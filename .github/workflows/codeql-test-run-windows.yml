name: ⚙️ CodeQL - Run Unit Tests (Windows)

# This workflow runs CodeQL unit tests for the 'javascript' language on Windows.
# The 'qlt' CLI is not supported on Windows, so this workflow uses 'codeql test run'
# directly, following the pattern from the Actions language unit tests workflow.
#
# Manual trigger only to conserve CI resources since Windows runners are slower.

on:
  workflow_dispatch:
    inputs:
      codeql_version:
        description: 'CodeQL CLI version (e.g., "latest", "v2.19.0", or specific version)'
        required: false
        default: 'latest'
        type: string

permissions:
  contents: read

jobs:
  discover-tests:
    name: Discover JavaScript Unit Tests
    runs-on: ubuntu-latest
    outputs:
      has_tests: ${{ steps.find-tests.outputs.has_tests }}
      test_count: ${{ steps.find-tests.outputs.test_count }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Find JavaScript unit tests
        id: find-tests
        shell: bash
        run: |
          echo "Searching for JavaScript unit tests..."

          # Find all .qlref files under javascript/frameworks (test directories)
          test_files=$(find javascript/frameworks -type f -name "*.qlref" 2>/dev/null || echo "")

          if [[ -z "$test_files" ]]; then
            echo "has_tests=false" >> $GITHUB_OUTPUT
            echo "test_count=0" >> $GITHUB_OUTPUT
            echo "❌ No JavaScript unit tests found"
          else
            test_count=$(echo "$test_files" | wc -l)
            echo "has_tests=true" >> $GITHUB_OUTPUT
            echo "test_count=$test_count" >> $GITHUB_OUTPUT
            echo "✅ Found $test_count JavaScript unit test(s)"
            echo ""
            echo "Sample test files:"
            echo "$test_files" | head -10
          fi

  run-windows-tests:
    name: Run Unit Tests (Windows)
    needs: [discover-tests]
    if: ${{ needs.discover-tests.outputs.has_tests == 'true' }}
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup CodeQL CLI
        id: setup-codeql
        shell: pwsh
        run: |
          $version = "${{ github.event.inputs.codeql_version }}"
          if ($version -eq "" -or $version -eq "latest") {
            # Get the latest release version from GitHub API
            $releaseInfo = Invoke-RestMethod -Uri "https://api.github.com/repos/github/codeql-cli-binaries/releases/latest"
            $version = $releaseInfo.tag_name
          }

          Write-Host "Installing CodeQL CLI version: $version"

          # Determine download URL for Windows
          $downloadUrl = "https://github.com/github/codeql-cli-binaries/releases/download/$version/codeql-win64.zip"

          # Create installation directory
          $installDir = "$env:RUNNER_TOOL_CACHE\codeql"
          New-Item -ItemType Directory -Force -Path $installDir | Out-Null

          # Download and extract CodeQL CLI
          $zipPath = "$env:RUNNER_TEMP\codeql.zip"
          Write-Host "Downloading from: $downloadUrl"
          Invoke-WebRequest -Uri $downloadUrl -OutFile $zipPath

          Write-Host "Extracting CodeQL CLI to: $installDir"
          Expand-Archive -Path $zipPath -DestinationPath $installDir -Force

          # Set up environment
          $codeqlPath = "$installDir\codeql"
          $codeqlExe = "$codeqlPath\codeql.exe"

          if (-not (Test-Path $codeqlExe)) {
            Write-Error "CodeQL executable not found at: $codeqlExe"
            exit 1
          }

          Write-Host "CodeQL executable: $codeqlExe"

          # Add to PATH for subsequent steps
          echo "$codeqlPath" >> $env:GITHUB_PATH
          echo "CODEQL_HOME=$codeqlPath" >> $env:GITHUB_ENV
          echo "codeql-path=$codeqlPath" >> $env:GITHUB_OUTPUT

          # Verify installation
          & $codeqlExe --version

      - name: Verify CodeQL Installation
        shell: pwsh
        run: |
          Write-Host "CodeQL version:"
          codeql --version

          Write-Host ""
          Write-Host "CodeQL resolve languages:"
          codeql resolve languages

      - name: Install QL Packs
        shell: pwsh
        run: |
          Write-Host "Installing QL packs from qlpack.yml files..."

          # Find all qlpack.yml files and install dependencies
          $qlpacks = Get-ChildItem -Path "javascript" -Filter "qlpack.yml" -Recurse

          foreach ($qlpack in $qlpacks) {
            $dir = $qlpack.DirectoryName
            Write-Host "Installing packs for: $dir"
            Push-Location $dir
            try {
              codeql pack install
            } catch {
              Write-Warning "Failed to install packs in $dir : $_"
            }
            Pop-Location
          }

          Write-Host "QL pack installation complete"

      - name: Setup Node.js for CDS compilation
        uses: actions/setup-node@v6
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: 'extractors/cds/tools/package-lock.json'

      - name: Verify Node.js and npm tools
        shell: pwsh
        run: |
          Write-Host "Node.js version: $(node --version)"
          Write-Host "npm version: $(npm --version)"
          Write-Host "npx version: $(npx --version)"

          # Verify npx can access @sap/cds-dk
          Write-Host "Testing npx access to @sap/cds-dk..."
          try {
            npx --yes --package @sap/cds-dk@latest cds --version
          } catch {
            Write-Host "CDS will be installed per-project as needed"
          }

      - name: Compile CAP CDS files
        shell: pwsh
        run: |
          # Compile CDS files in javascript/frameworks/cap/test directory
          # This is a Windows-compatible version of the cds-compilation-for-actions.sh script

          $baseDir = "javascript/frameworks/cap/test"

          if (-not (Test-Path $baseDir)) {
            Write-Host "Base directory '$baseDir' does not exist, skipping CDS compilation"
            exit 0
          }

          Write-Host "Compiling CDS files in: $baseDir"

          # Function to resolve CDS-DK version from package.json
          function Get-CdsDkVersion {
            param([string]$packageJsonPath)

            $minimumVersion = 8

            if (-not (Test-Path $packageJsonPath)) {
              return "^$minimumVersion"
            }

            $packageJson = Get-Content $packageJsonPath | ConvertFrom-Json

            $cdsDkVersion = $null
            $cdsVersion = $null

            # Check devDependencies and dependencies for @sap/cds-dk and @sap/cds
            if ($packageJson.devDependencies) {
              if ($packageJson.devDependencies.'@sap/cds-dk') {
                $cdsDkVersion = $packageJson.devDependencies.'@sap/cds-dk'
              }
              if ($packageJson.devDependencies.'@sap/cds') {
                $cdsVersion = $packageJson.devDependencies.'@sap/cds'
              }
            }

            if ($packageJson.dependencies) {
              if ($packageJson.dependencies.'@sap/cds-dk' -and -not $cdsDkVersion) {
                $cdsDkVersion = $packageJson.dependencies.'@sap/cds-dk'
              }
              if ($packageJson.dependencies.'@sap/cds' -and -not $cdsVersion) {
                $cdsVersion = $packageJson.dependencies.'@sap/cds'
              }
            }

            if ($cdsDkVersion) {
              # Extract major version and enforce minimum
              if ($cdsDkVersion -match '[\^~]?(\d+)') {
                $major = [int]$Matches[1]
                if ($major -lt $minimumVersion) {
                  return "^$minimumVersion"
                }
              }
              return $cdsDkVersion
            } elseif ($cdsVersion) {
              # Derive from @sap/cds version
              if ($cdsVersion -match '[\^~]?(\d+)') {
                $major = [int]$Matches[1]
                if ($major -lt $minimumVersion) {
                  return "^$minimumVersion"
                }
                return "^$major"
              }
            }

            return "^$minimumVersion"
          }

          # Find all package.json files that might contain CDS projects
          $projectDirs = Get-ChildItem -Path $baseDir -Recurse -Filter "package.json" |
            Where-Object { $_.FullName -notmatch "node_modules" } |
            Select-Object -ExpandProperty DirectoryName |
            Sort-Object -Unique

          foreach ($projectDir in $projectDirs) {
            $packageJsonPath = Join-Path $projectDir "package.json"

            # Check if this project has CDS files
            $cdsFiles = Get-ChildItem -Path $projectDir -Recurse -Filter "*.cds" -ErrorAction SilentlyContinue |
              Where-Object { $_.FullName -notmatch "node_modules" }

            if ($cdsFiles.Count -eq 0) {
              Write-Host "No CDS files found in: $projectDir"
              continue
            }

            Write-Host ""
            Write-Host "Processing project: $projectDir"
            Write-Host "Found $($cdsFiles.Count) CDS file(s)"

            # Get the appropriate CDS-DK version
            $cdsDkVersion = Get-CdsDkVersion -packageJsonPath $packageJsonPath
            Write-Host "Using @sap/cds-dk version: $cdsDkVersion"

            # Change to project directory for compilation
            Push-Location $projectDir

            try {
              # Compile CDS to JSON using npx
              Write-Host "Running: npx --yes --package @sap/cds-dk@$cdsDkVersion cds compile --to json"

              $compileArgs = @("--yes", "--package", "@sap/cds-dk@$cdsDkVersion", "cds", "compile", "--to", "json", "--dest", ".")

              # Check for index.cds or use standard CAP directories
              if (Test-Path "index.cds") {
                $compileArgs += "index.cds"
              } elseif ((Test-Path "db") -or (Test-Path "srv") -or (Test-Path "app")) {
                if (Test-Path "db") { $compileArgs += "db" }
                if (Test-Path "srv") { $compileArgs += "srv" }
                if (Test-Path "app") { $compileArgs += "app" }
              } else {
                # Compile individual CDS files
                foreach ($cdsFile in $cdsFiles) {
                  $relativePath = $cdsFile.FullName.Substring($projectDir.Length + 1)
                  $compileArgs += $relativePath
                }
              }

              npx @compileArgs

              # Rename .json files to .cds.json (excluding already renamed files)
              $jsonFiles = Get-ChildItem -Path $projectDir -Recurse -Filter "*.json" |
                Where-Object {
                  $_.Name -notmatch "\.cds\.json$" -and
                  $_.Name -notmatch "package\.json" -and
                  $_.Name -notmatch "package-lock\.json" -and
                  $_.Name -notmatch "tsconfig\.json" -and
                  $_.FullName -notmatch "node_modules"
                }

              foreach ($jsonFile in $jsonFiles) {
                $newName = $jsonFile.BaseName + ".cds.json"
                $newPath = Join-Path $jsonFile.DirectoryName $newName
                if (-not (Test-Path $newPath)) {
                  Write-Host "Renaming: $($jsonFile.Name) -> $newName"
                  Rename-Item -Path $jsonFile.FullName -NewName $newName
                }
              }

              Write-Host "✅ Compilation completed for: $projectDir"
            } catch {
              Write-Warning "Failed to compile CDS in $projectDir : $_"
            } finally {
              Pop-Location
            }
          }

          Write-Host ""
          Write-Host "CDS compilation complete"

      - name: Run CodeQL unit tests
        id: run-tests
        shell: pwsh
        env:
          LGTM_INDEX_XML_MODE: all
          LGTM_INDEX_FILETYPES: ".json:JSON\n.cds:JSON"
        run: |
          Write-Host "Running CodeQL unit tests for JavaScript language..."

          # Create results directory
          $resultsDir = Join-Path $env:RUNNER_TEMP "test-results"
          New-Item -ItemType Directory -Force -Path $resultsDir | Out-Null

          # Find all test directories containing .qlref files
          $testDirs = Get-ChildItem -Path "javascript/frameworks" -Recurse -Filter "*.qlref" |
            Select-Object -ExpandProperty DirectoryName |
            Sort-Object -Unique

          if ($testDirs.Count -eq 0) {
            Write-Host "❌ No test directories found"
            exit 1
          }

          Write-Host "Found $($testDirs.Count) test directory(ies):"
          $testDirs | ForEach-Object { Write-Host "  - $_" }
          Write-Host ""

          # Run tests using codeql test run
          # Join directories with space for the command
          $testDirArgs = $testDirs -join " "

          Write-Host "Running: codeql test run --format=text -- $testDirArgs"

          $outputFile = Join-Path $resultsDir "test-output.txt"

          # Run tests and capture output
          $testProcess = Start-Process -FilePath "codeql" -ArgumentList "test", "run", "--format=text", "--", $testDirArgs -Wait -PassThru -NoNewWindow -RedirectStandardOutput $outputFile -RedirectStandardError "$resultsDir\test-errors.txt"

          # Display output
          if (Test-Path $outputFile) {
            Get-Content $outputFile | Write-Host
          }

          if (Test-Path "$resultsDir\test-errors.txt") {
            $errors = Get-Content "$resultsDir\test-errors.txt"
            if ($errors) {
              Write-Host "Standard Error Output:"
              $errors | Write-Host
            }
          }

          # Check exit code
          if ($testProcess.ExitCode -ne 0) {
            Write-Host "❌ Tests failed with exit code: $($testProcess.ExitCode)"
            exit $testProcess.ExitCode
          }

          Write-Host "✅ Tests completed successfully"

      - name: Upload test results
        if: ${{ always() }}
        uses: actions/upload-artifact@v6
        with:
          name: windows-test-results-${{ runner.os }}
          path: |
            ${{ runner.temp }}/test-results/
          if-no-files-found: warn

  validate-results:
    name: Validate Windows Test Results
    needs: [discover-tests, run-windows-tests]
    if: ${{ needs.discover-tests.outputs.has_tests == 'true' && !cancelled() }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Download test results
        uses: actions/download-artifact@v7
        with:
          pattern: windows-test-results-*
          path: test-results/
          merge-multiple: true

      - name: Display test results
        shell: bash
        run: |
          echo "=== Windows Unit Test Results ==="

          # Check if results exist
          if [ ! -d "test-results/" ] || [ -z "$(find test-results/ -type f 2>/dev/null)" ]; then
            echo "❌ No test results found"
            exit 1
          fi

          # Display test output
          if [ -f "test-results/test-output.txt" ]; then
            echo "Test output:"
            cat test-results/test-output.txt
            echo ""
          fi

          # Check for failures
          if [ -f "test-results/test-output.txt" ]; then
            if grep -q "FAILED" test-results/test-output.txt 2>/dev/null; then
              echo "❌ Some tests failed. See output above for details."
              exit 1
            else
              echo "✅ All Windows tests passed successfully"
            fi
          fi

          echo "================================="
