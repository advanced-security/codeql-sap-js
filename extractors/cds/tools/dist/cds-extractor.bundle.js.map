{
  "version": 3,
  "sources": ["../cds-extractor.ts", "../node_modules/@isaacs/balanced-match/src/index.ts", "../node_modules/@isaacs/brace-expansion/src/index.ts", "../node_modules/glob/node_modules/minimatch/src/assert-valid-pattern.ts", "../node_modules/glob/node_modules/minimatch/src/brace-expressions.ts", "../node_modules/glob/node_modules/minimatch/src/unescape.ts", "../node_modules/glob/node_modules/minimatch/src/ast.ts", "../node_modules/glob/node_modules/minimatch/src/escape.ts", "../node_modules/glob/node_modules/minimatch/src/index.ts", "../node_modules/glob/src/glob.ts", "../node_modules/path-scurry/node_modules/lru-cache/src/index.ts", "../node_modules/path-scurry/src/index.ts", "../node_modules/minipass/src/index.ts", "../node_modules/glob/src/pattern.ts", "../node_modules/glob/src/ignore.ts", "../node_modules/glob/src/processor.ts", "../node_modules/glob/src/walker.ts", "../node_modules/glob/src/has-magic.ts", "../node_modules/glob/src/index.ts", "../src/cds/compiler/command.ts", "../src/filesystem.ts", "../src/logging/cdsExtractorLog.ts", "../src/logging/statusReport.ts", "../src/cds/compiler/compile.ts", "../src/cds/compiler/version.ts", "../src/cds/compiler/installer.ts", "../src/cds/compiler/validator.ts", "../src/diagnostics.ts", "../src/cds/compiler/retry.ts", "../src/cds/compiler/graph.ts", "../src/cds/compiler/project.ts", "../src/cds/parser/graph.ts", "../src/cds/parser/functions.ts", "../src/codeql.ts", "../src/environment.ts", "../src/packageManager/installer.ts", "../src/packageManager/versionResolver.ts", "../src/utils.ts"],
  "sourcesContent": ["import { join } from 'path';\n\nimport { sync as globSync } from 'glob';\n\nimport { orchestrateCompilation } from './src/cds/compiler';\nimport { buildCdsProjectDependencyGraph } from './src/cds/parser';\nimport { runJavaScriptExtractor } from './src/codeql';\nimport { addCompilationDiagnostic } from './src/diagnostics';\nimport { configureLgtmIndexFilters, setupAndValidateEnvironment } from './src/environment';\nimport {\n  cdsExtractorLog,\n  generateStatusReport,\n  logExtractorStart,\n  logExtractorStop,\n  logPerformanceMilestone,\n  logPerformanceTrackingStart,\n  logPerformanceTrackingStop,\n  setSourceRootDirectory,\n} from './src/logging';\nimport { installDependencies } from './src/packageManager';\nimport { validateArguments } from './src/utils';\n\n// Validate the script arguments.\nconst validationResult = validateArguments(process.argv);\nif (!validationResult.isValid) {\n  console.warn(validationResult.usageMessage);\n  // Exit with an error code on invalid use of this script.\n  process.exit(1);\n}\n\n// Get the validated and sanitized arguments.\nconst { sourceRoot } = validationResult.args!;\n\n// Initialize the unified logging system with the source root directory.\nsetSourceRootDirectory(sourceRoot);\n\n// Log the start of the CDS extractor session as a whole.\nlogExtractorStart(sourceRoot);\n\n// Setup the environment and validate all requirements first, before changing\n// directory back to the \"sourceRoot\" directory. This ensures we can properly locate\n// the CodeQL tools.\nlogPerformanceTrackingStart('Environment Setup');\nconst {\n  success: envSetupSuccess,\n  errorMessages,\n  codeqlExePath,\n  autobuildScriptPath,\n  platformInfo,\n} = setupAndValidateEnvironment(sourceRoot);\nlogPerformanceTrackingStop('Environment Setup');\n\nif (!envSetupSuccess) {\n  const codeqlExe = platformInfo.isWindows ? 'codeql.exe' : 'codeql';\n  cdsExtractorLog(\n    'warn',\n    `'${codeqlExe} database index-files --language cds' terminated early due to: ${errorMessages.join(\n      ', ',\n    )}.`,\n  );\n  // Exit with an error code when environment setup fails.\n  logExtractorStop(false, 'Terminated: Environment setup failed');\n  process.exit(1);\n}\n\n// Force this script, and any process it spawns, to use the project (source) root\n// directory as the current working directory.\nprocess.chdir(sourceRoot);\n\ncdsExtractorLog(\n  'info',\n  `CodeQL CDS extractor using autobuild mode for scan of project source root directory '${sourceRoot}'.`,\n);\n\ncdsExtractorLog('info', 'Building CDS project dependency graph...');\n\n// Build the CDS project `dependencyGraph` as the foundation for the extraction process.\n// This graph will contain all discovered CDS projects, their dependencies, the `.cds`\n// files discovered within each project, the expected `.cds.json` files for each project\n// and the compilation status of such `.cds.json` files.\n//\n// The `dependencyGraph` will be updated as CDS extractor phases progress, allowing for\n// a single data structure to be used for planning, execution, retries (i.e. error handling),\n// debugging, and final reporting.\nlet dependencyGraph;\n\ntry {\n  logPerformanceTrackingStart('Dependency Graph Build');\n  dependencyGraph = buildCdsProjectDependencyGraph(sourceRoot);\n  logPerformanceTrackingStop('Dependency Graph Build');\n\n  logPerformanceMilestone(\n    'Dependency graph created',\n    `${dependencyGraph.projects.size} projects, ${dependencyGraph.statusSummary.totalCdsFiles} CDS files`,\n  );\n\n  // Log details about discovered projects for debugging\n  if (dependencyGraph.projects.size > 0) {\n    for (const [projectDir, project] of dependencyGraph.projects.entries()) {\n      cdsExtractorLog(\n        'info',\n        `Project: ${projectDir}, Status: ${project.status}, CDS files: ${project.cdsFiles.length}, Compilations to run: ${project.cdsFilesToCompile.length}`,\n      );\n    }\n  } else {\n    cdsExtractorLog(\n      'error',\n      'No CDS projects were detected. This is an unrecoverable error as there is nothing to scan.',\n    );\n    // Let's also try to find CDS files directly as a backup check\n    try {\n      const allCdsFiles = Array.from(\n        new Set([\n          ...globSync(join(sourceRoot, '**/*.cds'), {\n            ignore: ['**/node_modules/**', '**/.git/**'],\n          }),\n        ]),\n      );\n      cdsExtractorLog(\n        'info',\n        `Direct search found ${allCdsFiles.length} CDS files in the source tree.`,\n      );\n      if (allCdsFiles.length > 0) {\n        cdsExtractorLog(\n          'info',\n          `Sample CDS files: ${allCdsFiles.slice(0, 5).join(', ')}${allCdsFiles.length > 5 ? ', ...' : ''}`,\n        );\n        cdsExtractorLog(\n          'error',\n          'CDS files were found but no projects were detected. This indicates a problem with project detection logic.',\n        );\n      } else {\n        cdsExtractorLog(\n          'info',\n          'No CDS files found in the source tree. This may be expected if the source does not contain CAP/CDS projects.',\n        );\n      }\n    } catch (globError) {\n      cdsExtractorLog('warn', `Could not perform direct CDS file search: ${String(globError)}`);\n    }\n\n    // Exit early since we have no CDS projects to process\n    logExtractorStop(false, 'Terminated: No CDS projects detected');\n    process.exit(1);\n  }\n} catch (error) {\n  cdsExtractorLog('error', `Failed to build CDS dependency graph: ${String(error)}`);\n  // Exit with error since we can't continue without a proper dependency graph\n  logExtractorStop(false, 'Terminated: Dependency graph build failed');\n  process.exit(1);\n}\n\nlogPerformanceTrackingStart('Dependency Installation');\nconst projectCacheDirMap = installDependencies(dependencyGraph, sourceRoot, codeqlExePath);\nlogPerformanceTrackingStop('Dependency Installation');\n\n// Check if dependency installation resulted in any usable project mappings\nif (projectCacheDirMap.size === 0) {\n  cdsExtractorLog(\n    'error',\n    'No project cache directory mappings were created. This indicates that dependency installation failed for all discovered projects.',\n  );\n\n  // This is a critical error if we have projects but no cache mappings\n  if (dependencyGraph.projects.size > 0) {\n    cdsExtractorLog(\n      'error',\n      `Found ${dependencyGraph.projects.size} CDS projects but failed to install dependencies for any of them. Cannot proceed with compilation.`,\n    );\n    logExtractorStop(false, 'Terminated: Dependency installation failed for all projects');\n    process.exit(1);\n  }\n\n  // If we have no projects and no cache mappings, this should have been caught earlier\n  cdsExtractorLog(\n    'warn',\n    'No projects and no cache mappings - this should have been detected earlier.',\n  );\n}\n\nconst cdsFilePathsToProcess: string[] = [];\n\n// Use the dependency graph to collect all `.cds` files from each project.\n// We want to \"extract\" all `.cds` files from all projects so that we have a copy\n// of each `.cds` source file in the CodeQL database.\nfor (const project of dependencyGraph.projects.values()) {\n  cdsFilePathsToProcess.push(...project.cdsFiles);\n}\n\n// TODO : Improve logging / debugging of dependencyGraph.statusSummary. Just log the JSON?\ncdsExtractorLog(\n  'info',\n  `Found ${cdsFilePathsToProcess.length} total CDS files, ${dependencyGraph.statusSummary.totalCdsFiles} CDS files in dependency graph`,\n);\n\nlogPerformanceTrackingStart('CDS Compilation');\ntry {\n  // Use the new orchestrated compilation approach (autobuild mode, no debug)\n  orchestrateCompilation(dependencyGraph, projectCacheDirMap, codeqlExePath);\n\n  // Handle compilation failures for normal mode\n  if (!dependencyGraph.statusSummary.overallSuccess) {\n    cdsExtractorLog(\n      'error',\n      `Compilation completed with failures: ${dependencyGraph.statusSummary.failedCompilations} failed out of ${dependencyGraph.statusSummary.totalCompilationTasks} total tasks`,\n    );\n\n    // Add diagnostics for critical errors\n    for (const error of dependencyGraph.errors.critical) {\n      cdsExtractorLog('error', `Critical error in ${error.phase}: ${error.message}`);\n    }\n\n    // Don't exit with error - let the JavaScript extractor run on whatever was compiled\n  }\n\n  logPerformanceTrackingStop('CDS Compilation');\n  logPerformanceMilestone('CDS compilation completed');\n} catch (error) {\n  logPerformanceTrackingStop('CDS Compilation');\n  cdsExtractorLog('error', `Compilation orchestration failed: ${String(error)}`);\n\n  // Add diagnostic for the overall failure\n  if (cdsFilePathsToProcess.length > 0) {\n    addCompilationDiagnostic(\n      cdsFilePathsToProcess[0], // Use first file as representative\n      `Compilation orchestration failed: ${String(error)}`,\n      codeqlExePath,\n    );\n  }\n}\n\n// Configure the \"LGTM\" index filters for proper extraction.\nconfigureLgtmIndexFilters();\n\n// Run CodeQL's JavaScript extractor to process the .cds source files and\n// the compiled .cds.json files.\nlogPerformanceTrackingStart('JavaScript Extraction');\nconst extractionStartTime = Date.now();\nconst extractorResult = runJavaScriptExtractor(sourceRoot, autobuildScriptPath, codeqlExePath);\nconst extractionEndTime = Date.now();\nlogPerformanceTrackingStop('JavaScript Extraction');\n\n// Update the dependency graph's performance metrics with the extraction duration\ndependencyGraph.statusSummary.performance.extractionDurationMs =\n  extractionEndTime - extractionStartTime;\n\n// Calculate total duration by summing all phases\nconst totalDuration =\n  dependencyGraph.statusSummary.performance.parsingDurationMs +\n  dependencyGraph.statusSummary.performance.compilationDurationMs +\n  dependencyGraph.statusSummary.performance.extractionDurationMs;\ndependencyGraph.statusSummary.performance.totalDurationMs = totalDuration;\n\nif (!extractorResult.success && extractorResult.error) {\n  cdsExtractorLog('error', `Error running JavaScript extractor: ${extractorResult.error}`);\n  logExtractorStop(false, 'JavaScript extractor failed');\n} else {\n  logExtractorStop(true, 'CDS extraction completed successfully');\n}\n\ncdsExtractorLog(\n  'info',\n  'CDS Extractor Status Report : Final...\\n' + generateStatusReport(dependencyGraph),\n);\n\n// Use the `cds-extractor.js` name in the log message as that is the name of the script\n// that is actually run by the `codeql database index-files` command. This TypeScript\n// file is where the code/logic is edited/implemented, but the runnable script is\n// generated by the TypeScript compiler and is named `cds-extractor.js`.\nconsole.log(`Completed run of the cds-extractor.js script for the CDS extractor.`);\n", "export const balanced = (\n  a: string | RegExp,\n  b: string | RegExp,\n  str: string,\n) => {\n  const ma = a instanceof RegExp ? maybeMatch(a, str) : a\n  const mb = b instanceof RegExp ? maybeMatch(b, str) : b\n\n  const r = ma !== null && mb != null && range(ma, mb, str)\n\n  return (\n    r && {\n      start: r[0],\n      end: r[1],\n      pre: str.slice(0, r[0]),\n      body: str.slice(r[0] + ma.length, r[1]),\n      post: str.slice(r[1] + mb.length),\n    }\n  )\n}\n\nconst maybeMatch = (reg: RegExp, str: string) => {\n  const m = str.match(reg)\n  return m ? m[0] : null\n}\n\nexport const range = (\n  a: string,\n  b: string,\n  str: string,\n): undefined | [number, number] => {\n  let begs: number[],\n    beg: number | undefined,\n    left: number,\n    right: number | undefined = undefined,\n    result: undefined | [number, number]\n  let ai = str.indexOf(a)\n  let bi = str.indexOf(b, ai + 1)\n  let i = ai\n\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi]\n    }\n    begs = []\n    left = str.length\n\n    while (i >= 0 && !result) {\n      if (i === ai) {\n        begs.push(i)\n        ai = str.indexOf(a, i + 1)\n      } else if (begs.length === 1) {\n        const r = begs.pop()\n        if (r !== undefined) result = [r, bi]\n      } else {\n        beg = begs.pop()\n        if (beg !== undefined && beg < left) {\n          left = beg\n          right = bi\n        }\n\n        bi = str.indexOf(b, i + 1)\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi\n    }\n\n    if (begs.length && right !== undefined) {\n      result = [left, right]\n    }\n  }\n\n  return result\n}\n", "import { balanced } from '@isaacs/balanced-match'\n\nconst escSlash = '\\0SLASH' + Math.random() + '\\0'\nconst escOpen = '\\0OPEN' + Math.random() + '\\0'\nconst escClose = '\\0CLOSE' + Math.random() + '\\0'\nconst escComma = '\\0COMMA' + Math.random() + '\\0'\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0'\nconst escSlashPattern = new RegExp(escSlash, 'g')\nconst escOpenPattern = new RegExp(escOpen, 'g')\nconst escClosePattern = new RegExp(escClose, 'g')\nconst escCommaPattern = new RegExp(escComma, 'g')\nconst escPeriodPattern = new RegExp(escPeriod, 'g')\nconst slashPattern = /\\\\\\\\/g\nconst openPattern = /\\\\{/g\nconst closePattern = /\\\\}/g\nconst commaPattern = /\\\\,/g\nconst periodPattern = /\\\\./g\n\nfunction numeric(str: string) {\n  return !isNaN(str as any) ? parseInt(str, 10) : str.charCodeAt(0)\n}\n\nfunction escapeBraces(str: string) {\n  return str\n    .replace(slashPattern, escSlash)\n    .replace(openPattern, escOpen)\n    .replace(closePattern, escClose)\n    .replace(commaPattern, escComma)\n    .replace(periodPattern, escPeriod)\n}\n\nfunction unescapeBraces(str: string) {\n  return str\n    .replace(escSlashPattern, '\\\\')\n    .replace(escOpenPattern, '{')\n    .replace(escClosePattern, '}')\n    .replace(escCommaPattern, ',')\n    .replace(escPeriodPattern, '.')\n}\n\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str: string) {\n  if (!str) {\n    return ['']\n  }\n\n  const parts: string[] = []\n  const m = balanced('{', '}', str)\n\n  if (!m) {\n    return str.split(',')\n  }\n\n  const { pre, body, post } = m\n  const p = pre.split(',')\n\n  p[p.length - 1] += '{' + body + '}'\n  const postParts = parseCommaParts(post)\n  if (post.length) {\n    ;(p[p.length - 1] as string) += postParts.shift()\n    p.push.apply(p, postParts)\n  }\n\n  parts.push.apply(parts, p)\n\n  return parts\n}\n\nexport function expand(str: string) {\n  if (!str) {\n    return []\n  }\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.slice(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.slice(2)\n  }\n\n  return expand_(escapeBraces(str), true).map(unescapeBraces)\n}\n\nfunction embrace(str: string) {\n  return '{' + str + '}'\n}\n\nfunction isPadded(el: string) {\n  return /^-?0\\d/.test(el)\n}\n\nfunction lte(i: number, y: number) {\n  return i <= y\n}\n\nfunction gte(i: number, y: number) {\n  return i >= y\n}\n\nfunction expand_(str: string, isTop?: boolean): string[] {\n  /** @type {string[]} */\n  const expansions: string[] = []\n\n  const m = balanced('{', '}', str)\n  if (!m) return [str]\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  const pre = m.pre\n  const post: string[] = m.post.length ? expand_(m.post, false) : ['']\n\n  if (/\\$$/.test(m.pre)) {\n    for (let k = 0; k < post.length; k++) {\n      const expansion = pre + '{' + m.body + '}' + post[k]\n      expansions.push(expansion)\n    }\n  } else {\n    const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isSequence = isNumericSequence || isAlphaSequence\n    const isOptions = m.body.indexOf(',') >= 0\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post\n        return expand_(str)\n      }\n      return [str]\n    }\n\n    let n: string[]\n    if (isSequence) {\n      n = m.body.split(/\\.\\./)\n    } else {\n      n = parseCommaParts(m.body)\n      if (n.length === 1 && n[0] !== undefined) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand_(n[0], false).map(embrace)\n        //XXX is this necessary? Can't seem to hit it in tests.\n        /* c8 ignore start */\n        if (n.length === 1) {\n          return post.map(p => m.pre + n[0] + p)\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    let N: string[]\n\n    if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n      const x = numeric(n[0])\n      const y = numeric(n[1])\n      const width = Math.max(n[0].length, n[1].length)\n      let incr =\n        n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1\n      let test = lte\n      const reverse = y < x\n      if (reverse) {\n        incr *= -1\n        test = gte\n      }\n      const pad = n.some(isPadded)\n\n      N = []\n\n      for (let i = x; test(i, y); i += incr) {\n        let c\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i)\n          if (c === '\\\\') {\n            c = ''\n          }\n        } else {\n          c = String(i)\n          if (pad) {\n            const need = width - c.length\n            if (need > 0) {\n              const z = new Array(need + 1).join('0')\n              if (i < 0) {\n                c = '-' + z + c.slice(1)\n              } else {\n                c = z + c\n              }\n            }\n          }\n        }\n        N.push(c)\n      }\n    } else {\n      N = []\n\n      for (let j = 0; j < n.length; j++) {\n        N.push.apply(N, expand_(n[j] as string, false))\n      }\n    }\n\n    for (let j = 0; j < N.length; j++) {\n      for (let k = 0; k < post.length; k++) {\n        const expansion = pre + N[j] + post[k]\n        if (!isTop || isSequence || expansion) {\n          expansions.push(expansion)\n        }\n      }\n    }\n  }\n\n  return expansions\n}\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import { expand } from '@isaacs/brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "import { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { fileURLToPath } from 'node:url'\nimport {\n  FSOption,\n  Path,\n  PathScurry,\n  PathScurryDarwin,\n  PathScurryPosix,\n  PathScurryWin32,\n} from 'path-scurry'\nimport { IgnoreLike } from './ignore.js'\nimport { Pattern } from './pattern.js'\nimport { GlobStream, GlobWalker } from './walker.js'\n\nexport type MatchSet = Minimatch['set']\nexport type GlobParts = Exclude<Minimatch['globParts'], undefined>\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform: NodeJS.Platform =\n  (\n    typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n  ) ?\n    process.platform\n  : 'linux'\n\n/**\n * A `GlobOptions` object may be provided to any of the exported methods, and\n * must be provided to the `Glob` constructor.\n *\n * All options are optional, boolean, and false by default, unless otherwise\n * noted.\n *\n * All resolved options are added to the Glob object as properties.\n *\n * If you are running many `glob` operations, you can pass a Glob object as the\n * `options` argument to a subsequent operation to share the previously loaded\n * cache.\n */\nexport interface GlobOptions {\n  /**\n   * Set to `true` to always receive absolute paths for\n   * matched files. Set to `false` to always return relative paths.\n   *\n   * When this option is not set, absolute paths are returned for patterns\n   * that are absolute, and otherwise paths are returned that are relative\n   * to the `cwd` setting.\n   *\n   * This does _not_ make an extra system call to get\n   * the realpath, it only does string path resolution.\n   *\n   * Conflicts with {@link withFileTypes}\n   */\n  absolute?: boolean\n\n  /**\n   * Set to false to enable {@link windowsPathsNoEscape}\n   *\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n\n  /**\n   * The current working directory in which to search. Defaults to\n   * `process.cwd()`.\n   *\n   * May be eiher a string path or a `file://` URL object or string.\n   */\n  cwd?: string | URL\n\n  /**\n   * Include `.dot` files in normal matches and `globstar`\n   * matches. Note that an explicit dot in a portion of the pattern\n   * will always match dot files.\n   */\n  dot?: boolean\n\n  /**\n   * Prepend all relative path strings with `./` (or `.\\` on Windows).\n   *\n   * Without this option, returned relative paths are \"bare\", so instead of\n   * returning `'./foo/bar'`, they are returned as `'foo/bar'`.\n   *\n   * Relative patterns starting with `'../'` are not prepended with `./`, even\n   * if this option is set.\n   */\n  dotRelative?: boolean\n\n  /**\n   * Follow symlinked directories when expanding `**`\n   * patterns. This can result in a lot of duplicate references in\n   * the presence of cyclic links, and make performance quite bad.\n   *\n   * By default, a `**` in a pattern will follow 1 symbolic link if\n   * it is not the first item in the pattern, or none if it is the\n   * first item in the pattern, following the same behavior as Bash.\n   */\n  follow?: boolean\n\n  /**\n   * string or string[], or an object with `ignored` and `childrenIgnored`\n   * methods.\n   *\n   * If a string or string[] is provided, then this is treated as a glob\n   * pattern or array of glob patterns to exclude from matches. To ignore all\n   * children within a directory, as well as the entry itself, append `'/**'`\n   * to the ignore pattern.\n   *\n   * **Note** `ignore` patterns are _always_ in `dot:true` mode, regardless of\n   * any other settings.\n   *\n   * If an object is provided that has `ignored(path)` and/or\n   * `childrenIgnored(path)` methods, then these methods will be called to\n   * determine whether any Path is a match or if its children should be\n   * traversed, respectively.\n   */\n  ignore?: string | string[] | IgnoreLike\n\n  /**\n   * Treat brace expansion like `{a,b}` as a \"magic\" pattern. Has no\n   * effect if {@link nobrace} is set.\n   *\n   * Only has effect on the {@link hasMagic} function.\n   */\n  magicalBraces?: boolean\n\n  /**\n   * Add a `/` character to directory matches. Note that this requires\n   * additional stat calls in some cases.\n   */\n  mark?: boolean\n\n  /**\n   * Perform a basename-only match if the pattern does not contain any slash\n   * characters. That is, `*.js` would be treated as equivalent to\n   * `**\\/*.js`, matching all js files in all directories.\n   */\n  matchBase?: boolean\n\n  /**\n   * Limit the directory traversal to a given depth below the cwd.\n   * Note that this does NOT prevent traversal to sibling folders,\n   * root patterns, and so on. It only limits the maximum folder depth\n   * that the walk will descend, relative to the cwd.\n   */\n  maxDepth?: number\n\n  /**\n   * Do not expand `{a,b}` and `{1..3}` brace sets.\n   */\n  nobrace?: boolean\n\n  /**\n   * Perform a case-insensitive match. This defaults to `true` on macOS and\n   * Windows systems, and `false` on all others.\n   *\n   * **Note** `nocase` should only be explicitly set when it is\n   * known that the filesystem's case sensitivity differs from the\n   * platform default. If set `true` on case-sensitive file\n   * systems, or `false` on case-insensitive file systems, then the\n   * walk may return more or less results than expected.\n   */\n  nocase?: boolean\n\n  /**\n   * Do not match directories, only files. (Note: to match\n   * _only_ directories, put a `/` at the end of the pattern.)\n   */\n  nodir?: boolean\n\n  /**\n   * Do not match \"extglob\" patterns such as `+(a|b)`.\n   */\n  noext?: boolean\n\n  /**\n   * Do not match `**` against multiple filenames. (Ie, treat it as a normal\n   * `*` instead.)\n   *\n   * Conflicts with {@link matchBase}\n   */\n  noglobstar?: boolean\n\n  /**\n   * Defaults to value of `process.platform` if available, or `'linux'` if\n   * not. Setting `platform:'win32'` on non-Windows systems may cause strange\n   * behavior.\n   */\n  platform?: NodeJS.Platform\n\n  /**\n   * Set to true to call `fs.realpath` on all of the\n   * results. In the case of an entry that cannot be resolved, the\n   * entry is omitted. This incurs a slight performance penalty, of\n   * course, because of the added system calls.\n   */\n  realpath?: boolean\n\n  /**\n   *\n   * A string path resolved against the `cwd` option, which\n   * is used as the starting point for absolute patterns that start\n   * with `/`, (but not drive letters or UNC paths on Windows).\n   *\n   * Note that this _doesn't_ necessarily limit the walk to the\n   * `root` directory, and doesn't affect the cwd starting point for\n   * non-absolute patterns. A pattern containing `..` will still be\n   * able to traverse out of the root directory, if it is not an\n   * actual root directory on the filesystem, and any non-absolute\n   * patterns will be matched in the `cwd`. For example, the\n   * pattern `/../*` with `{root:'/some/path'}` will return all\n   * files in `/some`, not all files in `/some/path`. The pattern\n   * `*` with `{root:'/some/path'}` will return all the entries in\n   * the cwd, not the entries in `/some/path`.\n   *\n   * To start absolute and non-absolute patterns in the same\n   * path, you can use `{root:''}`. However, be aware that on\n   * Windows systems, a pattern like `x:/*` or `//host/share/*` will\n   * _always_ start in the `x:/` or `//host/share` directory,\n   * regardless of the `root` setting.\n   */\n  root?: string\n\n  /**\n   * A [PathScurry](http://npm.im/path-scurry) object used\n   * to traverse the file system. If the `nocase` option is set\n   * explicitly, then any provided `scurry` object must match this\n   * setting.\n   */\n  scurry?: PathScurry\n\n  /**\n   * Call `lstat()` on all entries, whether required or not to determine\n   * if it's a valid match. When used with {@link withFileTypes}, this means\n   * that matches will include data such as modified time, permissions, and\n   * so on.  Note that this will incur a performance cost due to the added\n   * system calls.\n   */\n  stat?: boolean\n\n  /**\n   * An AbortSignal which will cancel the Glob walk when\n   * triggered.\n   */\n  signal?: AbortSignal\n\n  /**\n   * Use `\\\\` as a path separator _only_, and\n   *  _never_ as an escape character. If set, all `\\\\` characters are\n   *  replaced with `/` in the pattern.\n   *\n   *  Note that this makes it **impossible** to match against paths\n   *  containing literal glob pattern characters, but allows matching\n   *  with patterns constructed using `path.join()` and\n   *  `path.resolve()` on Windows platforms, mimicking the (buggy!)\n   *  behavior of Glob v7 and before on Windows. Please use with\n   *  caution, and be mindful of [the caveat below about Windows\n   *  paths](#windows). (For legacy reasons, this is also set if\n   *  `allowWindowsEscape` is set to the exact value `false`.)\n   */\n  windowsPathsNoEscape?: boolean\n\n  /**\n   * Return [PathScurry](http://npm.im/path-scurry)\n   * `Path` objects instead of strings. These are similar to a\n   * NodeJS `Dirent` object, but with additional methods and\n   * properties.\n   *\n   * Conflicts with {@link absolute}\n   */\n  withFileTypes?: boolean\n\n  /**\n   * An fs implementation to override some or all of the defaults.  See\n   * http://npm.im/path-scurry for details about what can be overridden.\n   */\n  fs?: FSOption\n\n  /**\n   * Just passed along to Minimatch.  Note that this makes all pattern\n   * matching operations slower and *extremely* noisy.\n   */\n  debug?: boolean\n\n  /**\n   * Return `/` delimited paths, even on Windows.\n   *\n   * On posix systems, this has no effect.  But, on Windows, it means that\n   * paths will be `/` delimited, and absolute paths will be their full\n   * resolved UNC forms, eg instead of `'C:\\\\foo\\\\bar'`, it would return\n   * `'//?/C:/foo/bar'`\n   */\n  posix?: boolean\n\n  /**\n   * Do not match any children of any matches. For example, the pattern\n   * `**\\/foo` would match `a/foo`, but not `a/foo/b/foo` in this mode.\n   *\n   * This is especially useful for cases like \"find all `node_modules`\n   * folders, but not the ones in `node_modules`\".\n   *\n   * In order to support this, the `Ignore` implementation must support an\n   * `add(pattern: string)` method. If using the default `Ignore` class, then\n   * this is fine, but if this is set to `false`, and a custom `Ignore` is\n   * provided that does not have an `add()` method, then it will throw an\n   * error.\n   *\n   * **Caveat** It *only* ignores matches that would be a descendant of a\n   * previous match, and only if that descendant is matched *after* the\n   * ancestor is encountered. Since the file system walk happens in\n   * indeterminate order, it's possible that a match will already be added\n   * before its ancestor, if multiple or braced patterns are used.\n   *\n   * For example:\n   *\n   * ```ts\n   * const results = await glob([\n   *   // likely to match first, since it's just a stat\n   *   'a/b/c/d/e/f',\n   *\n   *   // this pattern is more complicated! It must to various readdir()\n   *   // calls and test the results against a regular expression, and that\n   *   // is certainly going to take a little bit longer.\n   *   //\n   *   // So, later on, it encounters a match at 'a/b/c/d/e', but it's too\n   *   // late to ignore a/b/c/d/e/f, because it's already been emitted.\n   *   'a/[bdf]/?/[a-z]/*',\n   * ], { includeChildMatches: false })\n   * ```\n   *\n   * It's best to only set this to `false` if you can be reasonably sure that\n   * no components of the pattern will potentially match one another's file\n   * system descendants, or if the occasional included child entry will not\n   * cause problems.\n   *\n   * @default true\n   */\n  includeChildMatches?: boolean\n}\n\nexport type GlobOptionsWithFileTypesTrue = GlobOptions & {\n  withFileTypes: true\n  // string options not relevant if returning Path objects.\n  absolute?: undefined\n  mark?: undefined\n  posix?: undefined\n}\n\nexport type GlobOptionsWithFileTypesFalse = GlobOptions & {\n  withFileTypes?: false\n}\n\nexport type GlobOptionsWithFileTypesUnset = GlobOptions & {\n  withFileTypes?: undefined\n}\n\nexport type Result<Opts> =\n  Opts extends GlobOptionsWithFileTypesTrue ? Path\n  : Opts extends GlobOptionsWithFileTypesFalse ? string\n  : Opts extends GlobOptionsWithFileTypesUnset ? string\n  : string | Path\nexport type Results<Opts> = Result<Opts>[]\n\nexport type FileTypes<Opts> =\n  Opts extends GlobOptionsWithFileTypesTrue ? true\n  : Opts extends GlobOptionsWithFileTypesFalse ? false\n  : Opts extends GlobOptionsWithFileTypesUnset ? false\n  : boolean\n\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob<Opts extends GlobOptions> implements GlobOptions {\n  absolute?: boolean\n  cwd: string\n  root?: string\n  dot: boolean\n  dotRelative: boolean\n  follow: boolean\n  ignore?: string | string[] | IgnoreLike\n  magicalBraces: boolean\n  mark?: boolean\n  matchBase: boolean\n  maxDepth: number\n  nobrace: boolean\n  nocase: boolean\n  nodir: boolean\n  noext: boolean\n  noglobstar: boolean\n  pattern: string[]\n  platform: NodeJS.Platform\n  realpath: boolean\n  scurry: PathScurry\n  stat: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape: boolean\n  withFileTypes: FileTypes<Opts>\n  includeChildMatches: boolean\n\n  /**\n   * The options provided to the constructor.\n   */\n  opts: Opts\n\n  /**\n   * An array of parsed immutable {@link Pattern} objects.\n   */\n  patterns: Pattern[]\n\n  /**\n   * All options are stored as properties on the `Glob` object.\n   *\n   * See {@link GlobOptions} for full options descriptions.\n   *\n   * Note that a previous `Glob` object can be passed as the\n   * `GlobOptions` to another `Glob` instantiation to re-use settings\n   * and caches with a new pattern.\n   *\n   * Traversal functions can be called multiple times to run the walk\n   * again.\n   */\n  constructor(pattern: string | string[], opts: Opts) {\n    /* c8 ignore start */\n    if (!opts) throw new TypeError('glob options required')\n    /* c8 ignore stop */\n    this.withFileTypes = !!opts.withFileTypes as FileTypes<Opts>\n    this.signal = opts.signal\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.dotRelative = !!opts.dotRelative\n    this.nodir = !!opts.nodir\n    this.mark = !!opts.mark\n    if (!opts.cwd) {\n      this.cwd = ''\n    } else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n      opts.cwd = fileURLToPath(opts.cwd)\n    }\n    this.cwd = opts.cwd || ''\n    this.root = opts.root\n    this.magicalBraces = !!opts.magicalBraces\n    this.nobrace = !!opts.nobrace\n    this.noext = !!opts.noext\n    this.realpath = !!opts.realpath\n    this.absolute = opts.absolute\n    this.includeChildMatches = opts.includeChildMatches !== false\n\n    this.noglobstar = !!opts.noglobstar\n    this.matchBase = !!opts.matchBase\n    this.maxDepth =\n      typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity\n    this.stat = !!opts.stat\n    this.ignore = opts.ignore\n\n    if (this.withFileTypes && this.absolute !== undefined) {\n      throw new Error('cannot set absolute and withFileTypes:true')\n    }\n\n    if (typeof pattern === 'string') {\n      pattern = [pattern]\n    }\n\n    this.windowsPathsNoEscape =\n      !!opts.windowsPathsNoEscape ||\n      (opts as { allowWindowsEscape?: boolean }).allowWindowsEscape ===\n        false\n\n    if (this.windowsPathsNoEscape) {\n      pattern = pattern.map(p => p.replace(/\\\\/g, '/'))\n    }\n\n    if (this.matchBase) {\n      if (opts.noglobstar) {\n        throw new TypeError('base matching requires globstar')\n      }\n      pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`))\n    }\n\n    this.pattern = pattern\n\n    this.platform = opts.platform || defaultPlatform\n    this.opts = { ...opts, platform: this.platform }\n    if (opts.scurry) {\n      this.scurry = opts.scurry\n      if (\n        opts.nocase !== undefined &&\n        opts.nocase !== opts.scurry.nocase\n      ) {\n        throw new Error('nocase option contradicts provided scurry option')\n      }\n    } else {\n      const Scurry =\n        opts.platform === 'win32' ? PathScurryWin32\n        : opts.platform === 'darwin' ? PathScurryDarwin\n        : opts.platform ? PathScurryPosix\n        : PathScurry\n      this.scurry = new Scurry(this.cwd, {\n        nocase: opts.nocase,\n        fs: opts.fs,\n      })\n    }\n    this.nocase = this.scurry.nocase\n\n    // If you do nocase:true on a case-sensitive file system, then\n    // we need to use regexps instead of strings for non-magic\n    // path portions, because statting `aBc` won't return results\n    // for the file `AbC` for example.\n    const nocaseMagicOnly =\n      this.platform === 'darwin' || this.platform === 'win32'\n\n    const mmo: MinimatchOptions = {\n      // default nocase based on platform\n      ...opts,\n      dot: this.dot,\n      matchBase: this.matchBase,\n      nobrace: this.nobrace,\n      nocase: this.nocase,\n      nocaseMagicOnly,\n      nocomment: true,\n      noext: this.noext,\n      nonegate: true,\n      optimizationLevel: 2,\n      platform: this.platform,\n      windowsPathsNoEscape: this.windowsPathsNoEscape,\n      debug: !!this.opts.debug,\n    }\n\n    const mms = this.pattern.map(p => new Minimatch(p, mmo))\n    const [matchSet, globParts] = mms.reduce(\n      (set: [MatchSet, GlobParts], m) => {\n        set[0].push(...m.set)\n        set[1].push(...m.globParts)\n        return set\n      },\n      [[], []],\n    )\n    this.patterns = matchSet.map((set, i) => {\n      const g = globParts[i]\n      /* c8 ignore start */\n      if (!g) throw new Error('invalid pattern object')\n      /* c8 ignore stop */\n      return new Pattern(set, g, 0, this.platform)\n    })\n  }\n\n  /**\n   * Returns a Promise that resolves to the results array.\n   */\n  async walk(): Promise<Results<Opts>>\n  async walk(): Promise<(string | Path)[]> {\n    // Walkers always return array of Path objects, so we just have to\n    // coerce them into the right shape.  It will have already called\n    // realpath() if the option was set to do so, so we know that's cached.\n    // start out knowing the cwd, at least\n    return [\n      ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity ?\n            this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n        includeChildMatches: this.includeChildMatches,\n      }).walk()),\n    ]\n  }\n\n  /**\n   * synchronous {@link Glob.walk}\n   */\n  walkSync(): Results<Opts>\n  walkSync(): (string | Path)[] {\n    return [\n      ...new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity ?\n            this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n        includeChildMatches: this.includeChildMatches,\n      }).walkSync(),\n    ]\n  }\n\n  /**\n   * Stream results asynchronously.\n   */\n  stream(): Minipass<Result<Opts>, Result<Opts>>\n  stream(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity ?\n          this.maxDepth + this.scurry.cwd.depth()\n        : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n      includeChildMatches: this.includeChildMatches,\n    }).stream()\n  }\n\n  /**\n   * Stream results synchronously.\n   */\n  streamSync(): Minipass<Result<Opts>, Result<Opts>>\n  streamSync(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity ?\n          this.maxDepth + this.scurry.cwd.depth()\n        : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n      includeChildMatches: this.includeChildMatches,\n    }).streamSync()\n  }\n\n  /**\n   * Default sync iteration function. Returns a Generator that\n   * iterates over the results.\n   */\n  iterateSync(): Generator<Result<Opts>, void, void> {\n    return this.streamSync()[Symbol.iterator]()\n  }\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  /**\n   * Default async iteration function. Returns an AsyncGenerator that\n   * iterates over the results.\n   */\n  iterate(): AsyncGenerator<Result<Opts>, void, void> {\n    return this.stream()[Symbol.asyncIterator]()\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n}\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * The reason why an item was added to the cache, passed\n   * to the {@link Inserter} methods.\n   *\n   * - `add`: the item was not found in the cache, and was added\n   * - `update`: the item was in the cache, with the same value provided\n   * - `replace`: the item was in the cache, and replaced\n   */\n  export type InsertReason = 'add' | 'update' | 'replace'\n\n  /**\n   * A method called upon item insertion, passed as the\n   * {@link OptionsBase.insert}\n   */\n  export type Inserter<K, V> = (\n    value: V,\n    key: K,\n    reason: InsertReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * Function that is called when new items are inserted into the cache,\n     * as `onInsert(value, key, reason)`.\n     *\n     * This can be useful if you need to perform actions when an item is\n     * added, such as logging or tracking insertions.\n     *\n     * Unlike some other options, this may _not_ be overridden by passing\n     * an option to `set()`, for performance and consistency reasons.\n     */\n    onInsert?: Inserter<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> {\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #onInsert?: LRUCache.Inserter<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n  #hasOnInsert: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.onInsert} (read-only)\n   */\n  get onInsert() {\n    return this.#onInsert\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      onInsert,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof onInsert === 'function') {\n      this.#onInsert = onInsert\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasOnInsert = !!this.#onInsert\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n      if (this.#hasOnInsert) {\n        this.#onInsert?.(v as V, k, 'add')\n      }\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n\n      if (this.#hasOnInsert) {\n        this.onInsert?.(v as V, k, v === oldVal ? 'update' : 'replace');\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link LRUCache.OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'node:path'\n\nimport { fileURLToPath } from 'node:url'\n\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nimport * as actualFS from 'node:fs'\n\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\n\nimport { lstat, readdir, readlink, realpath } from 'node:fs/promises'\n\nimport { Minipass } from 'minipass'\nimport type { Dirent, Stats } from 'node:fs'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true },\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS ?\n    defaultFS\n  : {\n      ...defaultFS,\n      ...fsOption,\n      promises: {\n        ...defaultFS.promises,\n        ...(fsOption.promises || {}),\n      },\n    }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile() ? IFREG\n  : s.isDirectory() ? IFDIR\n  : s.isSymbolicLink() ? IFLNK\n  : s.isCharacterDevice() ? IFCHR\n  : s.isBlockDevice() ? IFBLK\n  : s.isSocket() ? IFSOCK\n  : s.isFIFO() ? IFIFO\n  : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * boolean indicating that this path is the current working directory\n   * of the PathScurry collection that contains it.\n   */\n  isCWD: boolean = false\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['parentPath'] refers to the path of the\n   * directory that was passed to readdir. For root entries, it's the path\n   * to the entry itself.\n   */\n  get parentPath(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n   * this property refers to the *parent* path, not the path object itself.\n   *\n   * @deprecated\n   */\n  get path(): string {\n    return this.parentPath\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase =\n      rootPath ?\n        this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name =\n      this.nocase ? normalizeNocase(pathPart) : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath =\n      this.#fullpath ? this.#fullpath + s + pathPart : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.isCWD) return ''\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.isCWD) return ''\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return (\n      this.isUnknown() ? 'Unknown'\n      : this.isDirectory() ? 'Directory'\n      : this.isFile() ? 'File'\n      : this.isSymbolicLink() ? 'SymbolicLink'\n      : this.isFIFO() ? 'FIFO'\n      : this.isCharacterDevice() ? 'CharacterDevice'\n      : this.isBlockDevice() ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket() ? 'Socket'\n      : 'Unknown'\n    )\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase ?\n        this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = (await this.parent.realpath())?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.realpathSync()?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      const c = children[p]\n      if (c) c.#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name =\n        this.nocase ? normalizeNocase(e.name) : normalize(e.name)\n      if (name !== pchild!.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild!, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children,\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[],\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false,\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res),\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean,\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n    oldCwd.isCWD = false\n    this.isCWD = true\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this,\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {},\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor',\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd,\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void,\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next(),\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {},\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false,\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r,\n                    ),\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true),\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32' ? PathScurryWin32\n  : process.platform === 'darwin' ? PathScurryDarwin\n  : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n", "const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'node:events'\nimport Stream from 'node:stream'\nimport { StringDecoder } from 'node:string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> =\n    | ObjectModeOptions\n    | (T extends string\n        ? EncodingOptions\n        : T extends Buffer\n        ? BufferOptions\n        : SharedOptions)\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args:\n      | [Minipass.ObjectModeOptions]\n      | (RType extends Buffer\n          ? [] | [Minipass.Options<RType>]\n          : [Minipass.Options<RType>])\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): this {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data as RType) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n", "// this is just a very light wrapper around 2 arrays with an offset index\n\nimport { GLOBSTAR } from 'minimatch'\nexport type MMPattern = string | RegExp | typeof GLOBSTAR\n\n// an array of length >= 1\nexport type PatternList = [p: MMPattern, ...rest: MMPattern[]]\nexport type UNCPatternList = [\n  p0: '',\n  p1: '',\n  p2: string,\n  p3: string,\n  ...rest: MMPattern[],\n]\nexport type DrivePatternList = [p0: string, ...rest: MMPattern[]]\nexport type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]\nexport type GlobList = [p: string, ...rest: string[]]\n\nconst isPatternList = (pl: MMPattern[]): pl is PatternList =>\n  pl.length >= 1\nconst isGlobList = (gl: string[]): gl is GlobList => gl.length >= 1\n\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n  readonly #patternList: PatternList\n  readonly #globList: GlobList\n  readonly #index: number\n  readonly length: number\n  readonly #platform: NodeJS.Platform\n  #rest?: Pattern | null\n  #globString?: string\n  #isDrive?: boolean\n  #isUNC?: boolean\n  #isAbsolute?: boolean\n  #followGlobstar: boolean = true\n\n  constructor(\n    patternList: MMPattern[],\n    globList: string[],\n    index: number,\n    platform: NodeJS.Platform,\n  ) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list')\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list')\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths')\n    }\n    this.length = patternList.length\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range')\n    }\n    this.#patternList = patternList\n    this.#globList = globList\n    this.#index = index\n    this.#platform = platform\n\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList\n        const [g0, g1, g2, g3, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = [p0, p1, p2, p3, ''].join('/')\n        const g = [g0, g1, g2, g3, ''].join('/')\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList\n        const [g1, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = (p1 as string) + '/'\n        const g = g1 + '/'\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      }\n    }\n  }\n\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern(): MMPattern {\n    return this.#patternList[this.#index] as MMPattern\n  }\n\n  /**\n   * true of if pattern() returns a string\n   */\n  isString(): boolean {\n    return typeof this.#patternList[this.#index] === 'string'\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar(): boolean {\n    return this.#patternList[this.#index] === GLOBSTAR\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp(): boolean {\n    return this.#patternList[this.#index] instanceof RegExp\n  }\n\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString(): string {\n    return (this.#globString =\n      this.#globString ||\n      (this.#index === 0 ?\n        this.isAbsolute() ?\n          this.#globList[0] + this.#globList.slice(1).join('/')\n        : this.#globList.join('/')\n      : this.#globList.slice(this.#index).join('/')))\n  }\n\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore(): boolean {\n    return this.length > this.#index + 1\n  }\n\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest(): Pattern | null {\n    if (this.#rest !== undefined) return this.#rest\n    if (!this.hasMore()) return (this.#rest = null)\n    this.#rest = new Pattern(\n      this.#patternList,\n      this.#globList,\n      this.#index + 1,\n      this.#platform,\n    )\n    this.#rest.#isAbsolute = this.#isAbsolute\n    this.#rest.#isUNC = this.#isUNC\n    this.#rest.#isDrive = this.#isDrive\n    return this.#rest\n  }\n\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC(): boolean {\n    const pl = this.#patternList\n    return this.#isUNC !== undefined ?\n        this.#isUNC\n      : (this.#isUNC =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          pl[0] === '' &&\n          pl[1] === '' &&\n          typeof pl[2] === 'string' &&\n          !!pl[2] &&\n          typeof pl[3] === 'string' &&\n          !!pl[3])\n  }\n\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive(): boolean {\n    const pl = this.#patternList\n    return this.#isDrive !== undefined ?\n        this.#isDrive\n      : (this.#isDrive =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          this.length > 1 &&\n          typeof pl[0] === 'string' &&\n          /^[a-z]:$/i.test(pl[0]))\n  }\n\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute(): boolean {\n    const pl = this.#patternList\n    return this.#isAbsolute !== undefined ?\n        this.#isAbsolute\n      : (this.#isAbsolute =\n          (pl[0] === '' && pl.length > 1) ||\n          this.isDrive() ||\n          this.isUNC())\n  }\n\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root(): string {\n    const p = this.#patternList[0]\n    return (\n        typeof p === 'string' && this.isAbsolute() && this.#index === 0\n      ) ?\n        p\n      : ''\n  }\n\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar(): boolean {\n    return !(\n      this.#index === 0 ||\n      !this.isGlobstar() ||\n      !this.#followGlobstar\n    )\n  }\n\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar(): boolean {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n      return false\n    this.#followGlobstar = false\n    return true\n  }\n}\n", "// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n  add?: (ignore: string) => void\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  (\n    typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n  ) ?\n    process.platform\n  : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n  platform: NodeJS.Platform\n  mmopts: MinimatchOptions\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts,\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    this.platform = platform\n    this.mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n    for (const ign of ignored) this.add(ign)\n  }\n\n  add(ign: string) {\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    const mm = new Minimatch(ign, this.mmopts)\n    for (let i = 0; i < mm.set.length; i++) {\n      const parsed = mm.set[i]\n      const globParts = mm.globParts[i]\n      /* c8 ignore start */\n      if (!parsed || !globParts) {\n        throw new Error('invalid pattern object')\n      }\n      // strip off leading ./ portions\n      // https://github.com/isaacs/node-glob/issues/570\n      while (parsed[0] === '.' && globParts[0] === '.') {\n        parsed.shift()\n        globParts.shift()\n      }\n      /* c8 ignore stop */\n      const p = new Pattern(parsed, globParts, 0, this.platform)\n      const m = new Minimatch(p.globString(), this.mmopts)\n      const children = globParts[globParts.length - 1] === '**'\n      const absolute = p.isAbsolute()\n      if (absolute) this.absolute.push(m)\n      else this.relative.push(m)\n      if (children) {\n        if (absolute) this.absoluteChildren.push(m)\n        else this.relativeChildren.push(m)\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n", "// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache =\n      hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined ?\n            this.opts.root\n          : root,\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n", "/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n  includeChildMatches?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Path\n  : O extends GWOFileTypesFalse ? string\n  : O extends GWOFileTypesUnset ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Set<Path>\n  : O extends GWOFileTypesFalse ? Set<string>\n  : O extends GWOFileTypesUnset ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> = Minipass<\n  Result<O>,\n  Result<O>\n>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts,\n): IgnoreLike =>\n  typeof ignore === 'string' ? new Ignore([ignore], opts)\n  : Array.isArray(ignore) ? new Ignore(ignore, opts)\n  : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n  includeChildMatches: boolean\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    this.includeChildMatches = opts.includeChildMatches !== false\n    if (opts.ignore || !this.includeChildMatches) {\n      this.#ignore = makeIgnore(opts.ignore ?? [], opts)\n      if (\n        !this.includeChildMatches &&\n        typeof this.#ignore.add !== 'function'\n      ) {\n        const m = 'cannot ignore child matches, ignore lacks add() method.'\n        throw new Error(m)\n      }\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? await e.lstat() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath()\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat()\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return (\n        e &&\n          (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n          (!ifDir || e.canReaddir()) &&\n          (!this.opts.nodir || !e.isDirectory()) &&\n          (!this.opts.nodir ||\n            !this.opts.follow ||\n            !e.isSymbolicLink() ||\n            !e.realpathCached()?.isDirectory()) &&\n          !this.#ignored(e)\n      ) ?\n        e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? e.lstatSync() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync()\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync()\n      }\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    // we know we have an ignore if this is false, but TS doesn't\n    if (!this.includeChildMatches && this.#ignore?.add) {\n      const ign = `${e.relativePosix()}/**`\n      this.#ignore.add(ign)\n    }\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n          '.' + this.#sep\n        : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true,\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb),\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  matches = new Set<Result<O>>()\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Set<Result<O>>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Set<Result<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  results: Minipass<Result<O>, Result<O>>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass<Result<O>, Result<O>>({\n      signal: this.signal,\n      objectMode: true,\n    })\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n", "import { Minimatch } from 'minimatch'\nimport { GlobOptions } from './glob.js'\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (\n  pattern: string | string[],\n  options: GlobOptions = {},\n): boolean => {\n  if (!Array.isArray(pattern)) {\n    pattern = [pattern]\n  }\n  for (const p of pattern) {\n    if (new Minimatch(p, options).hasMagic()) return true\n  }\n  return false\n}\n", "import { escape, unescape } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nimport { Glob } from './glob.js'\nimport { hasMagic } from './has-magic.js'\n\nexport { escape, unescape } from 'minimatch'\nexport type {\n  FSOption,\n  Path,\n  WalkOptions,\n  WalkOptionsWithFileTypesTrue,\n  WalkOptionsWithFileTypesUnset,\n} from 'path-scurry'\nexport { Glob } from './glob.js'\nexport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nexport { hasMagic } from './has-magic.js'\nexport { Ignore } from './ignore.js'\nexport type { IgnoreLike } from './ignore.js'\nexport type { MatchStream } from './walker.js'\n\n/**\n * Syncronous form of {@link globStream}. Will read all the matches as fast as\n * you consume them, even all in a single tick if you consume them immediately,\n * but will still respond to backpressure if they're not consumed immediately.\n */\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Minipass<Path, Path>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesUnset,\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).streamSync()\n}\n\n/**\n * Return a stream that emits all the strings or `Path` objects and\n * then emits `end` when completed.\n */\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Minipass<Path, Path>\nexport function globStream(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions,\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).stream()\n}\n\n/**\n * Synchronous form of {@link glob}\n */\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Path[]\nexport function globSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Path[] | string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).walkSync()\n}\n\n/**\n * Perform an asynchronous glob search for the pattern(s) specified. Returns\n * [Path](https://isaacs.github.io/path-scurry/classes/PathBase) objects if the\n * {@link withFileTypes} option is set to `true`. See {@link GlobOptions} for\n * full option descriptions.\n */\nasync function glob_(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Promise<Path[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions,\n): Promise<Path[] | string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).walk()\n}\n\n/**\n * Return a sync iterator for walking glob pattern matches.\n */\nexport function globIterateSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Generator<Path, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Generator<Path, void, void> | Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).iterateSync()\n}\n\n/**\n * Return an async iterator for walking glob pattern matches.\n */\nexport function globIterate(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): AsyncGenerator<Path, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions,\n): AsyncGenerator<Path, void, void> | AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).iterate()\n}\n\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync\nexport const stream = Object.assign(globStream, { sync: globStreamSync })\nexport const iterateSync = globIterateSync\nexport const iterate = Object.assign(globIterate, {\n  sync: globIterateSync,\n})\nexport const sync = Object.assign(globSync, {\n  stream: globStreamSync,\n  iterate: globIterateSync,\n})\n\nexport const glob = Object.assign(glob_, {\n  glob: glob_,\n  globSync,\n  sync,\n  globStream,\n  stream,\n  globStreamSync,\n  streamSync,\n  globIterate,\n  iterate,\n  globIterateSync,\n  iterateSync,\n  Glob,\n  hasMagic,\n  escape,\n  unescape,\n})\nglob.glob = glob\n", "import { execFileSync } from 'child_process';\nimport { existsSync, readdirSync } from 'fs';\nimport { join, resolve } from 'path';\n\nimport type { ValidatedCdsCommand } from './types';\nimport { fileExists } from '../../filesystem';\nimport { cdsExtractorLog } from '../../logging';\n\n/** Default timeout for command execution in milliseconds. **/\nexport const DEFAULT_COMMAND_TIMEOUT_MS = 10000;\n\n/**\n * Cache for CDS command test results to avoid running the same CLI commands repeatedly.\n */\ninterface CdsCommandCache {\n  /** Map of command strings to their test results */\n  commandResults: Map<string, { works: boolean; version?: string; error?: string }>;\n  /** Available cache directories discovered during testing */\n  availableCacheDirs: string[];\n  /** Global command test results */\n  globalCommand?: string;\n  /** Whether cache has been initialized */\n  initialized: boolean;\n}\n\n// Global cache instance to share results across all calls\nconst cdsCommandCache: CdsCommandCache = {\n  commandResults: new Map(),\n  availableCacheDirs: [],\n  initialized: false,\n};\n\n/**\n * Factory functions to create {@link ValidatedCdsCommand} instances.\n */\nconst createCdsCommands = {\n  // Global CDS command\n  cds: (): ValidatedCdsCommand => ({\n    executable: 'cds',\n    args: [],\n    originalCommand: 'cds',\n  }),\n  // NPX with @sap/cds package\n  npxCds: (): ValidatedCdsCommand => ({\n    executable: 'npx',\n    args: ['--yes', '--package', '@sap/cds', 'cds'],\n    originalCommand: 'npx --yes --package @sap/cds cds',\n  }),\n  // NPX with @sap/cds-dk package\n  npxCdsDk: (): ValidatedCdsCommand => ({\n    executable: 'npx',\n    args: ['--yes', '--package', '@sap/cds-dk', 'cds'],\n    originalCommand: 'npx --yes --package @sap/cds-dk cds',\n  }),\n  // NPX with @sap/cds-dk package (alternative flag)\n  npxCdsDkAlt: (): ValidatedCdsCommand => ({\n    executable: 'npx',\n    args: ['--yes', '@sap/cds-dk', 'cds'],\n    originalCommand: 'npx --yes @sap/cds-dk cds',\n  }),\n};\n\n/**\n * Creates a validated CDS command for an absolute path to a CDS executable.\n * @param absolutePath The absolute path to the CDS executable\n * @returns A {@link ValidatedCdsCommand} if the path exists and is valid, null otherwise\n */\nfunction createCdsCommandForPath(absolutePath: string): ValidatedCdsCommand | null {\n  try {\n    const resolvedPath = resolve(absolutePath);\n    if (resolvedPath && fileExists(resolvedPath)) {\n      return {\n        executable: resolvedPath,\n        args: [],\n        originalCommand: absolutePath,\n      };\n    }\n  } catch {\n    // Ignore path resolution errors\n  }\n  return null;\n}\n\n/**\n * Determine the `cds` command to use based on the environment and cache directory.\n *\n * This function uses a caching strategy to minimize repeated CLI command testing:\n * - Initializes a global cache on first call\n * - Tests global commands once and caches results\n * - Discovers all available cache directories upfront\n * - Reuses test results across multiple calls\n */\nexport function determineCdsCommand(cacheDir: string | undefined, sourceRoot: string): string {\n  try {\n    // Always use the efficient path - debug information is collected separately\n    return getBestCdsCommand(cacheDir, sourceRoot);\n  } catch (error) {\n    const errorMessage = `Failed to determine CDS command: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n    throw new Error(errorMessage);\n  }\n}\n\n/**\n * Discover all available cache directories in the source tree\n * @param sourceRoot The source root directory\n * @returns Array of cache directory paths\n */\nfunction discoverAvailableCacheDirs(sourceRoot: string): string[] {\n  if (cdsCommandCache.availableCacheDirs.length > 0) {\n    return cdsCommandCache.availableCacheDirs;\n  }\n\n  const cacheRootDir = join(sourceRoot, '.cds-extractor-cache');\n  const availableDirs: string[] = [];\n\n  try {\n    if (existsSync(cacheRootDir)) {\n      const entries = readdirSync(cacheRootDir, { withFileTypes: true });\n      for (const entry of entries) {\n        if (entry.isDirectory() && entry.name.startsWith('cds-')) {\n          const cacheDir = join(cacheRootDir, entry.name);\n          const cdsBin = join(cacheDir, 'node_modules', '.bin', 'cds');\n          if (fileExists(cdsBin)) {\n            availableDirs.push(cacheDir);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    cdsExtractorLog('debug', `Failed to discover cache directories: ${String(error)}`);\n  }\n\n  cdsCommandCache.availableCacheDirs = availableDirs;\n  return availableDirs;\n}\n\n/**\n * Get the best CDS command for a specific cache directory\n * @param cacheDir Optional specific cache directory\n * @param sourceRoot The source root directory\n * @returns The best CDS command to use\n */\nfunction getBestCdsCommand(cacheDir: string | undefined, sourceRoot: string): string {\n  // Initialize cache if needed\n  initializeCdsCommandCache(sourceRoot);\n\n  // If a specific cache directory is provided and valid, prefer it\n  if (cacheDir) {\n    const localCdsBin = join(cacheDir, 'node_modules', '.bin', 'cds');\n    const command = createCdsCommandForPath(localCdsBin);\n    if (command) {\n      const result = testCdsCommand(command, sourceRoot, true);\n      if (result.works) {\n        return localCdsBin;\n      }\n    }\n  }\n\n  // Try any available cache directories\n  for (const availableCacheDir of cdsCommandCache.availableCacheDirs) {\n    const localCdsBin = join(availableCacheDir, 'node_modules', '.bin', 'cds');\n    const command = createCdsCommandForPath(localCdsBin);\n    if (command) {\n      const result = testCdsCommand(command, sourceRoot, true);\n      if (result.works) {\n        return localCdsBin;\n      }\n    }\n  }\n\n  // Fall back to global command\n  if (cdsCommandCache.globalCommand) {\n    return cdsCommandCache.globalCommand;\n  }\n\n  // Final fallback: test remaining npx options\n  const fallbackCommands = [createCdsCommands.npxCds(), createCdsCommands.npxCdsDk()];\n\n  for (const command of fallbackCommands) {\n    const result = testCdsCommand(command, sourceRoot, true);\n    if (result.works) {\n      return command.originalCommand;\n    }\n  }\n\n  // Return the default fallback even if it doesn't work, as tests expect this behavior\n  return createCdsCommands.npxCdsDk().originalCommand;\n}\n\n/**\n * Initialize the CDS command cache by testing global commands\n * @param sourceRoot The source root directory\n */\nfunction initializeCdsCommandCache(sourceRoot: string): void {\n  if (cdsCommandCache.initialized) {\n    return;\n  }\n\n  cdsExtractorLog('info', 'Initializing CDS command cache...');\n\n  // Test global commands first (most commonly used)\n  const globalCommands = [createCdsCommands.cds(), createCdsCommands.npxCdsDk()];\n\n  for (const command of globalCommands) {\n    const result = testCdsCommand(command, sourceRoot, true); // Silent testing\n    if (result.works) {\n      cdsCommandCache.globalCommand = command.originalCommand;\n      cdsExtractorLog(\n        'info',\n        `Found working global CDS command: ${command.originalCommand} (v${result.version ?? 'unknown'})`,\n      );\n      break;\n    }\n  }\n\n  // Discover available cache directories\n  const cacheDirs = discoverAvailableCacheDirs(sourceRoot);\n  if (cacheDirs.length > 0) {\n    cdsExtractorLog(\n      'info',\n      `Discovered ${cacheDirs.length} CDS cache director${cacheDirs.length === 1 ? 'y' : 'ies'}`,\n    );\n  }\n\n  cdsCommandCache.initialized = true;\n}\n\n/**\n * Reset the command cache - primarily for testing\n */\nexport function resetCdsCommandCache(): void {\n  cdsCommandCache.commandResults.clear();\n  cdsCommandCache.availableCacheDirs = [];\n  cdsCommandCache.globalCommand = undefined;\n  cdsCommandCache.initialized = false;\n}\n\n/**\n * Check if a CDS command is available and working.\n * @param validatedCommand The {@link ValidatedCdsCommand} instance for the command to test\n * @param sourceRoot The source root directory to use as cwd when testing the command\n * @param silent Whether to suppress logging of test failures\n * @returns Object with test result and version information\n */\nfunction testCdsCommand(\n  validatedCommand: ValidatedCdsCommand,\n  sourceRoot: string,\n  silent: boolean = false,\n): { works: boolean; version?: string; error?: string } {\n  const cacheKey = validatedCommand.originalCommand;\n\n  // Check cache first\n  const cachedResult = cdsCommandCache.commandResults.get(cacheKey);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  try {\n    // Run the validated `cds` command with `--version` to test if it works.\n    const cleanEnv = {\n      ...process.env,\n      // Remove any CodeQL-specific environment variables that might interfere.\n      CODEQL_EXTRACTOR_CDS_WIP_DATABASE: undefined,\n      CODEQL_RUNNER: undefined,\n    };\n\n    const result = execFileSync(\n      validatedCommand.executable,\n      [...validatedCommand.args, '--version'],\n      {\n        encoding: 'utf8',\n        stdio: 'pipe',\n        timeout: DEFAULT_COMMAND_TIMEOUT_MS, // timeout after 10 seconds\n        cwd: sourceRoot,\n        env: cleanEnv,\n      },\n    ).toString();\n\n    // Extract version from output (typically in format \"@sap/cds-dk: 6.1.3\" or just \"6.1.3\")\n    const versionMatch = result.match(/(\\d+\\.\\d+\\.\\d+)/);\n    const version = versionMatch ? versionMatch[1] : undefined;\n\n    const testResult = { works: true, version };\n    cdsCommandCache.commandResults.set(cacheKey, testResult);\n    return testResult;\n  } catch (error) {\n    const errorMessage = String(error);\n    if (!silent) {\n      cdsExtractorLog('debug', `CDS command test failed for '${cacheKey}': ${errorMessage}`);\n    }\n\n    const testResult = { works: false, error: errorMessage };\n    cdsCommandCache.commandResults.set(cacheKey, testResult);\n    return testResult;\n  }\n}\n", "import { existsSync, readdirSync, renameSync, statSync } from 'fs';\nimport { format, join, parse } from 'path';\n\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Check if a directory exists\n * @param dirPath Path to the directory to check\n * @returns True if the directory exists, false otherwise\n */\nexport function dirExists(dirPath: string): boolean {\n  return existsSync(dirPath) && statSync(dirPath).isDirectory();\n}\n\n/**\n * Check if a file exists and can be read\n * @param filePath Path to the file to check\n * @returns True if the file exists and can be read, false otherwise\n */\nexport function fileExists(filePath: string): boolean {\n  return existsSync(filePath) && statSync(filePath).isFile();\n}\n\n/**\n * Recursively renames all .json files to .cds.json in the given directory and\n * its subdirectories, except for those that already have .cds.json extension.\n *\n * @param {string} dirPath - The directory path to start recursion from\n */\nexport function recursivelyRenameJsonFiles(dirPath: string): void {\n  // Make sure the directory exists\n  if (!dirExists(dirPath)) {\n    cdsExtractorLog('info', `Directory not found: ${dirPath}`);\n    return;\n  }\n  cdsExtractorLog('info', `Processing JSON files in directory: ${dirPath}`);\n\n  // Get all entries in the directory\n  const entries = readdirSync(dirPath, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const fullPath = join(dirPath, entry.name);\n\n    if (entry.isDirectory()) {\n      // Recursively process subdirectories\n      recursivelyRenameJsonFiles(fullPath);\n    } else if (\n      entry.isFile() &&\n      entry.name.endsWith('.json') &&\n      !entry.name.endsWith('.cds.json')\n    ) {\n      // Rename .json files to .cds.json\n      const newPath = format({ ...parse(fullPath), base: '', ext: '.cds.json' });\n      renameSync(fullPath, newPath);\n      cdsExtractorLog('info', `Renamed CDS output file from ${fullPath} to ${newPath}`);\n    }\n  }\n}\n", "import type { LogLevel } from './types';\n\n/**\n * Source root directory for logging context.\n */\nlet sourceRootDirectory: string | undefined;\n\n/**\n * Unique session ID for this CDS extractor run to help distinguish\n * between multiple concurrent or sequential runs in logs.\n * Uses the extractor start timestamp for uniqueness.\n */\nconst sessionId = Date.now().toString();\n\n/**\n * Start time of the CDS extractor session for performance tracking.\n */\nconst extractorStartTime = Date.now();\n\n/**\n * Performance tracking state for timing critical operations.\n */\nconst performanceTracking = new Map<string, number>();\n\n/**\n * Unified logging function for the CDS extractor. Provides consistent\n * log formatting with level prefixes, elapsed time, and session IDs.\n *\n * @param level - The log level ('debug', 'info', 'warn', 'error')\n * @param message - The primary message or data to log\n * @param optionalParams - Additional parameters to log (same as console.log)\n */\nexport function cdsExtractorLog(\n  level: LogLevel,\n  message: unknown,\n  ...optionalParams: unknown[]\n): void {\n  if (!sourceRootDirectory) {\n    throw new Error('Source root directory is not set. Call setSourceRootDirectory() first.');\n  }\n\n  const currentTime = Date.now();\n  const elapsedMs = currentTime - extractorStartTime;\n  const levelPrefix = `[CDS-${sessionId} ${elapsedMs}] ${level.toUpperCase()}: `;\n\n  // Select the appropriate console function based on log level\n  switch (level) {\n    case 'debug':\n    case 'info':\n      if (typeof message === 'string') {\n        console.log(levelPrefix + message, ...optionalParams);\n      } else {\n        console.log(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    case 'warn':\n      if (typeof message === 'string') {\n        console.warn(levelPrefix + message, ...optionalParams);\n      } else {\n        console.warn(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    case 'error':\n      if (typeof message === 'string') {\n        console.error(levelPrefix + message, ...optionalParams);\n      } else {\n        console.error(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    default:\n      // This should never happen due to TypeScript typing\n      throw new Error(`Invalid log level: ${String(level)}`);\n  }\n}\n/**\n * Calculates elapsed time from start and formats it with appropriate units.\n *\n * @param startTime - The start timestamp in milliseconds\n * @param endTime - The end timestamp in milliseconds (defaults to current time)\n * @returns Formatted duration string\n */\nfunction formatDuration(startTime: number, endTime: number = Date.now()): string {\n  const durationMs = endTime - startTime;\n\n  if (durationMs < 1000) {\n    return `${durationMs}ms`;\n  } else if (durationMs < 60000) {\n    return `${(durationMs / 1000).toFixed(2)}s`;\n  } else {\n    const minutes = Math.floor(durationMs / 60000);\n    const seconds = ((durationMs % 60000) / 1000).toFixed(2);\n    return `${minutes}m ${seconds}s`;\n  }\n}\n\n/**\n * Logs the start of the CDS extractor session with session information.\n *\n * @param sourceRoot - The source root directory being processed\n */\nexport function logExtractorStart(sourceRoot: string): void {\n  cdsExtractorLog('info', `=== CDS EXTRACTOR START [${sessionId}] ===`);\n  cdsExtractorLog('info', `Source Root: ${sourceRoot}`);\n}\n\n/**\n * Logs the end of the CDS extractor session with final performance summary.\n *\n * @param success - Whether the extraction completed successfully\n * @param additionalSummary - Optional additional summary information\n */\nexport function logExtractorStop(success: boolean = true, additionalSummary?: string): void {\n  const endTime = Date.now();\n  const totalDuration = formatDuration(extractorStartTime, endTime);\n  const status = success ? 'SUCCESS' : 'FAILURE';\n\n  if (additionalSummary) {\n    cdsExtractorLog('info', additionalSummary);\n  }\n\n  cdsExtractorLog('info', `=== CDS EXTRACTOR END [${sessionId}] - ${status} ===`);\n  cdsExtractorLog('info', `Total Duration: ${totalDuration}`);\n}\n\n/**\n * Logs a performance milestone with timing information.\n *\n * @param milestone - Description of the milestone reached\n * @param additionalInfo - Optional additional information to include\n */\nexport function logPerformanceMilestone(milestone: string, additionalInfo?: string): void {\n  const currentTime = Date.now();\n  const overallDuration = formatDuration(extractorStartTime, currentTime);\n  const info = additionalInfo ? ` - ${additionalInfo}` : '';\n  cdsExtractorLog('info', `MILESTONE: ${milestone} (after ${overallDuration})${info}`);\n}\n\n/**\n * Starts tracking performance for a named operation.\n *\n * @param operationName - Name of the operation to track\n */\nexport function logPerformanceTrackingStart(operationName: string): void {\n  performanceTracking.set(operationName, Date.now());\n  cdsExtractorLog('debug', `Started: ${operationName}`);\n}\n\n/**\n * Ends tracking performance for a named operation and logs the duration.\n *\n * @param operationName - Name of the operation to stop tracking\n */\nexport function logPerformanceTrackingStop(operationName: string): void {\n  const startTime = performanceTracking.get(operationName);\n  if (startTime) {\n    const duration = formatDuration(startTime);\n    performanceTracking.delete(operationName);\n    cdsExtractorLog('info', `Completed: ${operationName} (took ${duration})`);\n  } else {\n    cdsExtractorLog('warn', `No start time found for operation: ${operationName}`);\n  }\n}\n\n/**\n * Sets the source root directory for logging context.\n * This should typically be called once at the start of the CDS extractor.\n *\n * @param sourceRoot - The absolute path to the source root directory\n */\nexport function setSourceRootDirectory(sourceRoot: string): void {\n  sourceRootDirectory = sourceRoot;\n}\n", "import type { CdsDependencyGraph } from '../cds/parser';\n\n/**\n * Generate a comprehensive status report for the dependency graph\n * Supports both normal execution and debug modes\n */\nexport function generateStatusReport(dependencyGraph: CdsDependencyGraph): string {\n  const summary = dependencyGraph.statusSummary;\n  const lines: string[] = [];\n\n  lines.push('='.repeat(80));\n  lines.push(`CDS EXTRACTOR STATUS REPORT`);\n  lines.push('='.repeat(80));\n  lines.push('');\n\n  // Overall summary\n  lines.push('OVERALL SUMMARY:');\n  lines.push(`  Status: ${summary.overallSuccess ? 'SUCCESS' : 'FAILED'}`);\n  lines.push(`  Current Phase: ${dependencyGraph.currentPhase.toUpperCase()}`);\n  lines.push(`  Projects: ${summary.totalProjects}`);\n  lines.push(`  CDS Files: ${summary.totalCdsFiles}`);\n  lines.push(`  JSON Files Generated: ${summary.jsonFilesGenerated}`);\n  lines.push('');\n\n  // Compilation summary\n  lines.push('COMPILATION SUMMARY:');\n  lines.push(`  Total Tasks: ${summary.totalCompilationTasks}`);\n  lines.push(`  Successful: ${summary.successfulCompilations}`);\n  lines.push(`  Failed: ${summary.failedCompilations}`);\n  lines.push(`  Skipped: ${summary.skippedCompilations}`);\n  lines.push('');\n\n  // Retry summary (if retry attempts were made)\n  if (dependencyGraph.retryStatus.totalTasksRequiringRetry > 0) {\n    lines.push('RETRY SUMMARY:');\n    lines.push(`  Tasks Requiring Retry: ${dependencyGraph.retryStatus.totalTasksRequiringRetry}`);\n    lines.push(\n      `  Tasks Successfully Retried: ${dependencyGraph.retryStatus.totalTasksSuccessfullyRetried}`,\n    );\n    lines.push(`  Total Retry Attempts: ${dependencyGraph.retryStatus.totalRetryAttempts}`);\n    lines.push(\n      `  Projects Requiring Full Dependencies: ${dependencyGraph.retryStatus.projectsRequiringFullDependencies.size}`,\n    );\n    lines.push(\n      `  Projects with Full Dependencies: ${dependencyGraph.retryStatus.projectsWithFullDependencies.size}`,\n    );\n    lines.push('');\n  }\n\n  // Performance metrics\n  lines.push('PERFORMANCE:');\n  lines.push(`  Total Duration: ${summary.performance.totalDurationMs}ms`);\n  lines.push(`  Parsing: ${summary.performance.parsingDurationMs}ms`);\n  lines.push(`  Compilation: ${summary.performance.compilationDurationMs}ms`);\n  lines.push(`  Extraction: ${summary.performance.extractionDurationMs}ms`);\n\n  // Add percentage breakdown if total duration > 0\n  if (summary.performance.totalDurationMs > 0) {\n    const parsingPct = Math.round(\n      (summary.performance.parsingDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n    const compilationPct = Math.round(\n      (summary.performance.compilationDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n    const extractionPct = Math.round(\n      (summary.performance.extractionDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n\n    lines.push('  Breakdown:');\n    lines.push(`    Parsing: ${parsingPct}%`);\n    lines.push(`    Compilation: ${compilationPct}%`);\n    lines.push(`    Extraction: ${extractionPct}%`);\n  }\n  lines.push('');\n\n  // Errors and warnings\n  if (summary.criticalErrors.length > 0) {\n    lines.push('CRITICAL ERRORS:');\n    for (const error of summary.criticalErrors) {\n      lines.push(`  - ${error}`);\n    }\n    lines.push('');\n  }\n\n  if (summary.warnings.length > 0) {\n    lines.push('WARNINGS:');\n    for (const warning of summary.warnings) {\n      lines.push(`  - ${warning}`);\n    }\n    lines.push('');\n  }\n\n  lines.push('='.repeat(80));\n\n  return lines.join('\\n');\n}\n", "import { spawnSync, SpawnSyncOptions } from 'child_process';\nimport { resolve, join, delimiter, relative } from 'path';\n\nimport { globSync } from 'glob';\n\nimport { CdsCompilationResult } from './types';\nimport { getCdsVersion } from './version';\nimport { fileExists, dirExists, recursivelyRenameJsonFiles } from '../../filesystem';\nimport { cdsExtractorLog } from '../../logging';\nimport { BasicCdsProject } from '../parser/types';\n\n/**\n * Compiles a CDS file to JSON using robust, project-aware compilation only.\n * This function has been refactored to align with the autobuild.md vision by removing all\n * forms of individual file compilation and ensuring only project-aware compilation is used.\n *\n * For root files, this will compile them to their 1:1 .cds.json representation if and only\n * if the file is a true root file in a project.\n *\n * @param cdsFilePath The path to the CDS file to compile, relative to the `sourceRoot`.\n * @param sourceRoot The source root directory scanned by the CDS extractor.\n * CRITICAL: All spawned processes must use this as their cwd to ensure paths in generated\n * JSON are relative to sourceRoot.\n *\n * @param cdsCommand The actual shell command to use for `cds compile`.\n * @param cacheDir Full path to the cache directory where dependencies are stored.\n * @param projectMap Map of project directories to {@link BasicCdsProject} instances.\n * @param projectDir The project directory to which `cdsFilePath` belongs.\n *\n * @returns The {@link CdsCompilationResult} of the compilation attempt.\n */\nexport function compileCdsToJson(\n  cdsFilePath: string,\n  sourceRoot: string,\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  projectMap: Map<string, BasicCdsProject>,\n  projectDir: string,\n): CdsCompilationResult {\n  try {\n    const resolvedCdsFilePath = resolve(cdsFilePath);\n    if (!fileExists(resolvedCdsFilePath)) {\n      throw new Error(`Expected CDS file '${resolvedCdsFilePath}' does not exist.`);\n    }\n\n    // Get and log the CDS version\n    const cdsVersion = getCdsVersion(cdsCommand, cacheDir);\n    const versionInfo = cdsVersion ? `with CDS v${cdsVersion}` : '';\n\n    // CRITICAL: Create spawn options with sourceRoot as cwd to ensure correct path generation\n    const spawnOptions = createSpawnOptions(sourceRoot, cdsCommand, cacheDir);\n\n    // Throw an error if projectDir cannot be found in the projectMap.\n    if (!projectMap || !projectDir || !projectMap.has(projectDir)) {\n      throw new Error(\n        `Project directory '${projectDir}' not found in projectMap. Ensure the project is properly initialized.`,\n      );\n    }\n\n    const project = projectMap.get(projectDir);\n    const relativePath = relative(sourceRoot, resolvedCdsFilePath);\n\n    // Check if this is a project-level compilation marker\n    if (shouldUseProjectLevelCompilation(project)) {\n      return compileProjectLevel(\n        resolvedCdsFilePath,\n        sourceRoot,\n        projectDir,\n        cdsCommand,\n        spawnOptions,\n        versionInfo,\n      );\n    }\n\n    // Check if this file is in the list of files to compile for this project\n    if (!shouldCompileIndividually(project, relativePath)) {\n      cdsExtractorLog(\n        'info',\n        `${resolvedCdsFilePath} is imported by other files - will be compiled as part of a project ${versionInfo}...`,\n      );\n      const cdsJsonOutPath = `${resolvedCdsFilePath}.json`;\n      return {\n        success: true,\n        outputPath: cdsJsonOutPath,\n        compiledAsProject: true,\n        message: 'File was compiled as part of a project-based compilation',\n      };\n    } else {\n      // This is a root file - compile it using project-aware approach to its 1:1 representation\n      cdsExtractorLog(\n        'info',\n        `${resolvedCdsFilePath} identified as a root CDS file - using project-aware compilation for root file ${versionInfo}...`,\n      );\n      return compileRootFileAsProject(\n        resolvedCdsFilePath,\n        sourceRoot,\n        projectDir,\n        cdsCommand,\n        spawnOptions,\n        versionInfo,\n      );\n    }\n  } catch (error) {\n    return { success: false, message: String(error) };\n  }\n}\n\n/**\n * Handles project-level compilation for CAP projects with typical directory structure.\n * CRITICAL: Uses the project directory as cwd and calculates paths relative to project directory.\n *\n * @param resolvedCdsFilePath The resolved CDS file path that triggered this compilation\n * @param sourceRoot The source root directory\n * @param projectDir The project directory (relative to sourceRoot)\n * @param cdsCommand The CDS command to use\n * @param spawnOptions Pre-configured spawn options with sourceRoot as cwd\n * @param versionInfo Version information for logging\n * @returns Compilation result\n */\nfunction compileProjectLevel(\n  resolvedCdsFilePath: string,\n  sourceRoot: string,\n  projectDir: string,\n  cdsCommand: string,\n  spawnOptions: SpawnSyncOptions,\n  _versionInfo: string,\n): CdsCompilationResult {\n  cdsExtractorLog(\n    'info',\n    `${resolvedCdsFilePath} is part of a CAP project - using project-aware compilation ${_versionInfo}...`,\n  );\n\n  // For project-level compilation, compile the entire project together\n  // This follows the CAP best practice of compiling db and srv directories together\n  const projectAbsolutePath = join(sourceRoot, projectDir);\n\n  // Common directories in CAP projects that should be compiled together\n  const capDirectories = ['db', 'srv', 'app'];\n  const existingDirectories: string[] = [];\n\n  for (const dir of capDirectories) {\n    const dirPath = join(projectAbsolutePath, dir);\n    if (dirExists(dirPath)) {\n      existingDirectories.push(dir);\n    }\n  }\n\n  // Check if there are any CDS files in the project at all before proceeding\n  const allCdsFiles = globSync(join(projectAbsolutePath, '**/*.cds'), {\n    nodir: true,\n    ignore: ['**/node_modules/**'],\n  });\n\n  if (allCdsFiles.length === 0) {\n    throw new Error(\n      `Project directory '${projectDir}' does not contain any CDS files and cannot be compiled`,\n    );\n  }\n\n  if (existingDirectories.length === 0) {\n    // If no standard directories, check if there are CDS files in the root\n    const rootCdsFiles = globSync(join(projectAbsolutePath, '*.cds'));\n    if (rootCdsFiles.length > 0) {\n      existingDirectories.push('.');\n    } else {\n      // Find directories that contain CDS files\n      const cdsFileParents = new Set(\n        allCdsFiles.map((file: string) => {\n          const relativePath = relative(projectAbsolutePath, file);\n          const firstDir = relativePath.split('/')[0];\n          return firstDir === relativePath ? '.' : firstDir;\n        }),\n      );\n      existingDirectories.push(...Array.from(cdsFileParents));\n    }\n  }\n\n  // Generate output path for the compiled model - relative to sourceRoot for consistency\n  const relativeOutputPath = join(projectDir, 'model.cds.json');\n  const projectJsonOutPath = join(sourceRoot, relativeOutputPath);\n\n  // Use sourceRoot as working directory but provide project-relative paths\n  const projectSpawnOptions: SpawnSyncOptions = {\n    ...spawnOptions,\n    cwd: sourceRoot, // Use sourceRoot as working directory for consistency\n  };\n\n  // Convert directories to be relative to sourceRoot (include project prefix)\n  const projectRelativeDirectories = existingDirectories.map(dir =>\n    dir === '.' ? projectDir : join(projectDir, dir),\n  );\n\n  const compileArgs = [\n    'compile',\n    ...projectRelativeDirectories, // Use paths relative to sourceRoot\n    '--to',\n    'json',\n    '--dest',\n    join(projectDir, 'model.cds.json'), // Output to specific model.cds.json file\n    '--locations',\n    '--log-level',\n    'warn',\n  ];\n\n  cdsExtractorLog('info', `Compiling CAP project directories: ${existingDirectories.join(', ')}`);\n  cdsExtractorLog(\n    'info',\n    `Running compilation task for CDS project '${projectDir}': command='${cdsCommand}' args='${JSON.stringify(compileArgs)}'`,\n  );\n\n  // CRITICAL: Use the project directory as cwd\n  // Use array arguments for consistent test behavior\n  const result = spawnSync(cdsCommand, compileArgs, projectSpawnOptions);\n\n  if (result.error) {\n    cdsExtractorLog('error', `SpawnSync error: ${result.error.message}`);\n    throw new Error(`Error executing CDS compiler: ${result.error.message}`);\n  }\n\n  // Log stderr for debugging even on success (CDS often writes warnings to stderr)\n  if (result.stderr && result.stderr.length > 0) {\n    cdsExtractorLog('warn', `CDS stderr output: ${result.stderr.toString()}`);\n  }\n\n  if (result.status !== 0) {\n    cdsExtractorLog('error', `CDS command failed with status ${result.status}`);\n    cdsExtractorLog(\n      'error',\n      `Command: ${cdsCommand} ${compileArgs.map(arg => (arg.includes(' ') ? `\"${arg}\"` : arg)).join(' ')}`,\n    );\n    cdsExtractorLog('error', `Stdout: ${result.stdout?.toString() || 'No stdout'}`);\n    cdsExtractorLog('error', `Stderr: ${result.stderr?.toString() || 'No stderr'}`);\n    throw new Error(\n      `Could not compile the CAP project ${projectDir}.\\nReported error(s):\\n\\`\\`\\`\\n${\n        result.stderr?.toString() || 'Unknown error'\n      }\\n\\`\\`\\``,\n    );\n  }\n\n  if (!fileExists(projectJsonOutPath) && !dirExists(projectJsonOutPath)) {\n    throw new Error(\n      `CAP project '${projectDir}' was not compiled to JSON. This is likely because the project structure is invalid.`,\n    );\n  }\n\n  // Handle directory output if the CDS compiler generated a directory\n  if (dirExists(projectJsonOutPath)) {\n    cdsExtractorLog(\n      'info',\n      `CDS compiler generated JSON to output directory: ${projectJsonOutPath}`,\n    );\n    // Recursively rename all .json files to have a .cds.json extension\n    recursivelyRenameJsonFiles(projectJsonOutPath);\n  } else {\n    cdsExtractorLog('info', `CDS compiler generated JSON to file: ${projectJsonOutPath}`);\n  }\n\n  return {\n    success: true,\n    outputPath: projectJsonOutPath,\n    compiledAsProject: true,\n    message: 'Project was compiled using project-aware compilation',\n  };\n}\n\n/**\n * Compiles a root CDS file using project-aware approach for 1:1 .cds.json representation.\n * This follows the autobuild.md vision of project-aware compilation only.\n *\n * @param resolvedCdsFilePath The resolved CDS file path\n * @param sourceRoot The source root directory\n * @param projectDir The project directory\n * @param cdsCommand The CDS command to use\n * @param spawnOptions Pre-configured spawn options\n * @param versionInfo Version information for logging\n * @returns Compilation result\n */\nfunction compileRootFileAsProject(\n  resolvedCdsFilePath: string,\n  sourceRoot: string,\n  _projectDir: string,\n  cdsCommand: string,\n  spawnOptions: SpawnSyncOptions,\n  _versionInfo: string,\n): CdsCompilationResult {\n  // Calculate relative path for the output file\n  const relativeCdsPath = relative(sourceRoot, resolvedCdsFilePath);\n  const cdsJsonOutPath = `${resolvedCdsFilePath}.json`;\n\n  // Use project-aware compilation with specific file target\n  const compileArgs = [\n    'compile',\n    relativeCdsPath, // Compile the specific file relative to sourceRoot\n    '--to',\n    'json',\n    '--dest',\n    `${relativeCdsPath}.json`,\n    '--locations',\n    '--log-level',\n    'warn',\n  ];\n\n  cdsExtractorLog(\n    'info',\n    `Compiling root CDS file using project-aware approach: ${relativeCdsPath}`,\n  );\n  cdsExtractorLog(\n    'info',\n    `Executing CDS command: command='${cdsCommand}' args='${JSON.stringify(compileArgs)}'`,\n  );\n\n  // Execute the compilation\n  const result = spawnSync(cdsCommand, compileArgs, spawnOptions);\n\n  if (result.error) {\n    cdsExtractorLog('error', `SpawnSync error: ${result.error.message}`);\n    throw new Error(`Error executing CDS compiler: ${result.error.message}`);\n  }\n\n  // Log stderr for debugging even on success\n  if (result.stderr && result.stderr.length > 0) {\n    cdsExtractorLog('warn', `CDS stderr output: ${result.stderr.toString()}`);\n  }\n\n  if (result.status !== 0) {\n    cdsExtractorLog('error', `CDS command failed with status ${result.status}`);\n    cdsExtractorLog(\n      'error',\n      `Command: ${cdsCommand} ${compileArgs.map(arg => (arg.includes(' ') ? `\"${arg}\"` : arg)).join(' ')}`,\n    );\n    cdsExtractorLog('error', `Stdout: ${result.stdout?.toString() || 'No stdout'}`);\n    cdsExtractorLog('error', `Stderr: ${result.stderr?.toString() || 'No stderr'}`);\n    throw new Error(\n      `Could not compile the root CDS file ${relativeCdsPath}.\\nReported error(s):\\n\\`\\`\\`\\n${\n        result.stderr?.toString() || 'Unknown error'\n      }\\n\\`\\`\\``,\n    );\n  }\n\n  if (!fileExists(cdsJsonOutPath) && !dirExists(cdsJsonOutPath)) {\n    throw new Error(\n      `Root CDS file '${relativeCdsPath}' was not compiled to JSON. Expected output: ${cdsJsonOutPath}`,\n    );\n  }\n\n  // Handle directory output if the CDS compiler generated a directory\n  if (dirExists(cdsJsonOutPath)) {\n    cdsExtractorLog('info', `CDS compiler generated JSON to output directory: ${cdsJsonOutPath}`);\n    // Recursively rename all .json files to have a .cds.json extension\n    recursivelyRenameJsonFiles(cdsJsonOutPath);\n  } else {\n    cdsExtractorLog('info', `CDS compiler generated JSON to file: ${cdsJsonOutPath}`);\n  }\n\n  return {\n    success: true,\n    outputPath: cdsJsonOutPath,\n    compiledAsProject: true,\n    message: 'Root file compiled using project-aware compilation',\n  };\n}\n\n/**\n * Creates spawn options for CDS compilation processes.\n * CRITICAL: Always sets cwd to sourceRoot to ensure generated JSON paths are relative to sourceRoot.\n *\n * @param sourceRoot The source root directory - used as cwd for all spawned processes\n * @param cdsCommand The CDS command to determine if we need Node.js environment setup\n * @param cacheDir Optional cache directory for dependencies\n * @returns Spawn options configured for CDS compilation\n */\nfunction createSpawnOptions(\n  sourceRoot: string,\n  cdsCommand: string,\n  cacheDir?: string,\n): SpawnSyncOptions {\n  const spawnOptions: SpawnSyncOptions = {\n    cwd: sourceRoot, // CRITICAL: Always use sourceRoot as cwd to ensure correct path generation\n    shell: false, // Use shell=false to ensure proper argument handling for paths with spaces\n    stdio: 'pipe',\n    env: { ...process.env },\n  };\n\n  // Check if we're using a direct binary path (contains node_modules/.bin/) or npx-style command\n  const isDirectBinary = cdsCommand.includes('node_modules/.bin/');\n\n  // Only set up Node.js environment for npx-style commands, not for direct binary execution\n  if (cacheDir && !isDirectBinary) {\n    const nodePath = join(cacheDir, 'node_modules');\n\n    // Set up environment to use the cached dependencies\n    spawnOptions.env = {\n      ...process.env,\n      NODE_PATH: `${nodePath}${delimiter}${process.env.NODE_PATH ?? ''}`,\n      PATH: `${join(nodePath, '.bin')}${delimiter}${process.env.PATH}`,\n      // Add NPM configuration to ensure dependencies are resolved from the cache directory\n      npm_config_prefix: cacheDir,\n      // Ensure we don't pick up global CDS installations that might conflict\n      npm_config_global: 'false',\n      // Clear any existing CDS environment variables that might interfere\n      CDS_HOME: cacheDir,\n    };\n  } else if (isDirectBinary) {\n    // For direct binary execution, use minimal environment to avoid conflicts\n    // Remove Node.js-specific environment variables that might interfere\n    const cleanEnv = { ...process.env };\n    delete cleanEnv.NODE_PATH;\n    delete cleanEnv.npm_config_prefix;\n    delete cleanEnv.npm_config_global;\n    delete cleanEnv.CDS_HOME;\n\n    spawnOptions.env = cleanEnv;\n  }\n\n  return spawnOptions;\n}\n\n/**\n * Determines if a file should be compiled individually or skipped because it's part of a project.\n *\n * @param project The CDS project\n * @param relativePath The relative path of the file being checked\n * @returns true if the file should be compiled individually\n */\nfunction shouldCompileIndividually(\n  project: BasicCdsProject | undefined,\n  relativePath: string,\n): boolean {\n  return project?.cdsFilesToCompile?.includes(relativePath) ?? true;\n}\n\n/**\n * Determines if the given project should use project-level compilation.\n *\n * @param project The CDS project to check\n * @returns true if project-level compilation should be used\n */\nfunction shouldUseProjectLevelCompilation(project: BasicCdsProject | undefined): boolean {\n  return project?.cdsFilesToCompile?.includes('__PROJECT_LEVEL_COMPILATION__') ?? false;\n}\n", "import { spawnSync, SpawnSyncOptions } from 'child_process';\nimport { join, delimiter } from 'path';\n\n/**\n * Get the CDS compiler version from a specific command or cache directory.\n * @param cdsCommand The CDS command to use.\n * @param cacheDir Optional path to a directory containing installed dependencies.\n * @returns The CDS compiler version string, or undefined if it couldn't be determined.\n */\nexport function getCdsVersion(cdsCommand: string, cacheDir?: string): string | undefined {\n  try {\n    // Set up environment vars if using a cache directory\n    const spawnOptions: SpawnSyncOptions = {\n      shell: true,\n      stdio: 'pipe',\n      env: { ...process.env },\n    };\n\n    // If a cache directory is provided, set NODE_PATH to use that cache\n    if (cacheDir) {\n      const nodePath = join(cacheDir, 'node_modules');\n\n      // Set up environment to use the cached dependencies\n      spawnOptions.env = {\n        ...process.env,\n        NODE_PATH: `${nodePath}${delimiter}${process.env.NODE_PATH ?? ''}`,\n        PATH: `${join(nodePath, '.bin')}${delimiter}${process.env.PATH}`,\n        npm_config_prefix: cacheDir,\n      };\n    }\n\n    // Execute the CDS command with the --version flag\n    const result = spawnSync(cdsCommand, ['--version'], spawnOptions);\n    if (result.status === 0 && result.stdout) {\n      const versionOutput = result.stdout.toString().trim();\n      // Extract version number, which is typically in formats like \"@sap/cds: 6.1.3\" or similar\n      const match = versionOutput.match(/@sap\\/cds[^0-9]*([0-9]+\\.[0-9]+\\.[0-9]+)/);\n      if (match?.[1]) {\n        return match[1]; // Return just the version number\n      }\n      return versionOutput; // Return full output if we couldn't parse it\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n", "/** Full dependency installation utilities for retry scenarios. */\n\nimport { execFileSync } from 'child_process';\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';\nimport { join } from 'path';\n\nimport { cdsExtractorLog } from '../../logging';\nimport type { CdsProject } from '../parser/types';\n\n/** Result of full dependency installation for a project */\nexport interface FullDependencyInstallationResult {\n  /** Whether installation was successful */\n  success: boolean;\n  /** Path to the retry cache directory */\n  retryCacheDir: string;\n  /** Installation error message if failed */\n  error?: string;\n  /** Warnings during installation */\n  warnings: string[];\n  /** Duration of installation in milliseconds */\n  durationMs: number;\n  /** Whether a timeout occurred */\n  timedOut: boolean;\n}\n\n/**\n * Installs full dependencies for a project using its package.json\n * @param project The CDS project to install dependencies for\n * @param sourceRoot Source root directory\n * @param codeqlExePath Path to the CodeQL executable for diagnostics\n * @returns Installation result with details\n */\nexport function installFullDependencies(\n  project: CdsProject,\n  sourceRoot: string,\n  _codeqlExePath: string,\n): FullDependencyInstallationResult {\n  const startTime = Date.now();\n\n  const result: FullDependencyInstallationResult = {\n    success: false,\n    retryCacheDir: '',\n    warnings: [],\n    durationMs: 0,\n    timedOut: false,\n  };\n\n  try {\n    // Create retry-specific cache directory\n    const retryCacheDir = createRetryCacheDirectory(project, sourceRoot);\n    result.retryCacheDir = retryCacheDir;\n\n    // Create package.json in retry cache directory\n    if (!createPackageJsonForRetry(project, sourceRoot, retryCacheDir)) {\n      result.error = 'Failed to create package.json for retry';\n      return result;\n    }\n\n    // Install dependencies using npm\n    cdsExtractorLog(\n      'info',\n      `Installing full dependencies for project ${project.projectDir} in retry cache directory`,\n    );\n\n    try {\n      execFileSync('npm', ['install', '--quiet', '--no-audit', '--no-fund'], {\n        cwd: retryCacheDir,\n        stdio: 'inherit',\n        timeout: 120000, // 2-minute timeout\n      });\n\n      result.success = true;\n      cdsExtractorLog(\n        'info',\n        `Successfully installed full dependencies for project ${project.projectDir}`,\n      );\n    } catch (execError) {\n      if (execError instanceof Error && 'signal' in execError && execError.signal === 'SIGTERM') {\n        result.timedOut = true;\n        result.error = 'Dependency installation timed out';\n      } else {\n        result.error = `npm install failed: ${String(execError)}`;\n      }\n\n      // Still attempt retry compilation even if dependency installation fails (optimistic approach)\n      result.warnings.push(\n        `Dependency installation failed but will still attempt retry compilation: ${result.error}`,\n      );\n      cdsExtractorLog('warn', result.warnings[0]);\n    }\n  } catch (error) {\n    result.error = `Failed to install full dependencies: ${String(error)}`;\n    cdsExtractorLog('error', result.error);\n  } finally {\n    result.durationMs = Date.now() - startTime;\n  }\n\n  return result;\n}\n\n/**\n * Determines if a project needs full dependency installation\n * @param project The CDS project to check\n * @returns Whether full dependency installation is needed\n */\nexport function needsFullDependencyInstallation(project: CdsProject): boolean {\n  // Check if already installed\n  if (project.retryStatus?.fullDependenciesInstalled) {\n    return false;\n  }\n\n  // Check if project has failed tasks that could benefit from full dependencies\n  const hasFailedTasks = project.compilationTasks.some(\n    task => task.status === 'failed' && !task.retryInfo?.hasBeenRetried,\n  );\n\n  return hasFailedTasks && project.packageJson !== undefined;\n}\n\n/**\n * Creates retry-specific cache directory for a project\n * @param project The CDS project\n * @param sourceRoot Source root directory\n * @returns Path to the created retry cache directory\n */\nexport function createRetryCacheDirectory(project: CdsProject, sourceRoot: string): string {\n  const cacheSubDirName = '.cds-extractor-cache';\n  const cacheRootDir = join(sourceRoot, cacheSubDirName);\n\n  // Generate unique retry cache directory name\n  const projectHash = Buffer.from(project.projectDir).toString('base64').replace(/[/+=]/g, '_');\n  const timestamp = Date.now();\n  const retryCacheDirName = `retry-${projectHash}-${timestamp}`;\n  const retryCacheDir = join(cacheRootDir, retryCacheDirName);\n\n  // Create cache root directory if it doesn't exist\n  if (!existsSync(cacheRootDir)) {\n    try {\n      mkdirSync(cacheRootDir, { recursive: true });\n      cdsExtractorLog('info', `Created cache root directory: ${cacheRootDir}`);\n    } catch (error) {\n      throw new Error(`Failed to create cache root directory: ${String(error)}`);\n    }\n  }\n\n  // Create retry-specific cache directory\n  try {\n    mkdirSync(retryCacheDir, { recursive: true });\n    cdsExtractorLog('info', `Created retry cache directory: ${retryCacheDirName}`);\n  } catch (error) {\n    throw new Error(`Failed to create retry cache directory: ${String(error)}`);\n  }\n\n  return retryCacheDir;\n}\n\n/**\n * Creates a package.json file in the retry cache directory based on the project's original package.json\n * @param project The CDS project\n * @param sourceRoot Source root directory\n * @param retryCacheDir Path to the retry cache directory\n * @returns Whether package.json creation was successful\n */\nfunction createPackageJsonForRetry(\n  project: CdsProject,\n  sourceRoot: string,\n  retryCacheDir: string,\n): boolean {\n  if (!project.packageJson) {\n    cdsExtractorLog('warn', `No package.json found for project ${project.projectDir}`);\n    return false;\n  }\n\n  try {\n    // Check if original package-lock.json exists\n    const originalPackageLockPath = join(sourceRoot, project.projectDir, 'package-lock.json');\n    let packageLockContent: unknown = undefined;\n\n    if (existsSync(originalPackageLockPath)) {\n      try {\n        const lockContent = readFileSync(originalPackageLockPath, 'utf8');\n        packageLockContent = JSON.parse(lockContent);\n        cdsExtractorLog('info', `Found package-lock.json for project ${project.projectDir}`);\n      } catch (error) {\n        cdsExtractorLog(\n          'warn',\n          `Failed to read package-lock.json for project ${project.projectDir}: ${String(error)}`,\n        );\n      }\n    }\n\n    // Create package.json with all dependencies\n    const retryPackageJson: Record<string, unknown> = {\n      name: `${project.packageJson.name ?? 'unknown'}-retry`,\n      version: project.packageJson.version ?? '1.0.0',\n      private: true,\n      dependencies: {\n        ...(project.packageJson.dependencies ?? {}),\n        ...(project.packageJson.devDependencies ?? {}), // Include dev dependencies as dependencies\n      },\n    };\n\n    // Copy other relevant fields that might affect dependency resolution\n    if (project.packageJson.engines) {\n      retryPackageJson.engines = project.packageJson.engines;\n    }\n    if (project.packageJson.peerDependencies) {\n      retryPackageJson.peerDependencies = project.packageJson.peerDependencies;\n    }\n\n    // Write package.json\n    const packageJsonPath = join(retryCacheDir, 'package.json');\n    writeFileSync(packageJsonPath, JSON.stringify(retryPackageJson, null, 2));\n    cdsExtractorLog('info', `Created retry package.json for project ${project.projectDir}`);\n\n    // Copy package-lock.json if it exists\n    if (packageLockContent) {\n      const packageLockPath = join(retryCacheDir, 'package-lock.json');\n      writeFileSync(packageLockPath, JSON.stringify(packageLockContent, null, 2));\n      cdsExtractorLog('info', `Copied package-lock.json for project ${project.projectDir}`);\n    }\n\n    return true;\n  } catch (error) {\n    cdsExtractorLog('error', `Failed to create package.json for retry: ${String(error)}`);\n    return false;\n  }\n}\n", "/** Validation utilities for CDS compilation output files. */\n\nimport { readFileSync } from 'fs';\nimport { isAbsolute, join } from 'path';\n\nimport type { CompilationTask } from './types';\nimport { fileExists } from '../../filesystem';\nimport { cdsExtractorLog } from '../../logging';\nimport type { CdsDependencyGraph } from '../parser/types';\n\n/** Result of validating a single output file */\nexport interface OutputFileValidationResult {\n  /** Whether the file is valid */\n  isValid: boolean;\n  /** Path to the validated file */\n  filePath: string;\n  /** Validation error message if validation failed */\n  error?: string;\n  /** Whether the file exists */\n  exists: boolean;\n  /** Whether the file contains valid JSON (if it exists) */\n  hasValidJson?: boolean;\n}\n\n/** Result of validating all outputs for a compilation task */\nexport interface TaskValidationResult {\n  /** Whether all outputs are valid */\n  isValid: boolean;\n  /** The task that was validated */\n  task: CompilationTask;\n  /** Validation results for each expected output file */\n  fileResults: OutputFileValidationResult[];\n  /** Number of valid output files */\n  validFileCount: number;\n  /** Number of expected output files */\n  expectedFileCount: number;\n}\n\n/**\n * Validates a single expected output file.\n * @param filePath Path to the output file to validate\n * @returns Validation result with details\n */\nexport function validateOutputFile(filePath: string): OutputFileValidationResult {\n  const result: OutputFileValidationResult = {\n    isValid: false,\n    filePath,\n    exists: false,\n  };\n\n  // Check if file exists\n  if (!fileExists(filePath)) {\n    result.error = 'File does not exist';\n    return result;\n  }\n\n  result.exists = true;\n\n  // For .cds.json files, validate JSON content\n  if (filePath.endsWith('.cds.json') || filePath.endsWith('.json')) {\n    try {\n      const content = readFileSync(filePath, 'utf8');\n\n      // Check if content is empty\n      if (!content.trim()) {\n        result.error = 'File is empty';\n        return result;\n      }\n\n      // Try to parse as JSON\n      const parsed: unknown = JSON.parse(content);\n\n      // Basic structure validation for CDS JSON files\n      if (typeof parsed !== 'object' || parsed === null) {\n        result.error = 'File does not contain a valid JSON object';\n        return result;\n      }\n\n      result.hasValidJson = true;\n      result.isValid = true;\n    } catch (error) {\n      result.error = `Invalid JSON content: ${String(error)}`;\n      return result;\n    }\n  } else {\n    // For non-JSON files, existence is sufficient\n    result.isValid = true;\n  }\n\n  return result;\n}\n\n/**\n * Validates that all expected output files exist for a compilation task.\n * @param task The compilation task to validate\n * @param sourceRoot Source root directory for resolving relative paths\n * @returns Task-level validation result\n */\nexport function validateTaskOutputs(\n  task: CompilationTask,\n  sourceRoot: string,\n): TaskValidationResult {\n  const fileResults: OutputFileValidationResult[] = [];\n\n  for (const expectedOutput of task.expectedOutputFiles) {\n    // Resolve the output file path relative to source root\n    const absolutePath = isAbsolute(expectedOutput)\n      ? expectedOutput\n      : join(sourceRoot, expectedOutput);\n\n    const fileResult = validateOutputFile(absolutePath);\n    fileResults.push(fileResult);\n  }\n\n  const validFileCount = fileResults.filter(r => r.isValid).length;\n  const expectedFileCount = task.expectedOutputFiles.length;\n  const isValid = validFileCount === expectedFileCount && expectedFileCount > 0;\n\n  return {\n    isValid,\n    task,\n    fileResults,\n    validFileCount,\n    expectedFileCount,\n  };\n}\n\n/**\n * Identifies tasks requiring retry based on output validation\n * @param dependencyGraph The dependency graph containing tasks to validate\n * @returns Map of project directory to failed tasks that need retry\n */\nexport function identifyTasksRequiringRetry(\n  dependencyGraph: CdsDependencyGraph,\n): Map<string, CompilationTask[]> {\n  const tasksRequiringRetry = new Map<string, CompilationTask[]>();\n\n  for (const [projectDir, project] of dependencyGraph.projects.entries()) {\n    const failedTasks: CompilationTask[] = [];\n\n    for (const task of project.compilationTasks) {\n      // Skip tasks that have already been retried.\n      if (task.retryInfo?.hasBeenRetried) {\n        continue;\n      }\n\n      // Always validate output files exist, regardless of task status.\n      const validationResult = validateTaskOutputs(task, dependencyGraph.sourceRootDir);\n\n      if (!validationResult.isValid) {\n        failedTasks.push(task);\n        cdsExtractorLog(\n          'info',\n          `Task ${task.id} requires retry: ${validationResult.validFileCount}/${validationResult.expectedFileCount} output files valid (status: ${task.status})`,\n        );\n\n        // Update task status to reflect actual file state.\n        if (task.status === 'success') {\n          cdsExtractorLog(\n            'warn',\n            `Task ${task.id} was marked as successful but output files are missing or invalid - updating status to failed`,\n          );\n          task.status = 'failed';\n        }\n      }\n    }\n\n    if (failedTasks.length > 0) {\n      tasksRequiringRetry.set(projectDir, failedTasks);\n    }\n  }\n\n  if (tasksRequiringRetry.size > 0) {\n    const totalFailedTasks = Array.from(tasksRequiringRetry.values()).reduce(\n      (sum, tasks) => sum + tasks.length,\n      0,\n    );\n    cdsExtractorLog(\n      'info',\n      `Identified ${totalFailedTasks} task(s) requiring retry across ${tasksRequiringRetry.size} project(s)`,\n    );\n  }\n\n  return tasksRequiringRetry;\n}\n", "import { execFileSync } from 'child_process';\nimport { resolve } from 'path';\n\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Severity levels for diagnostics\n */\nexport enum DiagnosticSeverity {\n  Error = 'error',\n  Warning = 'warning',\n  Note = 'note',\n  Recommendation = 'recommendation',\n}\n\n/**\n * Base function to add a diagnostic to the CodeQL database\n * @param filePath Path to the file related to the diagnostic\n * @param message The diagnostic message\n * @param codeqlExePath Path to the CodeQL executable\n * @param sourceId The source ID for the diagnostic\n * @param sourceName The source name for the diagnostic\n * @param severity The severity level of the diagnostic\n * @param logPrefix Prefix for the log message\n * @returns True if the diagnostic was added, false otherwise\n */\nfunction addDiagnostic(\n  filePath: string,\n  message: string,\n  codeqlExePath: string,\n  sourceId: string,\n  sourceName: string,\n  severity: DiagnosticSeverity,\n  logPrefix: string,\n): boolean {\n  try {\n    execFileSync(codeqlExePath, [\n      'database',\n      'add-diagnostic',\n      '--extractor-name=cds',\n      '--ready-for-status-page',\n      `--source-id=${sourceId}`,\n      `--source-name=${sourceName}`,\n      `--severity=${severity}`,\n      `--markdown-message=${message}`,\n      `--file-path=${resolve(filePath)}`,\n      '--',\n      `${process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE ?? ''}`,\n    ]);\n    cdsExtractorLog('info', `Added ${severity} diagnostic for ${logPrefix}: ${filePath}`);\n    return true;\n  } catch (err) {\n    cdsExtractorLog(\n      'error',\n      `Failed to add ${severity} diagnostic for ${logPrefix}=${filePath} : ${String(err)}`,\n    );\n    return false;\n  }\n}\n\n/**\n * Add a diagnostic error to the CodeQL database for a failed CDS compilation\n * @param cdsFilePath Path to the CDS file that failed to compile\n * @param errorMessage The error message from the compilation\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nexport function addCompilationDiagnostic(\n  cdsFilePath: string,\n  errorMessage: string,\n  codeqlExePath: string,\n): boolean {\n  return addDiagnostic(\n    cdsFilePath,\n    errorMessage,\n    codeqlExePath,\n    'cds/compilation-failure',\n    'Failure to compile one or more SAP CAP CDS files',\n    DiagnosticSeverity.Error,\n    'source file',\n  );\n}\n\n/**\n * Add a diagnostic error to the CodeQL database for a JavaScript extractor failure\n * @param filePath Path to a relevant file for the error context\n * @param errorMessage The error message from the JavaScript extractor\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nexport function addJavaScriptExtractorDiagnostic(\n  filePath: string,\n  errorMessage: string,\n  codeqlExePath: string,\n): boolean {\n  return addDiagnostic(\n    filePath,\n    errorMessage,\n    codeqlExePath,\n    'cds/js-extractor-failure',\n    'Failure in JavaScript extractor for SAP CAP CDS files',\n    DiagnosticSeverity.Error,\n    'extraction file',\n  );\n}\n", "/** Main retry orchestration logic for CDS compilation failures. */\n\nimport { determineCdsCommand } from './command';\nimport { compileCdsToJson } from './compile';\nimport { installFullDependencies, needsFullDependencyInstallation } from './installer';\nimport type { CompilationAttempt, CompilationTask } from './types';\nimport { identifyTasksRequiringRetry } from './validator';\nimport { addCompilationDiagnostic } from '../../diagnostics';\nimport { cdsExtractorLog } from '../../logging';\nimport type { CdsDependencyGraph, CdsProject } from '../parser/types';\n\n/** Result of retry orchestration for the entire dependency graph */\nexport interface RetryOrchestrationResult {\n  /** Overall success status */\n  success: boolean;\n  /** Projects that had retry attempts */\n  projectsWithRetries: string[];\n  /** Total number of tasks that required retry */\n  totalTasksRequiringRetry: number;\n  /** Total number of successful retry attempts */\n  totalSuccessfulRetries: number;\n  /** Total number of failed retry attempts */\n  totalFailedRetries: number;\n  /** Projects where full dependency installation succeeded */\n  projectsWithSuccessfulDependencyInstallation: string[];\n  /** Projects where full dependency installation failed */\n  projectsWithFailedDependencyInstallation: string[];\n  /** Duration of retry phase in milliseconds */\n  retryDurationMs: number;\n  /** Duration of dependency installation in milliseconds */\n  dependencyInstallationDurationMs: number;\n  /** Duration of retry compilation in milliseconds */\n  retryCompilationDurationMs: number;\n}\n\n/** Result of executing retry compilation for specific tasks */\nexport interface RetryExecutionResult {\n  /** Project directory */\n  projectDir: string;\n  /** Tasks that were retried */\n  retriedTasks: CompilationTask[];\n  /** Number of successful retry attempts */\n  successfulRetries: number;\n  /** Number of failed retry attempts */\n  failedRetries: number;\n  /** Whether full dependencies were available for retry */\n  fullDependenciesAvailable: boolean;\n  /** Retry execution duration in milliseconds */\n  executionDurationMs: number;\n  /** Error messages from failed retries */\n  retryErrors: string[];\n}\n\n/**\n * Main retry orchestration function\n * @param dependencyGraph The dependency graph containing compilation tasks\n * @param baseProjectCacheDirMap Original cache directory mappings\n * @param codeqlExePath Path to CodeQL executable for diagnostics\n * @returns Comprehensive retry orchestration results\n */\nexport function orchestrateRetryAttempts(\n  dependencyGraph: CdsDependencyGraph,\n  baseProjectCacheDirMap: Map<string, string>,\n  codeqlExePath: string,\n): RetryOrchestrationResult {\n  const startTime = Date.now();\n  let dependencyInstallationStartTime = 0;\n  let dependencyInstallationEndTime = 0;\n  let retryCompilationStartTime = 0;\n  let retryCompilationEndTime = 0;\n\n  const result: RetryOrchestrationResult = {\n    success: true,\n    projectsWithRetries: [],\n    totalTasksRequiringRetry: 0,\n    totalSuccessfulRetries: 0,\n    totalFailedRetries: 0,\n    projectsWithSuccessfulDependencyInstallation: [],\n    projectsWithFailedDependencyInstallation: [],\n    retryDurationMs: 0,\n    dependencyInstallationDurationMs: 0,\n    retryCompilationDurationMs: 0,\n  };\n\n  try {\n    // Phase 1: Validate current outputs and identify failed tasks\n    cdsExtractorLog('info', 'Identifying tasks requiring retry...');\n    const tasksRequiringRetry = identifyTasksRequiringRetry(dependencyGraph);\n\n    if (tasksRequiringRetry.size === 0) {\n      cdsExtractorLog('info', 'No tasks require retry - all compilations successful');\n      return result;\n    }\n\n    // Update retry status tracking\n    result.totalTasksRequiringRetry = Array.from(tasksRequiringRetry.values()).reduce(\n      (sum, tasks) => sum + tasks.length,\n      0,\n    );\n    dependencyGraph.retryStatus.totalTasksRequiringRetry = result.totalTasksRequiringRetry;\n\n    // Phase 2: Install full dependencies for projects with failed tasks\n    cdsExtractorLog('info', 'Installing full dependencies for projects requiring retry...');\n    dependencyInstallationStartTime = Date.now();\n\n    for (const [projectDir, failedTasks] of tasksRequiringRetry) {\n      const project = dependencyGraph.projects.get(projectDir);\n      if (!project) {\n        continue;\n      }\n\n      if (needsFullDependencyInstallation(project)) {\n        try {\n          const installResult = installFullDependencies(\n            project,\n            dependencyGraph.sourceRootDir,\n            codeqlExePath,\n          );\n\n          // Update project retry status\n          project.retryStatus ??= {\n            fullDependenciesInstalled: false,\n            tasksRequiringRetry: failedTasks.length,\n            tasksRetried: 0,\n            installationErrors: [],\n          };\n\n          if (installResult.success) {\n            project.retryStatus.fullDependenciesInstalled = true;\n            project.fullDependencyCacheDir = installResult.retryCacheDir;\n            result.projectsWithSuccessfulDependencyInstallation.push(projectDir);\n            dependencyGraph.retryStatus.projectsWithFullDependencies.add(projectDir);\n          } else {\n            project.retryStatus.installationErrors = [\n              ...(project.retryStatus.installationErrors ?? []),\n              installResult.error ?? 'Unknown installation error',\n            ];\n            result.projectsWithFailedDependencyInstallation.push(projectDir);\n          }\n\n          if (installResult.warnings.length > 0) {\n            for (const warning of installResult.warnings) {\n              dependencyGraph.errors.warnings.push({\n                phase: 'retry_dependency_installation',\n                message: warning,\n                timestamp: new Date(),\n                context: projectDir,\n              });\n            }\n          }\n        } catch (error) {\n          const errorMessage = `Failed to install full dependencies for project ${projectDir}: ${String(error)}`;\n          cdsExtractorLog('error', errorMessage);\n\n          dependencyGraph.errors.critical.push({\n            phase: 'retry_dependency_installation',\n            message: errorMessage,\n            timestamp: new Date(),\n          });\n\n          result.projectsWithFailedDependencyInstallation.push(projectDir);\n        }\n      }\n\n      dependencyGraph.retryStatus.projectsRequiringFullDependencies.add(projectDir);\n    }\n\n    dependencyInstallationEndTime = Date.now();\n    result.dependencyInstallationDurationMs =\n      dependencyInstallationEndTime - dependencyInstallationStartTime;\n\n    // Phase 3: Execute retry compilation attempts\n    cdsExtractorLog('info', 'Executing retry compilation attempts...');\n    retryCompilationStartTime = Date.now();\n\n    for (const [projectDir, failedTasks] of tasksRequiringRetry) {\n      const project = dependencyGraph.projects.get(projectDir);\n      if (!project) {\n        continue;\n      }\n\n      const retryExecutionResult = executeRetryCompilation(\n        failedTasks,\n        project,\n        dependencyGraph,\n        baseProjectCacheDirMap,\n        codeqlExePath,\n      );\n\n      result.projectsWithRetries.push(projectDir);\n      result.totalSuccessfulRetries += retryExecutionResult.successfulRetries;\n      result.totalFailedRetries += retryExecutionResult.failedRetries;\n\n      // Update project retry status\n      if (project.retryStatus) {\n        project.retryStatus.tasksRetried = retryExecutionResult.retriedTasks.length;\n      }\n    }\n\n    retryCompilationEndTime = Date.now();\n    result.retryCompilationDurationMs = retryCompilationEndTime - retryCompilationStartTime;\n\n    // Phase 4: Update dependency graph with retry results\n    updateDependencyGraphWithRetryResults(dependencyGraph, result);\n\n    // Phase 5: Add diagnostics for definitively failed tasks\n    addDiagnosticsForFailedTasks(dependencyGraph, codeqlExePath);\n\n    result.success = result.totalSuccessfulRetries > 0 || result.totalTasksRequiringRetry === 0;\n  } catch (error) {\n    const errorMessage = `Retry orchestration failed: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n\n    dependencyGraph.errors.critical.push({\n      phase: 'retry_orchestration',\n      message: errorMessage,\n      timestamp: new Date(),\n    });\n\n    result.success = false;\n  } finally {\n    result.retryDurationMs = Date.now() - startTime;\n  }\n\n  return result;\n}\n\n/**\n * Executes retry compilation for specific tasks\n * @param tasksToRetry Tasks that need to be retried\n * @param project The project containing the tasks\n * @param dependencyGraph The dependency graph\n * @param baseProjectCacheDirMap Original cache directory mappings\n * @param codeqlExePath Path to CodeQL executable\n * @returns Retry execution results\n */\nexport function executeRetryCompilation(\n  tasksToRetry: CompilationTask[],\n  project: CdsProject,\n  dependencyGraph: CdsDependencyGraph,\n  baseProjectCacheDirMap: Map<string, string>,\n  _codeqlExePath: string,\n): RetryExecutionResult {\n  const startTime = Date.now();\n\n  const result: RetryExecutionResult = {\n    projectDir: project.projectDir,\n    retriedTasks: [],\n    successfulRetries: 0,\n    failedRetries: 0,\n    fullDependenciesAvailable: Boolean(project.fullDependencyCacheDir),\n    executionDurationMs: 0,\n    retryErrors: [],\n  };\n\n  // Determine cache directory to use for retry\n  const cacheDir = project.fullDependencyCacheDir ?? baseProjectCacheDirMap.get(project.projectDir);\n  const cdsCommand = determineCdsCommand(cacheDir, dependencyGraph.sourceRootDir);\n\n  cdsExtractorLog(\n    'info',\n    `Retrying ${tasksToRetry.length} task(s) for project ${project.projectDir} using ${result.fullDependenciesAvailable ? 'full' : 'minimal'} dependencies`,\n  );\n\n  for (const task of tasksToRetry) {\n    try {\n      // Mark task as being retried\n      task.retryInfo = {\n        hasBeenRetried: true,\n        retryReason: 'Output validation failed',\n        fullDependenciesInstalled: result.fullDependenciesAvailable,\n        retryTimestamp: new Date(),\n      };\n\n      // Execute retry compilation attempt\n      const retryAttempt = attemptRetryCompilation(task, cdsCommand, cacheDir, dependencyGraph);\n\n      task.retryInfo.retryAttempt = retryAttempt;\n      task.attempts.push(retryAttempt);\n      result.retriedTasks.push(task);\n\n      if (retryAttempt.result.success) {\n        task.status = 'success';\n        result.successfulRetries++;\n        cdsExtractorLog('info', `Retry successful for task ${task.id}`);\n      } else {\n        task.status = 'failed';\n        task.errorSummary = retryAttempt.error?.message ?? 'Retry compilation failed';\n        result.failedRetries++;\n        result.retryErrors.push(task.errorSummary);\n        cdsExtractorLog('warn', `Retry failed for task ${task.id}: ${task.errorSummary}`);\n      }\n    } catch (error) {\n      const errorMessage = `Failed to retry task ${task.id}: ${String(error)}`;\n      result.retryErrors.push(errorMessage);\n      result.failedRetries++;\n      task.status = 'failed';\n      task.errorSummary = errorMessage;\n      cdsExtractorLog('error', errorMessage);\n    }\n  }\n\n  result.executionDurationMs = Date.now() - startTime;\n\n  cdsExtractorLog(\n    'info',\n    `Retry execution completed for project ${project.projectDir}: ${result.successfulRetries} successful, ${result.failedRetries} failed`,\n  );\n\n  return result;\n}\n\n/**\n * Updates dependency graph with retry results\n * @param dependencyGraph The dependency graph to update\n * @param retryResults The retry orchestration results\n */\nexport function updateDependencyGraphWithRetryResults(\n  dependencyGraph: CdsDependencyGraph,\n  retryResults: RetryOrchestrationResult,\n): void {\n  // Update overall status summary\n  dependencyGraph.retryStatus.totalTasksSuccessfullyRetried = retryResults.totalSuccessfulRetries;\n  dependencyGraph.retryStatus.totalRetryAttempts =\n    retryResults.totalSuccessfulRetries + retryResults.totalFailedRetries;\n\n  // Update compilation status counters\n  dependencyGraph.statusSummary.successfulCompilations += retryResults.totalSuccessfulRetries;\n  dependencyGraph.statusSummary.failedCompilations -= retryResults.totalSuccessfulRetries;\n\n  // Update overall success status\n  const hasFailures =\n    dependencyGraph.statusSummary.failedCompilations > 0 ||\n    dependencyGraph.errors.critical.length > 0;\n  dependencyGraph.statusSummary.overallSuccess = !hasFailures;\n}\n\n/**\n * Add diagnostics only for tasks that remain failed after retry attempts\n * @param dependencyGraph The dependency graph\n * @param codeqlExePath Path to CodeQL executable\n */\nfunction addDiagnosticsForFailedTasks(\n  dependencyGraph: CdsDependencyGraph,\n  codeqlExePath: string,\n): void {\n  for (const project of dependencyGraph.projects.values()) {\n    for (const task of project.compilationTasks) {\n      // Add diagnostics for tasks that are definitively failed\n      // This includes both tasks that failed after retry and tasks that failed initially but didn't require retry\n      if (task.status === 'failed') {\n        const shouldAddDiagnostic = task.retryInfo?.hasBeenRetried ?? !task.retryInfo; // Failed after retry attempt or failed initially and was never retried\n\n        if (shouldAddDiagnostic) {\n          for (const sourceFile of task.sourceFiles) {\n            addCompilationDiagnostic(\n              sourceFile,\n              task.errorSummary ?? 'Compilation failed',\n              codeqlExePath,\n            );\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Attempt compilation with retry-specific context\n * @param task The compilation task to retry\n * @param cdsCommand CDS command to use\n * @param cacheDir Cache directory to use\n * @param dependencyGraph The dependency graph\n * @returns Compilation attempt result\n */\nfunction attemptRetryCompilation(\n  task: CompilationTask,\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  dependencyGraph: CdsDependencyGraph,\n): CompilationAttempt {\n  const attemptId = `${task.id}_retry_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\n  const startTime = new Date();\n\n  const attempt: CompilationAttempt = {\n    id: attemptId,\n    cdsCommand,\n    cacheDir,\n    timestamp: startTime,\n    result: {\n      success: false,\n      timestamp: startTime,\n    },\n  };\n\n  try {\n    // Use the same compilation logic as the original attempt\n    const primarySourceFile = task.sourceFiles[0];\n\n    const compilationResult = compileCdsToJson(\n      primarySourceFile,\n      dependencyGraph.sourceRootDir,\n      cdsCommand,\n      cacheDir,\n      // Convert CDS projects to BasicCdsProject format expected by compileCdsToJson\n      new Map(\n        Array.from(dependencyGraph.projects.entries()).map(([key, value]) => [\n          key,\n          {\n            cdsFiles: value.cdsFiles,\n            cdsFilesToCompile: value.cdsFilesToCompile,\n            expectedOutputFiles: value.expectedOutputFiles,\n            projectDir: value.projectDir,\n            dependencies: value.dependencies,\n            imports: value.imports,\n            packageJson: value.packageJson,\n          },\n        ]),\n      ),\n      task.projectDir,\n    );\n\n    attempt.result = {\n      ...compilationResult,\n      timestamp: startTime,\n    };\n  } catch (error) {\n    attempt.error = {\n      message: String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n    };\n  }\n\n  return attempt;\n}\n", "import { determineCdsCommand } from './command';\nimport { compileCdsToJson } from './compile';\nimport { orchestrateRetryAttempts } from './retry';\nimport { CompilationAttempt, CompilationTask, CompilationConfig } from './types';\nimport { cdsExtractorLog, generateStatusReport } from '../../logging';\nimport { CdsDependencyGraph, CdsProject } from '../parser/types';\n\n/** Attempt compilation with a specific command and configuration. */\nfunction attemptCompilation(\n  task: CompilationTask,\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  dependencyGraph: CdsDependencyGraph,\n): CompilationAttempt {\n  const attemptId = `${task.id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\n  const startTime = new Date();\n\n  const attempt: CompilationAttempt = {\n    id: attemptId,\n    cdsCommand,\n    cacheDir,\n    timestamp: startTime,\n    result: {\n      success: false,\n      timestamp: startTime,\n    },\n  };\n\n  try {\n    // For now, we'll use the first source file for compilation\n    // In a more sophisticated implementation, we might handle project-level compilation differently\n    const primarySourceFile = task.sourceFiles[0];\n\n    const compilationResult = compileCdsToJson(\n      primarySourceFile,\n      dependencyGraph.sourceRootDir,\n      cdsCommand,\n      cacheDir,\n      // Convert CDS projects to BasicCdsProject format expected by compileCdsToJson\n      new Map(\n        Array.from(dependencyGraph.projects.entries()).map(([key, value]) => [\n          key,\n          {\n            cdsFiles: value.cdsFiles,\n            cdsFilesToCompile: value.cdsFilesToCompile,\n            expectedOutputFiles: value.expectedOutputFiles,\n            projectDir: value.projectDir,\n            dependencies: value.dependencies,\n            imports: value.imports,\n            packageJson: value.packageJson,\n            compilationConfig: value.compilationConfig,\n          },\n        ]),\n      ),\n      task.projectDir,\n    );\n\n    const endTime = new Date();\n    attempt.result = {\n      ...compilationResult,\n      timestamp: endTime,\n      durationMs: endTime.getTime() - startTime.getTime(),\n      commandUsed: cdsCommand,\n      cacheDir,\n    };\n\n    if (compilationResult.success && compilationResult.outputPath) {\n      dependencyGraph.statusSummary.jsonFilesGenerated++;\n    }\n  } catch (error) {\n    const endTime = new Date();\n    attempt.error = {\n      message: String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n    };\n    attempt.result.timestamp = endTime;\n    attempt.result.durationMs = endTime.getTime() - startTime.getTime();\n  }\n\n  task.attempts.push(attempt);\n  return attempt;\n}\n\n/**\n * Create a compilation task for a project or individual file\n */\nfunction createCompilationTask(\n  type: 'file' | 'project',\n  sourceFiles: string[],\n  expectedOutputFiles: string[],\n  projectDir: string,\n  useProjectLevelCompilation: boolean,\n): CompilationTask {\n  return {\n    id: `${type}_${projectDir}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    type,\n    status: 'pending',\n    sourceFiles,\n    expectedOutputFiles,\n    projectDir,\n    attempts: [],\n    useProjectLevelCompilation,\n    dependencies: [],\n  };\n}\n\nfunction createCompilationConfig(\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  useProjectLevel: boolean,\n): CompilationConfig {\n  return {\n    cdsCommand: cdsCommand,\n    cacheDir: cacheDir,\n    useProjectLevelCompilation: useProjectLevel,\n    versionCompatibility: {\n      isCompatible: true, // Will be validated during planning\n    },\n    maxRetryAttempts: 3,\n  };\n}\n\n/**\n * Execute a single compilation task\n */\nfunction executeCompilationTask(\n  task: CompilationTask,\n  project: CdsProject,\n  dependencyGraph: CdsDependencyGraph,\n  _codeqlExePath: string,\n): void {\n  task.status = 'in_progress';\n\n  const config = project.enhancedCompilationConfig;\n  if (!config) {\n    throw new Error(`No compilation configuration found for project ${project.projectDir}`);\n  }\n\n  const compilationAttempt = attemptCompilation(\n    task,\n    config.cdsCommand,\n    config.cacheDir,\n    dependencyGraph,\n  );\n\n  if (compilationAttempt.result.success) {\n    task.status = 'success';\n    dependencyGraph.statusSummary.successfulCompilations++;\n    return;\n  }\n\n  // Compilation failed - mark task as failed\n  const lastError = compilationAttempt.error\n    ? new Error(compilationAttempt.error.message)\n    : new Error('Compilation failed');\n\n  task.status = 'failed';\n  task.errorSummary = lastError?.message || 'Compilation failed';\n  dependencyGraph.statusSummary.failedCompilations++;\n\n  // Note: Diagnostics are deferred until after retry phase completes\n  // to implement \"Silent Success\" - only add diagnostics for definitively failed tasks\n\n  cdsExtractorLog('error', `Compilation failed for task ${task.id}: ${task.errorSummary}`);\n}\n\n/**\n * Executes all compilation tasks for the provided {@link CdsDependencyGraph}.\n * Uses the provided `codeqlExePath` to run the CodeQL CLI, as needed, for\n * generating diagnositic warnings and/or errors for problems encountered while\n * running the CodeQL CDS extractor.\n */\nfunction executeCompilationTasks(dependencyGraph: CdsDependencyGraph, codeqlExePath: string): void {\n  cdsExtractorLog('info', 'Starting compilation execution for all projects...');\n\n  dependencyGraph.currentPhase = 'compiling';\n  const compilationStartTime = new Date();\n\n  // Collect all compilation tasks from all projects.\n  const allTasks: Array<{ task: CompilationTask; project: CdsProject }> = [];\n\n  for (const project of dependencyGraph.projects.values()) {\n    for (const task of project.compilationTasks) {\n      allTasks.push({ task, project });\n    }\n  }\n\n  // Execute compilation tasks sequentially. There is room for optimization in the future.\n  // For now, we keep it simple to ensure consistent debug information collection.\n  cdsExtractorLog('info', `Executing ${allTasks.length} compilation task(s)...`);\n  for (const { task, project } of allTasks) {\n    try {\n      executeCompilationTask(task, project, dependencyGraph, codeqlExePath);\n    } catch (error) {\n      const errorMessage = `Failed to execute compilation task ${task.id}: ${String(error)}`;\n      cdsExtractorLog('error', errorMessage);\n\n      dependencyGraph.errors.critical.push({\n        phase: 'compiling',\n        message: errorMessage,\n        timestamp: new Date(),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n\n      task.status = 'failed';\n      task.errorSummary = errorMessage;\n      dependencyGraph.statusSummary.failedCompilations++;\n    }\n  }\n\n  // Update project statuses\n  for (const project of dependencyGraph.projects.values()) {\n    const allTasksCompleted = project.compilationTasks.every(\n      task => task.status === 'success' || task.status === 'failed',\n    );\n\n    if (allTasksCompleted) {\n      const hasFailedTasks = project.compilationTasks.some(task => task.status === 'failed');\n      project.status = hasFailedTasks ? 'failed' : 'completed';\n      project.timestamps.compilationCompleted = new Date();\n    }\n  }\n\n  const compilationEndTime = new Date();\n  dependencyGraph.statusSummary.performance.compilationDurationMs =\n    compilationEndTime.getTime() - compilationStartTime.getTime();\n\n  cdsExtractorLog(\n    'info',\n    `Compilation execution completed. Success: ${dependencyGraph.statusSummary.successfulCompilations}, Failed: ${dependencyGraph.statusSummary.failedCompilations}`,\n  );\n}\n\n/**\n * Orchestrates the compilation process for CDS files based on a dependency graph.\n *\n * This function coordinates the planning and execution of compilation tasks,\n * tracks the compilation status, and generates a post-compilation report.\n *\n * @param dependencyGraph - The {@link CdsDependencyGraph} representing the CDS projects,\n * project dependencies, expected compilation tasks, and their statuses.\n * @param projectCacheDirMap - A map from project identifiers to their cache directory paths.\n * @param codeqlExePath - The path to the CodeQL executable. Used for generating diagnostic\n * messages as part of the broader CodeQL (JavaScript) extraction process.\n * @throws Will rethrow any errors encountered during compilation, after logging them.\n */\nexport function orchestrateCompilation(\n  dependencyGraph: CdsDependencyGraph,\n  projectCacheDirMap: Map<string, string>,\n  codeqlExePath: string,\n): void {\n  try {\n    // Phase 1: Initial compilation\n    planCompilationTasks(dependencyGraph, projectCacheDirMap);\n    executeCompilationTasks(dependencyGraph, codeqlExePath);\n\n    // Phase 2: Retry orchestration\n    cdsExtractorLog('info', 'Starting retry orchestration phase...');\n    const retryResults = orchestrateRetryAttempts(\n      dependencyGraph,\n      projectCacheDirMap,\n      codeqlExePath,\n    );\n\n    // Log retry results\n    if (retryResults.totalTasksRequiringRetry > 0) {\n      cdsExtractorLog(\n        'info',\n        `Retry phase completed: ${retryResults.totalTasksRequiringRetry} tasks retried, ${retryResults.totalSuccessfulRetries} successful, ${retryResults.totalFailedRetries} failed`,\n      );\n    } else {\n      cdsExtractorLog('info', 'Retry phase completed: no tasks required retry');\n    }\n\n    // Phase 3: Final status update\n    const hasFailures =\n      dependencyGraph.statusSummary.failedCompilations > 0 ||\n      dependencyGraph.errors.critical.length > 0;\n\n    dependencyGraph.statusSummary.overallSuccess = !hasFailures;\n    dependencyGraph.currentPhase = hasFailures ? 'failed' : 'completed';\n\n    // Generate and log a \"Post-Compilation\" status report, aka before the JavaScript extractor runs.\n    const statusReport = generateStatusReport(dependencyGraph);\n    cdsExtractorLog('info', 'CDS Extractor Status Report : Post-Compilation...\\n' + statusReport);\n  } catch (error) {\n    const errorMessage = `Compilation orchestration failed: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n\n    dependencyGraph.errors.critical.push({\n      phase: 'compiling',\n      message: errorMessage,\n      timestamp: new Date(),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n\n    dependencyGraph.currentPhase = 'failed';\n    dependencyGraph.statusSummary.overallSuccess = false;\n\n    throw error;\n  }\n}\n\n/** Plan compilation tasks for all projects in the dependency graph. */\nfunction planCompilationTasks(\n  dependencyGraph: CdsDependencyGraph,\n  projectCacheDirMap: Map<string, string>,\n): void {\n  cdsExtractorLog('info', 'Planning compilation tasks for all projects...');\n\n  dependencyGraph.currentPhase = 'compilation_planning';\n\n  for (const [projectDir, project] of dependencyGraph.projects.entries()) {\n    try {\n      const cacheDir = projectCacheDirMap.get(projectDir);\n\n      // Determine CDS command\n      const cdsCommand = determineCdsCommand(cacheDir, dependencyGraph.sourceRootDir);\n\n      // Create compilation configuration\n      const compilationConfig = createCompilationConfig(\n        cdsCommand,\n        cacheDir,\n        project.cdsFilesToCompile.includes('__PROJECT_LEVEL_COMPILATION__'),\n      );\n\n      project.enhancedCompilationConfig = compilationConfig;\n\n      // Create compilation tasks\n      if (project.cdsFilesToCompile.includes('__PROJECT_LEVEL_COMPILATION__')) {\n        // Project-level compilation\n        const task = createCompilationTask(\n          'project',\n          project.cdsFiles,\n          project.expectedOutputFiles,\n          projectDir,\n          true,\n        );\n        project.compilationTasks = [task];\n      } else {\n        // Individual file compilation\n        const tasks: CompilationTask[] = [];\n        for (const cdsFile of project.cdsFilesToCompile) {\n          const expectedOutput = `${cdsFile}.json`;\n          const task = createCompilationTask(\n            'file',\n            [cdsFile],\n            [expectedOutput],\n            projectDir,\n            false,\n          );\n          tasks.push(task);\n        }\n        project.compilationTasks = tasks;\n      }\n\n      project.status = 'compilation_planned';\n      project.timestamps.compilationStarted = new Date();\n\n      cdsExtractorLog(\n        'info',\n        `Planned ${project.compilationTasks.length} compilation task(s) for project ${projectDir}`,\n      );\n    } catch (error) {\n      const errorMessage = `Failed to plan compilation for project ${projectDir}: ${String(error)}`;\n      cdsExtractorLog('error', errorMessage);\n\n      dependencyGraph.errors.critical.push({\n        phase: 'compilation_planning',\n        message: errorMessage,\n        timestamp: new Date(),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n\n      project.status = 'failed';\n    }\n  }\n\n  const totalTasks = Array.from(dependencyGraph.projects.values()).reduce(\n    (sum, project) => sum + project.compilationTasks.length,\n    0,\n  );\n\n  dependencyGraph.statusSummary.totalCompilationTasks = totalTasks;\n\n  cdsExtractorLog('info', `Compilation planning completed. Total tasks: ${totalTasks}`);\n}\n", "import { relative } from 'path';\n\n/**\n * Helper functions for mapping CDS files to their projects and cache directories\n */\n\n/**\n * Find the project directory for a CDS file\n * @param cdsFilePath Path to the CDS file\n * @param sourceRoot Source root directory\n * @param projectMap Map of project directories to project objects\n * @returns The project directory the file belongs to, or undefined if not found\n */\nexport function findProjectForCdsFile(\n  cdsFilePath: string,\n  sourceRoot: string,\n  projectMap: Map<string, { cdsFiles: string[] }>,\n): string | undefined {\n  // Get the relative path to the project directory for this CDS file\n  const relativeCdsFilePath = relative(sourceRoot, cdsFilePath);\n\n  // If the file is outside the source root, path.relative() will start with '../'\n  // In this case, we should also check against the absolute path\n  const isOutsideSourceRoot = relativeCdsFilePath.startsWith('../');\n\n  // Find the project this file belongs to\n  for (const [projectDir, project] of projectMap.entries()) {\n    if (\n      project.cdsFiles.some(\n        cdsFile =>\n          cdsFile === relativeCdsFilePath ||\n          relativeCdsFilePath.startsWith(projectDir) ||\n          (isOutsideSourceRoot && cdsFile === cdsFilePath),\n      )\n    ) {\n      return projectDir;\n    }\n  }\n\n  return undefined;\n}\n", "import { dirname, join, resolve, sep } from 'path';\n\nimport {\n  determineCdsFilesForProjectDir,\n  determineCdsFilesToCompile,\n  determineCdsProjectsUnderSourceDir,\n  extractCdsImports,\n  readPackageJsonFile,\n} from './functions';\nimport { CdsDependencyGraph, CdsImport, CdsProject, BasicCdsProject } from './types';\nimport { cdsExtractorLog } from '../../logging';\n\n/**\n * Builds a basic dependency graph of CDS projects and performs the initial parsing stage of the CDS extractor.\n * This is the internal function that creates basic project structures.\n *\n * @param sourceRootDir - Source root directory\n * @returns Map of project directories to their BasicCdsProject objects with dependency information\n */\nfunction buildBasicCdsProjectDependencyGraph(sourceRootDir: string): Map<string, BasicCdsProject> {\n  // Find all CDS projects under the source directory\n  cdsExtractorLog('info', 'Detecting CDS projects...');\n  const projectDirs = determineCdsProjectsUnderSourceDir(sourceRootDir);\n\n  if (projectDirs.length === 0) {\n    cdsExtractorLog('info', 'No CDS projects found.');\n    return new Map<string, BasicCdsProject>();\n  }\n\n  cdsExtractorLog('info', `Found ${projectDirs.length} CDS project(s) under source directory.`);\n\n  const projectMap = new Map<string, BasicCdsProject>();\n\n  // First pass: create CdsProject objects for each project directory\n  for (const projectDir of projectDirs) {\n    const absoluteProjectDir = join(sourceRootDir, projectDir);\n    const cdsFiles = determineCdsFilesForProjectDir(sourceRootDir, absoluteProjectDir);\n\n    // Try to load package.json if it exists\n    const packageJsonPath = join(absoluteProjectDir, 'package.json');\n    const packageJson = readPackageJsonFile(packageJsonPath);\n\n    projectMap.set(projectDir, {\n      projectDir,\n      cdsFiles,\n      cdsFilesToCompile: [], // Will be populated in the third pass\n      expectedOutputFiles: [], // Will be populated in the fourth pass\n      packageJson,\n      dependencies: [],\n      imports: new Map<string, CdsImport[]>(),\n    });\n  }\n\n  // Second pass: analyze dependencies between projects\n  cdsExtractorLog('info', 'Analyzing dependencies between CDS projects...');\n  for (const [projectDir, project] of projectMap.entries()) {\n    // Check each CDS file for imports\n    for (const relativeFilePath of project.cdsFiles) {\n      const absoluteFilePath = join(sourceRootDir, relativeFilePath);\n\n      try {\n        const imports = extractCdsImports(absoluteFilePath);\n        const enrichedImports: CdsImport[] = [];\n\n        // Process each import\n        for (const importInfo of imports) {\n          const enrichedImport: CdsImport = { ...importInfo };\n\n          if (importInfo.isRelative) {\n            // Resolve the relative import path\n            const importedFilePath = resolve(dirname(absoluteFilePath), importInfo.path);\n            const normalizedImportedPath = importedFilePath.endsWith('.cds')\n              ? importedFilePath\n              : `${importedFilePath}.cds`;\n\n            // Store the resolved path relative to source root\n            try {\n              const relativeToDirPath = dirname(relativeFilePath);\n              const resolvedPath = resolve(join(sourceRootDir, relativeToDirPath), importInfo.path);\n              const normalizedResolvedPath = resolvedPath.endsWith('.cds')\n                ? resolvedPath\n                : `${resolvedPath}.cds`;\n\n              // Convert to relative path from source root\n              if (normalizedResolvedPath.startsWith(sourceRootDir)) {\n                enrichedImport.resolvedPath = normalizedResolvedPath\n                  .substring(sourceRootDir.length)\n                  .replace(/^[/\\\\]/, '');\n              }\n            } catch (error) {\n              cdsExtractorLog(\n                'warn',\n                `Could not resolve import path for ${importInfo.path} in ${relativeFilePath}: ${String(error)}`,\n              );\n            }\n\n            // Find which project contains this imported file\n            for (const [otherProjectDir, otherProject] of projectMap.entries()) {\n              if (otherProjectDir === projectDir) continue; // Skip self\n\n              const otherProjectAbsoluteDir = join(sourceRootDir, otherProjectDir);\n\n              // Check if the imported file is in the other project\n              const isInOtherProject = otherProject.cdsFiles.some(otherFile => {\n                const otherAbsolutePath = join(sourceRootDir, otherFile);\n                return (\n                  otherAbsolutePath === normalizedImportedPath ||\n                  normalizedImportedPath.startsWith(otherProjectAbsoluteDir + sep)\n                );\n              });\n\n              if (isInOtherProject) {\n                // Add dependency if not already present\n                project.dependencies ??= [];\n\n                if (!project.dependencies.includes(otherProject)) {\n                  project.dependencies.push(otherProject);\n                }\n              }\n            }\n          }\n          // For module imports, check package.json dependencies\n          else if (importInfo.isModule && project.packageJson) {\n            const dependencies = {\n              ...(project.packageJson.dependencies ?? {}),\n              ...(project.packageJson.devDependencies ?? {}),\n            };\n\n            // Extract module name from import path (e.g., '@sap/cds/common' -> '@sap/cds')\n            const moduleName = importInfo.path.split('/')[0].startsWith('@')\n              ? importInfo.path.split('/').slice(0, 2).join('/')\n              : importInfo.path.split('/')[0];\n\n            if (dependencies[moduleName]) {\n              // This is a valid module dependency, nothing more to do here\n              // In the future, we could track module dependencies separately\n            }\n          }\n\n          enrichedImports.push(enrichedImport);\n        }\n\n        // Store the enriched imports in the project\n        project.imports?.set(relativeFilePath, enrichedImports);\n      } catch (error: unknown) {\n        cdsExtractorLog(\n          'warn',\n          `Error processing imports in ${absoluteFilePath}: ${String(error)}`,\n        );\n      }\n    }\n  }\n\n  // Third pass: determine CDS files to compile and expected output files for each project\n  cdsExtractorLog(\n    'info',\n    'Determining CDS files to compile and expected output files for each project...',\n  );\n  for (const [, project] of projectMap.entries()) {\n    try {\n      const projectPlan = determineCdsFilesToCompile(sourceRootDir, project);\n\n      // Assign the calculated values back to the project\n      project.cdsFilesToCompile = projectPlan.filesToCompile;\n      project.expectedOutputFiles = projectPlan.expectedOutputFiles;\n\n      // Check if using project-level compilation\n      const usesProjectLevelCompilation = projectPlan.filesToCompile.includes(\n        '__PROJECT_LEVEL_COMPILATION__',\n      );\n\n      if (usesProjectLevelCompilation) {\n        cdsExtractorLog(\n          'info',\n          `Project ${project.projectDir}: using project-level compilation for all ${project.cdsFiles.length} CDS files, expecting ${projectPlan.expectedOutputFiles.length} output files`,\n        );\n      } else {\n        cdsExtractorLog(\n          'info',\n          `Project ${project.projectDir}: ${projectPlan.filesToCompile.length} files to compile out of ${project.cdsFiles.length} total CDS files, expecting ${projectPlan.expectedOutputFiles.length} output files`,\n        );\n      }\n    } catch (error) {\n      cdsExtractorLog(\n        'warn',\n        `Error determining files to compile for project ${project.projectDir}: ${String(error)}`,\n      );\n      // Fall back to compiling all files on error\n      project.cdsFilesToCompile = [...project.cdsFiles];\n      project.expectedOutputFiles = [];\n    }\n  }\n\n  return projectMap;\n}\n\n/**\n * Builds a CDS dependency graph with comprehensive tracking and debug information.\n * This is the main function that returns a CdsDependencyGraph instead of a simple Map.\n * The extractor now runs in autobuild mode by default.\n *\n * @param sourceRootDir - Source root directory\n * @returns CDS dependency graph with comprehensive tracking\n */\nexport function buildCdsProjectDependencyGraph(sourceRootDir: string): CdsDependencyGraph {\n  const startTime = new Date();\n\n  // Create the initial dependency graph structure\n  const dependencyGraph: CdsDependencyGraph = {\n    id: `cds_graph_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    sourceRootDir,\n    projects: new Map<string, CdsProject>(),\n    debugInfo: {\n      extractor: {\n        runMode: 'autobuild',\n        sourceRootDir,\n        startTime,\n        environment: {\n          nodeVersion: process.version,\n          platform: process.platform,\n          cwd: process.cwd(),\n          argv: process.argv,\n        },\n      },\n      parser: {\n        projectsDetected: 0,\n        cdsFilesFound: 0,\n        dependencyResolutionSuccess: true,\n        parsingErrors: [],\n        parsingWarnings: [],\n      },\n      compiler: {\n        availableCommands: [],\n        selectedCommand: '',\n        cacheDirectories: [],\n        cacheInitialized: false,\n      },\n    },\n    currentPhase: 'parsing',\n    statusSummary: {\n      overallSuccess: false,\n      totalProjects: 0,\n      totalCdsFiles: 0,\n      totalCompilationTasks: 0,\n      successfulCompilations: 0,\n      failedCompilations: 0,\n      skippedCompilations: 0,\n      jsonFilesGenerated: 0,\n      criticalErrors: [],\n      warnings: [],\n      performance: {\n        totalDurationMs: 0,\n        parsingDurationMs: 0,\n        compilationDurationMs: 0,\n        extractionDurationMs: 0,\n      },\n    },\n    config: {\n      maxRetryAttempts: 3,\n      enableDetailedLogging: false, // Debug modes removed\n      generateDebugOutput: false, // Debug modes removed\n      compilationTimeoutMs: 30000, // 30 seconds\n    },\n    errors: {\n      critical: [],\n      warnings: [],\n    },\n    retryStatus: {\n      totalTasksRequiringRetry: 0,\n      totalTasksSuccessfullyRetried: 0,\n      totalRetryAttempts: 0,\n      projectsRequiringFullDependencies: new Set<string>(),\n      projectsWithFullDependencies: new Set<string>(),\n    },\n  };\n\n  try {\n    // Use the existing function to build the basic project map\n    const basicProjectMap = buildBasicCdsProjectDependencyGraph(sourceRootDir);\n\n    // Convert basic projects to CDS projects\n    for (const [projectDir, basicProject] of basicProjectMap.entries()) {\n      const cdsProject: CdsProject = {\n        ...basicProject,\n        id: `project_${projectDir.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`,\n        enhancedCompilationConfig: undefined, // Will be set during compilation planning\n        compilationTasks: [],\n        parserDebugInfo: {\n          dependenciesResolved: [],\n          importErrors: [],\n          parseErrors: new Map<string, string>(),\n        },\n        status: 'discovered',\n        timestamps: {\n          discovered: new Date(),\n        },\n      };\n\n      dependencyGraph.projects.set(projectDir, cdsProject);\n    }\n\n    // Update summary statistics\n    dependencyGraph.statusSummary.totalProjects = dependencyGraph.projects.size;\n    dependencyGraph.statusSummary.totalCdsFiles = Array.from(\n      dependencyGraph.projects.values(),\n    ).reduce((sum, project) => sum + project.cdsFiles.length, 0);\n\n    dependencyGraph.debugInfo.parser.projectsDetected = dependencyGraph.projects.size;\n    dependencyGraph.debugInfo.parser.cdsFilesFound = dependencyGraph.statusSummary.totalCdsFiles;\n\n    // Mark dependency resolution phase as completed\n    dependencyGraph.currentPhase = 'dependency_resolution';\n\n    const endTime = new Date();\n    dependencyGraph.debugInfo.extractor.endTime = endTime;\n    dependencyGraph.debugInfo.extractor.durationMs = endTime.getTime() - startTime.getTime();\n    dependencyGraph.statusSummary.performance.parsingDurationMs =\n      dependencyGraph.debugInfo.extractor.durationMs;\n\n    cdsExtractorLog(\n      'info',\n      `CDS dependency graph created with ${dependencyGraph.projects.size} projects and ${dependencyGraph.statusSummary.totalCdsFiles} CDS files`,\n    );\n\n    return dependencyGraph;\n  } catch (error) {\n    const errorMessage = `Failed to build CDS dependency graph: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n\n    dependencyGraph.errors.critical.push({\n      phase: 'parsing',\n      message: errorMessage,\n      timestamp: new Date(),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n\n    dependencyGraph.currentPhase = 'failed';\n    return dependencyGraph;\n  }\n}\n", "import { existsSync, readFileSync, statSync } from 'fs';\nimport { basename, dirname, join, relative, sep } from 'path';\n\nimport { sync } from 'glob';\n\nimport { CdsFilesToCompile, CdsImport, PackageJson } from './types';\nimport { cdsExtractorLog } from '../../logging';\n\n/**\n * Determines the list of CDS files to be parsed for the specified project directory.\n *\n * @param sourceRootDir - The source root directory to search for CDS files. This is\n * used to resolve relative paths in relation to a common (source root) directory for\n * multiple projects.\n * @param projectDir - The full, local filesystem path of the directory that contains\n * the individual `.cds` definition files for some `CAP` project.\n * @returns An array of strings representing the paths, relative to the source root\n * directory, of the `.cds` files to be parsed for a given project.\n */\nexport function determineCdsFilesForProjectDir(\n  sourceRootDir: string,\n  projectDir: string,\n): string[] {\n  if (!sourceRootDir || !projectDir) {\n    throw new Error(\n      `Unable to determine CDS files for project dir '${projectDir}'; both sourceRootDir and projectDir must be provided.`,\n    );\n  }\n\n  // Normalize paths by removing trailing slashes for comparison\n  const normalizedSourceRoot = sourceRootDir.replace(/[/\\\\]+$/, '');\n  const normalizedProjectDir = projectDir.replace(/[/\\\\]+$/, '');\n\n  if (\n    !normalizedProjectDir.startsWith(normalizedSourceRoot) &&\n    normalizedProjectDir !== normalizedSourceRoot\n  ) {\n    throw new Error(\n      'projectDir must be a subdirectory of sourceRootDir or equal to sourceRootDir.',\n    );\n  }\n\n  try {\n    // Use glob to find all .cds files under the project directory, excluding node_modules\n    const cdsFiles = sync(join(projectDir, '**/*.cds'), {\n      nodir: true,\n      ignore: ['**/node_modules/**', '**/*.testproj/**'],\n    });\n\n    // Convert absolute paths to paths relative to sourceRootDir\n    return cdsFiles.map(file => relative(sourceRootDir, file));\n  } catch (error: unknown) {\n    cdsExtractorLog('error', `Error finding CDS files in ${projectDir}: ${String(error)}`);\n    return [];\n  }\n}\n\n/**\n * Determines the list of distinct CDS projects under the specified source\n * directory.\n * @param sourceRootDir - The source root directory to search for CDS projects.\n * @returns An array of strings representing the paths, relative to the source\n * root directory, of the detected CDS projects.\n */\nexport function determineCdsProjectsUnderSourceDir(sourceRootDir: string): string[] {\n  if (!sourceRootDir || !existsSync(sourceRootDir)) {\n    throw new Error(`Source root directory '${sourceRootDir}' does not exist.`);\n  }\n\n  const foundProjects = new Set<string>();\n\n  // Find all potential project directories by looking for package.json files and CDS files\n  const packageJsonFiles = sync(join(sourceRootDir, '**/package.json'), {\n    nodir: true,\n    ignore: ['**/node_modules/**', '**/*.testproj/**'],\n  });\n\n  const cdsFiles = sync(join(sourceRootDir, '**/*.cds'), {\n    nodir: true,\n    ignore: ['**/node_modules/**', '**/*.testproj/**'],\n  });\n\n  // Collect all potential project directories\n  const candidateDirectories = new Set<string>();\n\n  // Add directories with package.json files\n  for (const packageJsonFile of packageJsonFiles) {\n    candidateDirectories.add(dirname(packageJsonFile));\n  }\n\n  // Add directories with CDS files and try to find their project roots\n  for (const cdsFile of cdsFiles) {\n    const cdsDir = dirname(cdsFile);\n    const projectRoot = findProjectRootFromCdsFile(cdsDir, sourceRootDir);\n    if (projectRoot) {\n      candidateDirectories.add(projectRoot);\n    } else {\n      candidateDirectories.add(cdsDir);\n    }\n  }\n\n  // Filter candidates to only include likely CDS projects\n  for (const dir of candidateDirectories) {\n    if (isLikelyCdsProject(dir)) {\n      const relativePath = relative(sourceRootDir, dir);\n      const projectDir = relativePath || '.';\n\n      // Check if this project is already included as a parent or child of an existing project\n      let shouldAdd = true;\n      const existingProjects = Array.from(foundProjects);\n\n      for (const existingProject of existingProjects) {\n        const existingAbsPath = join(sourceRootDir, existingProject);\n\n        // Skip if this directory is a subdirectory of an existing project,\n        // but only if the parent is not a monorepo with its own CDS content\n        if (dir.startsWith(existingAbsPath + sep)) {\n          // Check if parent is a monorepo root with its own CDS content\n          const parentPackageJsonPath = join(existingAbsPath, 'package.json');\n          const parentPackageJson = readPackageJsonFile(parentPackageJsonPath);\n          const isParentMonorepo =\n            parentPackageJson?.workspaces &&\n            Array.isArray(parentPackageJson.workspaces) &&\n            parentPackageJson.workspaces.length > 0;\n\n          // If parent is a monorepo with CDS content, allow both parent and child\n          if (\n            isParentMonorepo &&\n            (hasStandardCdsContent(existingAbsPath) || hasDirectCdsContent(existingAbsPath))\n          ) {\n            // Both parent and child can coexist as separate CDS projects\n            shouldAdd = true;\n          } else {\n            // Traditional case: exclude subdirectory\n            shouldAdd = false;\n          }\n          break;\n        }\n\n        // Remove existing project if it's a subdirectory of the current directory,\n        // unless the current directory is a monorepo root and the existing project has its own CDS content\n        if (existingAbsPath.startsWith(dir + sep)) {\n          const currentPackageJsonPath = join(dir, 'package.json');\n          const currentPackageJson = readPackageJsonFile(currentPackageJsonPath);\n          const isCurrentMonorepo =\n            currentPackageJson?.workspaces &&\n            Array.isArray(currentPackageJson.workspaces) &&\n            currentPackageJson.workspaces.length > 0;\n\n          // If current is a monorepo and the existing project is a legitimate CDS project, keep both\n          if (!(isCurrentMonorepo && isLikelyCdsProject(existingAbsPath))) {\n            foundProjects.delete(existingProject);\n          }\n        }\n      }\n\n      if (shouldAdd) {\n        foundProjects.add(projectDir);\n      }\n    }\n  }\n\n  return Array.from(foundProjects).sort();\n}\n\n/**\n * Parses a CDS file to extract import statements\n *\n * @param filePath - Path to the CDS file\n * @returns Array of import statements found in the file\n */\nexport function extractCdsImports(filePath: string): CdsImport[] {\n  if (!existsSync(filePath)) {\n    throw new Error(`File does not exist: ${filePath}`);\n  }\n\n  const content = readFileSync(filePath, 'utf8');\n  const imports: CdsImport[] = [];\n\n  // Regular expression to match using statements\n  // This handles: using X from 'path'; and using { X, Y } from 'path';\n  // and also using X as Y from 'path';\n  const usingRegex =\n    /using\\s+(?:{[^}]+}|[\\w.]+(?:\\s+as\\s+[\\w.]+)?)\\s+from\\s+['\"`]([^'\"`]+)['\"`]\\s*;/g;\n\n  let match;\n  while ((match = usingRegex.exec(content)) !== null) {\n    const path = match[1];\n    imports.push({\n      statement: match[0],\n      path,\n      isRelative: path.startsWith('./') || path.startsWith('../'),\n      isModule: !path.startsWith('./') && !path.startsWith('../') && !path.startsWith('/'),\n    });\n  }\n\n  return imports;\n}\n\n/**\n * Attempts to find the project root directory starting from a directory containing a CDS file\n *\n * @param cdsFileDir - Directory containing a CDS file\n * @param sourceRootDir - Source root directory to limit the search\n * @returns The project root directory or null if not found\n */\nfunction findProjectRootFromCdsFile(cdsFileDir: string, sourceRootDir: string): string | null {\n  // Skip node_modules and testproj directories entirely\n  if (cdsFileDir.includes('node_modules') || cdsFileDir.includes('.testproj')) {\n    return null;\n  }\n\n  let currentDir = cdsFileDir;\n\n  // Limit the upward search to the sourceRootDir\n  while (currentDir.startsWith(sourceRootDir)) {\n    // Check if this directory looks like a project root\n    if (isLikelyCdsProject(currentDir)) {\n      // If this is a standard CAP subdirectory (srv, db, app), check if the parent\n      // directory should be the real project root\n      const currentDirName = basename(currentDir);\n      const isStandardSubdir = ['srv', 'db', 'app'].includes(currentDirName);\n\n      if (isStandardSubdir) {\n        const parentDir = dirname(currentDir);\n\n        if (\n          parentDir !== currentDir &&\n          parentDir.startsWith(sourceRootDir) &&\n          !parentDir.includes('node_modules') &&\n          !parentDir.includes('.testproj') &&\n          isLikelyCdsProject(parentDir)\n        ) {\n          // The parent is also a CDS project, so it's likely the real project root\n          return parentDir;\n        }\n      }\n\n      // For non-standard subdirectories, also check if the parent might be a better project root\n      const parentDir = dirname(currentDir);\n\n      if (\n        parentDir !== currentDir &&\n        parentDir.startsWith(sourceRootDir) &&\n        !parentDir.includes('node_modules') &&\n        !parentDir.includes('.testproj')\n      ) {\n        const hasDbDir =\n          existsSync(join(parentDir, 'db')) && statSync(join(parentDir, 'db')).isDirectory();\n        const hasSrvDir =\n          existsSync(join(parentDir, 'srv')) && statSync(join(parentDir, 'srv')).isDirectory();\n        const hasAppDir =\n          existsSync(join(parentDir, 'app')) && statSync(join(parentDir, 'app')).isDirectory();\n\n        // Use the same CAP project structure logic as below\n        if ((hasDbDir && hasSrvDir) || (hasSrvDir && hasAppDir)) {\n          return parentDir;\n        }\n      }\n\n      return currentDir;\n    }\n\n    // Check for typical CAP project structure indicators\n    const hasDbDir =\n      existsSync(join(currentDir, 'db')) && statSync(join(currentDir, 'db')).isDirectory();\n    const hasSrvDir =\n      existsSync(join(currentDir, 'srv')) && statSync(join(currentDir, 'srv')).isDirectory();\n    const hasAppDir =\n      existsSync(join(currentDir, 'app')) && statSync(join(currentDir, 'app')).isDirectory();\n\n    if ((hasDbDir && hasSrvDir) || (hasSrvDir && hasAppDir)) {\n      return currentDir;\n    }\n\n    // Move up one directory\n    const parentDir = dirname(currentDir);\n    if (parentDir === currentDir) {\n      // We've reached the root of the filesystem\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  // If we couldn't determine a proper project root, return the original directory\n  return cdsFileDir;\n}\n\n/**\n * Determines if a directory likely contains a CAP project by checking for key\n * indicators like package.json with CAP dependencies or .cds files in standard\n * locations.\n *\n * @param dir - Directory to check\n * @returns true if the directory likely contains a CAP project\n */\nexport function isLikelyCdsProject(dir: string): boolean {\n  try {\n    // Skip node_modules and testproj directories entirely\n    if (dir.includes('node_modules') || dir.includes('.testproj')) {\n      return false;\n    }\n\n    // Check for CDS files in standard locations (checking both direct and nested files)\n    const hasStandardCdsDirectories = hasStandardCdsContent(dir);\n    const hasDirectCdsFiles = hasDirectCdsContent(dir);\n    const hasCdsFiles = hasStandardCdsDirectories || hasDirectCdsFiles;\n\n    // Check if package.json exists and has CAP dependencies\n    const hasCapDependencies = hasPackageJsonWithCapDeps(dir);\n\n    if (hasCapDependencies) {\n      // If there are CAP dependencies but no CDS files, there's nothing for us to do\n      if (!hasCdsFiles) {\n        return false;\n      }\n\n      // Check if this is a monorepo root\n      const packageJsonPath = join(dir, 'package.json');\n      const packageJson = readPackageJsonFile(packageJsonPath);\n\n      if (\n        packageJson?.workspaces &&\n        Array.isArray(packageJson.workspaces) &&\n        packageJson.workspaces.length > 0\n      ) {\n        // This is likely a monorepo - only treat as CDS project if it has actual CDS content\n        if (!hasCdsFiles) {\n          // This is a monorepo root without its own CDS content\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    // If no CAP dependencies, only consider it a CDS project if it has CDS files\n    return hasCdsFiles;\n  } catch (error: unknown) {\n    cdsExtractorLog('error', `Error checking directory ${dir}: ${String(error)}`);\n    return false;\n  }\n}\n\n/**\n * Check if a directory has CDS content in standard CAP directories.\n */\nfunction hasStandardCdsContent(dir: string): boolean {\n  const standardLocations = [join(dir, 'db'), join(dir, 'srv'), join(dir, 'app')];\n\n  for (const location of standardLocations) {\n    if (existsSync(location) && statSync(location).isDirectory()) {\n      // Check for any .cds files at any level under these directories.\n      const cdsFiles = sync(join(location, '**/*.cds'), { nodir: true });\n      if (cdsFiles.length > 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if a directory has direct CDS files.\n */\nfunction hasDirectCdsContent(dir: string): boolean {\n  const directCdsFiles = sync(join(dir, '*.cds'));\n  return directCdsFiles.length > 0;\n}\n\n/**\n * Safely parses a package.json file, using the cache if available\n * @param filePath - Path to the package.json file\n * @returns The parsed package.json content or undefined if the file doesn't exist or can't be parsed\n */\nexport function readPackageJsonFile(filePath: string): PackageJson | undefined {\n  if (!existsSync(filePath)) {\n    return undefined;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf8');\n    const packageJson = JSON.parse(content) as PackageJson;\n    return packageJson;\n  } catch (error) {\n    cdsExtractorLog('warn', `Error parsing package.json at ${filePath}: ${String(error)}`);\n    return undefined;\n  }\n}\n\n/**\n * Determines which CDS files should be compiled for a given project and what output files to expect.\n * This function analyzes the project structure and dependencies to decide\n * whether to use project-level compilation or individual file compilation.\n *\n * For CAP projects (identified by either having @sap/cds dependencies or\n * typical CAP directory structure), it returns a special marker indicating\n * project-level compilation should be used. For other projects, it attempts\n * to identify root files (files that are not imported by others) and returns\n * those for individual compilation.\n *\n * @param sourceRootDir - The source root directory\n * @param project - The project to analyze, containing cdsFiles, imports, and projectDir\n * @returns Object containing files to compile and expected output files\n */\nexport function determineCdsFilesToCompile(\n  sourceRootDir: string,\n  project: {\n    cdsFiles: string[];\n    imports?: Map<string, CdsImport[]>;\n    projectDir: string;\n  },\n): CdsFilesToCompile {\n  if (!project.cdsFiles || project.cdsFiles.length === 0) {\n    return {\n      filesToCompile: [],\n      expectedOutputFiles: [],\n    };\n  }\n\n  // If there's only one CDS file, it should be compiled individually.\n  if (project.cdsFiles.length === 1) {\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  const absoluteProjectDir = join(sourceRootDir, project.projectDir);\n  const hasCapStructure = hasTypicalCapDirectoryStructure(project.cdsFiles);\n  const hasCapDeps = hasPackageJsonWithCapDeps(absoluteProjectDir);\n\n  // Use project-level compilation only if:\n  // 1. It has CAP package.json dependencies, OR\n  // 2. It has the typical CAP directory structure (db/, srv/ etc.)\n  if (project.cdsFiles.length > 1 && (hasCapStructure || hasCapDeps)) {\n    // For CAP projects, we should use project-level compilation\n    // Return a special marker that indicates the entire project should be compiled together\n    const filesToCompile = ['__PROJECT_LEVEL_COMPILATION__'];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  // For non-CAP projects or when we can't determine project type,\n  // fall back to the original logic of identifying root files\n  if (!project.imports || project.imports.size === 0) {\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  try {\n    // Create a map to track imported files in the project\n    const importedFiles = new Map<string, boolean>();\n\n    // First pass: collect all imported files in the project\n    for (const file of project.cdsFiles) {\n      try {\n        const absoluteFilePath = join(sourceRootDir, file);\n        if (existsSync(absoluteFilePath)) {\n          // Get imports for this file\n          const imports = project.imports.get(file) ?? [];\n\n          // Mark imported files\n          for (const importInfo of imports) {\n            if (importInfo.resolvedPath) {\n              importedFiles.set(importInfo.resolvedPath, true);\n            }\n          }\n        }\n      } catch (error) {\n        cdsExtractorLog('warn', `Error processing imports for ${file}: ${String(error)}`);\n      }\n    }\n\n    // Second pass: identify root files (files that are not imported by others)\n    const rootFiles: string[] = [];\n    for (const file of project.cdsFiles) {\n      const relativePath = relative(sourceRootDir, join(sourceRootDir, file));\n      const isImported = importedFiles.has(relativePath);\n\n      if (!isImported) {\n        rootFiles.push(file);\n      }\n    }\n\n    // If no root files were identified, fall back to compiling all files\n    if (rootFiles.length === 0) {\n      cdsExtractorLog(\n        'warn',\n        `No root CDS files identified in project ${project.projectDir}, will compile all files`,\n      );\n      const filesToCompile = [...project.cdsFiles];\n      return {\n        filesToCompile,\n        expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n      };\n    }\n\n    return {\n      filesToCompile: rootFiles,\n      expectedOutputFiles: computeExpectedOutputFiles(rootFiles, project.projectDir),\n    };\n  } catch (error) {\n    cdsExtractorLog(\n      'warn',\n      `Error determining files to compile for project ${project.projectDir}: ${String(error)}`,\n    );\n    // Fall back to compiling all files on error\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n}\n\n/**\n * Computes the expected output files for a given set of files to compile.\n * This function predicts what .cds.json files will be generated during compilation.\n *\n * @param filesToCompile - Array of files to compile (may include special markers)\n * @param projectDir - The project directory\n * @returns Array of expected output file paths (relative to source root)\n */\nfunction computeExpectedOutputFiles(filesToCompile: string[], projectDir: string): string[] {\n  const expectedFiles: string[] = [];\n\n  // Check if this project uses project-level compilation.\n  const usesProjectLevelCompilation = filesToCompile.includes('__PROJECT_LEVEL_COMPILATION__');\n\n  // Validate that __PROJECT_LEVEL_COMPILATION__ element does not coexist with other\n  // files. We either expect a single project-level compilation marker or a list of\n  // individual files to compile, not both.\n  if (usesProjectLevelCompilation && filesToCompile.length !== 1) {\n    throw new Error(\n      `Invalid compilation configuration: '__PROJECT_LEVEL_COMPILATION__' must be the only element in filesToCompile array, but found ${filesToCompile.length} elements: ${filesToCompile.join(', ')}`,\n    );\n  }\n\n  if (usesProjectLevelCompilation) {\n    // For project-level compilation, expect a single model.cds.json file in the project\n    // root directory.\n    const projectModelFile = join(projectDir, 'model.cds.json');\n    expectedFiles.push(projectModelFile);\n  } else {\n    // For individual file compilation, expect a .cds.json file for each .cds file compiled.\n    for (const cdsFile of filesToCompile) {\n      expectedFiles.push(`${cdsFile}.json`);\n    }\n  }\n\n  return expectedFiles;\n}\n\n/**\n * Determines the expected output files for a project based on its compilation strategy.\n * This function predicts what .cds.json files will be generated during compilation.\n *\n * @param project - The CDS project to analyze\n * @returns Array of expected output file paths (relative to source root)\n */\nexport function determineExpectedOutputFiles(project: {\n  cdsFilesToCompile: string[];\n  projectDir: string;\n}): string[] {\n  const expectedFiles: string[] = [];\n\n  // Check if this project uses project-level compilation.\n  const usesProjectLevelCompilation = project.cdsFilesToCompile.includes(\n    '__PROJECT_LEVEL_COMPILATION__',\n  );\n  // Validate that __PROJECT_LEVEL_COMPILATION__ element does not coexist with other\n  // files. We either expect a single project-level compilation marker or a list of\n  // individual files to compile, not both.\n  if (usesProjectLevelCompilation && project.cdsFilesToCompile.length !== 1) {\n    throw new Error(\n      `Invalid compilation configuration: '__PROJECT_LEVEL_COMPILATION__' must be the only element in cdsFilesToCompile array, but found ${project.cdsFilesToCompile.length} elements: ${project.cdsFilesToCompile.join(', ')}`,\n    );\n  }\n\n  if (usesProjectLevelCompilation) {\n    // For project-level compilation, expect a single model.cds.json file in the project\n    // root directory.\n    const projectModelFile = join(project.projectDir, 'model.cds.json');\n    expectedFiles.push(projectModelFile);\n  } else {\n    // For individual file compilation, expect a .cds.json file for each .cds file compiled.\n    for (const cdsFile of project.cdsFilesToCompile) {\n      expectedFiles.push(`${cdsFile}.json`);\n    }\n  }\n\n  return expectedFiles;\n}\n\n/**\n * Checks if a project has a typical CAP directory structure by looking at the file paths.\n * This is used as a heuristic to determine if project-level compilation should be used.\n *\n * @param cdsFiles - List of CDS files in the project (relative to source root)\n * @returns true if the project appears to have a CAP structure\n */\nfunction hasTypicalCapDirectoryStructure(cdsFiles: string[]): boolean {\n  // Check if there are files in common CAP directories\n  const hasDbFiles = cdsFiles.some(file => file.includes('db/') || file.includes('database/'));\n  const hasSrvFiles = cdsFiles.some(file => file.includes('srv/') || file.includes('service/'));\n\n  // If we have both db and srv files, this looks like a CAP project\n  if (hasDbFiles && hasSrvFiles) {\n    return true;\n  }\n\n  // Check if files are spread across multiple meaningful directories (not just the root)\n  const meaningfulDirectories = new Set(\n    cdsFiles.map(file => dirname(file)).filter(dir => dir !== '.' && dir !== ''), // Exclude root directory\n  );\n\n  // If there are multiple meaningful directories with CDS files, this might be a structured project\n  // But we need to be more selective - only consider it structured if there are actual subdirectories\n  return meaningfulDirectories.size >= 2;\n}\n\n/**\n * Checks if a directory has a package.json with CAP dependencies.\n * This function is used to determine if a directory has the necessary CAP packages installed,\n * which is one indicator that it might be a CAP project.\n *\n * @param dir - Directory to check for package.json with CAP dependencies\n * @returns true if the directory has a package.json with CAP dependencies\n */\nexport function hasPackageJsonWithCapDeps(dir: string): boolean {\n  try {\n    const packageJsonPath = join(dir, 'package.json');\n    const packageJson = readPackageJsonFile(packageJsonPath);\n\n    if (packageJson) {\n      const dependencies = {\n        ...(packageJson.dependencies ?? {}),\n        ...(packageJson.devDependencies ?? {}),\n      };\n\n      // Check for common CAP dependencies\n      return !!(dependencies['@sap/cds'] || dependencies['@sap/cds-dk']);\n    }\n\n    return false;\n  } catch {\n    return false;\n  }\n}\n", "import { spawnSync, SpawnSyncReturns } from 'child_process';\n\nimport { addJavaScriptExtractorDiagnostic } from './diagnostics';\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Run the JavaScript extractor autobuild script\n * @param sourceRoot The source root directory\n * @param autobuildScriptPath Path to the autobuild script\n * @param codeqlExePath Path to the CodeQL executable (optional)\n * @returns Success status and any error message\n */\nexport function runJavaScriptExtractor(\n  sourceRoot: string,\n  autobuildScriptPath: string,\n  codeqlExePath?: string,\n): { success: boolean; error?: string } {\n  cdsExtractorLog(\n    'info',\n    `Extracting the .cds.json files by running the 'javascript' extractor autobuild script:\n        ${autobuildScriptPath}`,\n  );\n\n  /**\n   * Invoke the javascript autobuilder to index the .cds.json files only.\n   *\n   * Environment variables must be passed from this script's process to the\n   * process that invokes the autobuild script, otherwise the CDS autobuild.sh\n   * script will not be invoked by the autobuild script built into the\n   * 'javascript' extractor.\n   *\n   * IMPORTANT: The JavaScript extractor autobuild script must be invoked with\n   * the current working directory set to the project (source) root directory\n   * because it assumes it is running from there.\n   */\n  const result: SpawnSyncReturns<Buffer> = spawnSync(autobuildScriptPath, [], {\n    cwd: sourceRoot,\n    env: process.env,\n    shell: true,\n    stdio: 'inherit',\n  });\n\n  if (result.error) {\n    const errorMessage = `Error running JavaScript extractor: ${result.error.message}`;\n    if (codeqlExePath) {\n      addJavaScriptExtractorDiagnostic(sourceRoot, errorMessage, codeqlExePath);\n    }\n    return {\n      success: false,\n      error: errorMessage,\n    };\n  }\n\n  if (result.status !== 0) {\n    const errorMessage = `JavaScript extractor failed with exit code ${String(result.status)}`;\n    if (codeqlExePath) {\n      addJavaScriptExtractorDiagnostic(sourceRoot, errorMessage, codeqlExePath);\n    }\n    return {\n      success: false,\n      error: errorMessage,\n    };\n  }\n\n  return { success: true };\n}\n", "import { execFileSync } from 'child_process';\nimport { existsSync } from 'fs';\nimport { arch, platform } from 'os';\nimport { join, resolve } from 'path';\n\nimport { dirExists } from './filesystem';\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Interface for platform information\n */\nexport interface PlatformInfo {\n  platform: string;\n  arch: string;\n  isWindows: boolean;\n  exeExtension: string;\n}\n\n/**\n * Interface for environment validation results\n */\nexport interface EnvironmentSetupResult {\n  success: boolean;\n  errorMessages: string[];\n  codeqlExePath: string;\n  jsExtractorRoot: string;\n  autobuildScriptPath: string;\n  platformInfo: PlatformInfo;\n}\n\n/**\n * Get platform information\n * @returns Platform information including OS platform, architecture, and whether it's Windows\n */\nexport function getPlatformInfo(): PlatformInfo {\n  const osPlatform: string = platform();\n  const osPlatformArch: string = arch();\n  const isWindows = osPlatform === 'win32';\n  const exeExtension = isWindows ? '.exe' : '';\n\n  return {\n    platform: osPlatform,\n    arch: osPlatformArch,\n    isWindows,\n    exeExtension,\n  };\n}\n\n/**\n * Get the path to the CodeQL executable.\n * Prioritizes CODEQL_DIST if set and valid. Otherwise, tries to find CodeQL via system PATH.\n * @returns The resolved path to the CodeQL executable, or an empty string if not found.\n */\nexport function getCodeQLExePath(): string {\n  const platformInfo = getPlatformInfo();\n  const codeqlExeName: string = platformInfo.isWindows ? 'codeql.exe' : 'codeql';\n\n  // First, check if CODEQL_DIST is set and valid\n  const codeqlDist = process.env.CODEQL_DIST;\n  if (codeqlDist) {\n    const codeqlPathFromDist = resolve(join(codeqlDist, codeqlExeName));\n    if (existsSync(codeqlPathFromDist)) {\n      cdsExtractorLog('info', `Using CodeQL executable from CODEQL_DIST: ${codeqlPathFromDist}`);\n      return codeqlPathFromDist;\n    } else {\n      cdsExtractorLog(\n        'error',\n        `CODEQL_DIST is set to '${codeqlDist}', but CodeQL executable was not found at '${codeqlPathFromDist}'. Please ensure this path is correct. Falling back to PATH-based discovery.`,\n      );\n      // Fall through to PATH-based discovery\n    }\n  }\n\n  // CODEQL_DIST is not set or was invalid, attempt to find CodeQL via system PATH using 'codeql version --format=json'\n  cdsExtractorLog(\n    'info',\n    'CODEQL_DIST environment variable not set or invalid. Attempting to find CodeQL executable via system PATH using \"codeql version --format=json\".',\n  );\n  try {\n    const versionOutput = execFileSync(codeqlExeName, ['version', '--format=json'], {\n      encoding: 'utf8',\n      timeout: 5000, // 5 seconds timeout\n      stdio: 'pipe', // Suppress output to console\n    });\n\n    interface CodeQLVersionInfo {\n      unpackedLocation?: string;\n      cliVersion?: string; // For potential future use or richer logging\n    }\n\n    try {\n      const versionInfo = JSON.parse(versionOutput) as CodeQLVersionInfo;\n\n      if (\n        versionInfo &&\n        typeof versionInfo.unpackedLocation === 'string' &&\n        versionInfo.unpackedLocation\n      ) {\n        const resolvedPathFromVersion = resolve(join(versionInfo.unpackedLocation, codeqlExeName));\n        if (existsSync(resolvedPathFromVersion)) {\n          cdsExtractorLog(\n            'info',\n            `CodeQL executable found via 'codeql version --format=json' at: ${resolvedPathFromVersion}`,\n          );\n          return resolvedPathFromVersion;\n        }\n        cdsExtractorLog(\n          'warn',\n          `'codeql version --format=json' provided unpackedLocation '${versionInfo.unpackedLocation}', but executable not found at '${resolvedPathFromVersion}'.`,\n        );\n      } else {\n        cdsExtractorLog(\n          'warn',\n          \"Could not determine CodeQL executable path from 'codeql version --format=json' output. 'unpackedLocation' field missing, empty, or invalid.\",\n        );\n      }\n    } catch (parseError) {\n      cdsExtractorLog(\n        'warn',\n        `Failed to parse 'codeql version --format=json' output: ${String(parseError)}. Output was: ${versionOutput}`,\n      );\n    }\n  } catch (error) {\n    let errorMessage = `INFO: Failed to find CodeQL executable via 'codeql version --format=json'. Error: ${String(error)}`;\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {\n      errorMessage += `\\nINFO: The command '${codeqlExeName}' was not found in your system PATH.`;\n    }\n    cdsExtractorLog('info', errorMessage);\n  }\n\n  cdsExtractorLog(\n    'error',\n    'Failed to determine CodeQL executable path. Please ensure the CODEQL_DIST environment variable is set and points to a valid CodeQL distribution, or that the CodeQL CLI (codeql) is available in your system PATH and \"codeql version --format=json\" can provide its location.',\n  );\n  return ''; // Return empty string if all attempts fail\n}\n\n/**\n * Get the JavaScript extractor root path.\n * @param codeqlExePath The path to the CodeQL executable. If empty, resolution will be skipped.\n * @returns The JavaScript extractor root path, or an empty string if not found or if codeqlExePath is empty.\n */\nexport function getJavaScriptExtractorRoot(codeqlExePath: string): string {\n  let jsExtractorRoot = process.env.CODEQL_EXTRACTOR_JAVASCRIPT_ROOT ?? '';\n\n  if (jsExtractorRoot) {\n    cdsExtractorLog(\n      'info',\n      `Using JavaScript extractor root from environment variable CODEQL_EXTRACTOR_JAVASCRIPT_ROOT: ${jsExtractorRoot}`,\n    );\n    return jsExtractorRoot;\n  }\n\n  if (!codeqlExePath) {\n    cdsExtractorLog(\n      'warn',\n      'Cannot resolve JavaScript extractor root because the CodeQL executable path was not provided or found.',\n    );\n    return '';\n  }\n\n  try {\n    jsExtractorRoot = execFileSync(\n      codeqlExePath,\n      ['resolve', 'extractor', '--language=javascript'],\n      { stdio: 'pipe' }, // Suppress output from the command itself\n    )\n      .toString()\n      .trim();\n    if (jsExtractorRoot) {\n      cdsExtractorLog('info', `JavaScript extractor root resolved to: ${jsExtractorRoot}`);\n    } else {\n      cdsExtractorLog(\n        'warn',\n        `'codeql resolve extractor --language=javascript' using '${codeqlExePath}' returned an empty path.`,\n      );\n    }\n  } catch (error) {\n    cdsExtractorLog(\n      'error',\n      `Error resolving JavaScript extractor root using '${codeqlExePath}': ${String(error)}`,\n    );\n    jsExtractorRoot = ''; // Ensure it's empty on error\n  }\n  return jsExtractorRoot;\n}\n\n/**\n * Set JavaScript extractor environment variables using CDS extractor variables\n */\nexport function setupJavaScriptExtractorEnv(): void {\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_WIP_DATABASE =\n    process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_DIAGNOSTIC_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_DIAGNOSTIC_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_LOG_DIR = process.env.CODEQL_EXTRACTOR_CDS_LOG_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_SCRATCH_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_SCRATCH_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_TRAP_DIR = process.env.CODEQL_EXTRACTOR_CDS_TRAP_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_SOURCE_ARCHIVE_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_SOURCE_ARCHIVE_DIR;\n}\n\n/**\n * Get the path to the autobuild script\n * @param jsExtractorRoot The JavaScript extractor root path\n * @returns The path to the autobuild script, or an empty string if jsExtractorRoot is empty.\n */\nexport function getAutobuildScriptPath(jsExtractorRoot: string): string {\n  if (!jsExtractorRoot) return '';\n  const platformInfo = getPlatformInfo();\n  const autobuildScriptName: string = platformInfo.isWindows ? 'autobuild.cmd' : 'autobuild.sh';\n  return resolve(join(jsExtractorRoot, 'tools', autobuildScriptName));\n}\n\n/**\n * Configure LGTM index filters for CDS files\n */\nexport function configureLgtmIndexFilters(): void {\n  let excludeFilters = '';\n\n  if (process.env.LGTM_INDEX_FILTERS) {\n    cdsExtractorLog(\n      'info',\n      `Found $LGTM_INDEX_FILTERS already set to:\n${process.env.LGTM_INDEX_FILTERS}`,\n    );\n    const allowedExcludePatterns = [join('exclude:**', '*'), join('exclude:**', '*.*')];\n\n    excludeFilters =\n      '\\n' +\n      process.env.LGTM_INDEX_FILTERS.split('\\n')\n        .filter(\n          line =>\n            line.startsWith('exclude') &&\n            !allowedExcludePatterns.some(pattern => line.includes(pattern)),\n        )\n        .join('\\n');\n  }\n\n  // Enable extraction of the .cds.json files only.\n  const lgtmIndexFiltersPatterns = [\n    join('exclude:**', '*.*'),\n    join('include:**', '*.cds.json'),\n    join('include:**', '*.cds'),\n    join('exclude:**', 'node_modules', '**', '*.*'),\n  ].join('\\n');\n\n  process.env.LGTM_INDEX_FILTERS = lgtmIndexFiltersPatterns + excludeFilters;\n  process.env.LGTM_INDEX_TYPESCRIPT = 'NONE';\n  // Configure to copy over the .cds files as well, by pretending they are JSON.\n  process.env.LGTM_INDEX_FILETYPES = '.cds:JSON';\n}\n\n/**\n * Sets up the environment and validates key components for running the CDS extractor.\n * This includes checking for the CodeQL executable, validating the source root directory,\n * and setting up environment variables for the JavaScript extractor.\n *\n * @param sourceRoot The source root directory.\n *\n * @returns The {@link EnvironmentSetupResult} containing success status, error messages,\n *          CodeQL executable path, JavaScript extractor root, autobuild script path,\n *          and platform information.\n *\n * @throws Will throw an error if the environment setup fails.\n */\nexport function setupAndValidateEnvironment(sourceRoot: string): EnvironmentSetupResult {\n  const errorMessages: string[] = [];\n  const platformInfo = getPlatformInfo();\n\n  // Get the CodeQL executable path\n  const codeqlExePath = getCodeQLExePath();\n  if (!codeqlExePath) {\n    errorMessages.push(\n      'Failed to find CodeQL executable. Ensure CODEQL_DIST is set and valid, or CodeQL CLI is in PATH.',\n    );\n  }\n\n  // Validate that the required source root directory exists\n  if (!dirExists(sourceRoot)) {\n    errorMessages.push(`Project root directory '${sourceRoot}' does not exist.`);\n  }\n\n  // Get JavaScript extractor root\n  const jsExtractorRoot = getJavaScriptExtractorRoot(codeqlExePath);\n  if (!jsExtractorRoot) {\n    if (codeqlExePath) {\n      // Only add this error if codeqlExePath was found but JS extractor root wasn't\n      errorMessages.push(\n        'Failed to determine JavaScript extractor root using the found CodeQL executable.',\n      );\n    } else {\n      // If codeqlExePath is empty, the error from getCodeQLExePath is usually sufficient.\n      // However, we can add a more specific one if needed.\n      errorMessages.push(\n        'Cannot determine JavaScript extractor root because CodeQL executable was not found.',\n      );\n    }\n  }\n\n  // Set environment variables for JavaScript extractor only if jsExtractorRoot is valid\n  if (jsExtractorRoot) {\n    process.env.CODEQL_EXTRACTOR_JAVASCRIPT_ROOT = jsExtractorRoot;\n    setupJavaScriptExtractorEnv();\n  }\n\n  // Get autobuild script path\n  const autobuildScriptPath = jsExtractorRoot ? getAutobuildScriptPath(jsExtractorRoot) : '';\n  // Not having an autobuild script path might be an error depending on the run mode,\n  // but for now, the function just returns what it found.\n\n  return {\n    success: errorMessages.length === 0,\n    errorMessages,\n    codeqlExePath, // Will be '' if not found\n    jsExtractorRoot, // Will be '' if not found\n    autobuildScriptPath,\n    platformInfo,\n  };\n}\n", "import { execFileSync } from 'child_process';\nimport { createHash } from 'crypto';\nimport { existsSync, mkdirSync, writeFileSync } from 'fs';\nimport { join, resolve } from 'path';\n\nimport type { CdsDependencyCombination } from './types';\nimport { CdsDependencyGraph, CdsProject } from '../cds/parser/types';\nimport { DiagnosticSeverity } from '../diagnostics';\nimport { cdsExtractorLog } from '../logging';\nimport { resolveCdsVersions } from './versionResolver';\n\nconst cacheSubDirName = '.cds-extractor-cache';\n\n/**\n * Add a warning diagnostic for dependency version fallback\n * @param packageJsonPath Path to the package.json file\n * @param warningMessage The warning message\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nfunction addDependencyVersionWarning(\n  packageJsonPath: string,\n  warningMessage: string,\n  codeqlExePath: string,\n): boolean {\n  try {\n    execFileSync(codeqlExePath, [\n      'database',\n      'add-diagnostic',\n      '--extractor-name=cds',\n      '--ready-for-status-page',\n      '--source-id=cds/dependency-version-fallback',\n      '--source-name=Using fallback versions for SAP CAP CDS dependencies',\n      `--severity=${DiagnosticSeverity.Warning}`,\n      `--markdown-message=${warningMessage}`,\n      `--file-path=${resolve(packageJsonPath)}`,\n      '--',\n      `${process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE ?? ''}`,\n    ]);\n    cdsExtractorLog('info', `Added warning diagnostic for dependency fallback: ${packageJsonPath}`);\n    return true;\n  } catch (err) {\n    cdsExtractorLog(\n      'error',\n      `Failed to add warning diagnostic for ${packageJsonPath}: ${String(err)}`,\n    );\n    return false;\n  }\n}\n\n/**\n * Extracts unique dependency combinations from the dependency graph.\n * @param projects A map of projects from the dependency graph.\n * @returns An array of unique dependency combinations.\n */\nfunction extractUniqueDependencyCombinations(\n  projects: Map<string, CdsProject>,\n): CdsDependencyCombination[] {\n  const combinations = new Map<string, CdsDependencyCombination>();\n\n  for (const project of Array.from(projects.values())) {\n    if (!project.packageJson) {\n      continue;\n    }\n\n    const cdsVersion = project.packageJson.dependencies?.['@sap/cds'] ?? 'latest';\n    const cdsDkVersion = project.packageJson.devDependencies?.['@sap/cds-dk'] ?? cdsVersion;\n\n    // Resolve versions first to ensure we cache based on actual resolved versions\n    cdsExtractorLog(\n      'info',\n      `Resolving available dependency versions for project '${project.projectDir}' with dependencies: [@sap/cds@${cdsVersion}, @sap/cds-dk@${cdsDkVersion}]`,\n    );\n    const resolvedVersions = resolveCdsVersions(cdsVersion, cdsDkVersion);\n    const { resolvedCdsVersion, resolvedCdsDkVersion, ...rest } = resolvedVersions;\n\n    // Log the resolved CDS dependency versions for the project\n    if (resolvedCdsVersion && resolvedCdsDkVersion) {\n      let statusMsg: string;\n      if (resolvedVersions.cdsExactMatch && resolvedVersions.cdsDkExactMatch) {\n        statusMsg = ' (exact match)';\n      } else if (!resolvedVersions.isFallback) {\n        statusMsg = ' (compatible versions)';\n      } else {\n        statusMsg = ' (using fallback versions)';\n      }\n      cdsExtractorLog(\n        'info',\n        `Resolved to: @sap/cds@${resolvedCdsVersion}, @sap/cds-dk@${resolvedCdsDkVersion}${statusMsg}`,\n      );\n    } else {\n      cdsExtractorLog(\n        'error',\n        `Failed to resolve CDS dependencies: @sap/cds@${cdsVersion}, @sap/cds-dk@${cdsDkVersion}`,\n      );\n    }\n\n    // Calculate hash based on resolved versions to ensure proper cache reuse\n    const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n    const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n    const hash = createHash('sha256')\n      .update(`${actualCdsVersion}|${actualCdsDkVersion}`)\n      .digest('hex');\n\n    if (!combinations.has(hash)) {\n      combinations.set(hash, {\n        cdsVersion,\n        cdsDkVersion,\n        hash,\n        resolvedCdsVersion: resolvedCdsVersion ?? undefined,\n        resolvedCdsDkVersion: resolvedCdsDkVersion ?? undefined,\n        ...rest,\n      });\n    }\n  }\n\n  return Array.from(combinations.values());\n}\n\n/**\n * Install dependencies for CDS projects using a robust cache strategy with fallback logic\n * @param dependencyGraph The dependency graph of the project\n * @param sourceRoot Source root directory\n * @param codeqlExePath Path to the CodeQL executable (optional)\n * @returns Map of project directories to their corresponding cache directories\n */\nexport function installDependencies(\n  dependencyGraph: CdsDependencyGraph,\n  sourceRoot: string,\n  codeqlExePath?: string,\n): Map<string, string> {\n  // Sanity check that we found at least one project\n  if (dependencyGraph.projects.size === 0) {\n    cdsExtractorLog('info', 'No CDS projects found for dependency installation.');\n    cdsExtractorLog(\n      'info',\n      'This is expected if the source contains no CAP/CDS projects and should be handled by the caller.',\n    );\n    return new Map<string, string>();\n  }\n\n  // Extract unique dependency combinations from all projects with version resolution\n  const dependencyCombinations = extractUniqueDependencyCombinations(dependencyGraph.projects);\n\n  if (dependencyCombinations.length === 0) {\n    cdsExtractorLog(\n      'error',\n      'No CDS dependencies found in any project. This means projects were detected but lack proper @sap/cds dependencies.',\n    );\n    cdsExtractorLog(\n      'info',\n      'Will attempt to use system-installed CDS tools if available, but compilation may fail.',\n    );\n    return new Map<string, string>();\n  }\n\n  cdsExtractorLog(\n    'info',\n    `Found ${dependencyCombinations.length} unique CDS dependency combination(s).`,\n  );\n\n  // Log each dependency combination for transparency\n  for (const combination of dependencyCombinations) {\n    const { cdsVersion, cdsDkVersion, hash, resolvedCdsVersion, resolvedCdsDkVersion, isFallback } =\n      combination;\n    const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n    const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n    const fallbackNote = isFallback ? ' (using fallback versions)' : '';\n\n    cdsExtractorLog(\n      'info',\n      `Dependency combination ${hash.substring(0, 8)}: @sap/cds@${actualCdsVersion}, @sap/cds-dk@${actualCdsDkVersion}${fallbackNote}`,\n    );\n  }\n\n  // Create a cache directory under the source root directory.\n  const cacheRootDir = join(sourceRoot, cacheSubDirName);\n  cdsExtractorLog(\n    'info',\n    `Using cache directory '${cacheSubDirName}' within source root directory '${cacheRootDir}'`,\n  );\n\n  if (!existsSync(cacheRootDir)) {\n    try {\n      mkdirSync(cacheRootDir, { recursive: true });\n      cdsExtractorLog('info', `Created cache directory: ${cacheRootDir}`);\n    } catch (err) {\n      cdsExtractorLog(\n        'warn',\n        `Failed to create cache directory: ${err instanceof Error ? err.message : String(err)}`,\n      );\n      cdsExtractorLog('info', 'Skipping dependency installation due to cache directory failure.');\n      return new Map<string, string>();\n    }\n  } else {\n    cdsExtractorLog('info', `Cache directory already exists: ${cacheRootDir}`);\n  }\n\n  // Map to track which cache directory to use for each project\n  const projectCacheDirMap = new Map<string, string>();\n  let successfulInstallations = 0;\n\n  // Install each unique dependency combination in its own cache directory\n  for (const combination of dependencyCombinations) {\n    const { cdsVersion, cdsDkVersion, hash } = combination;\n    const { resolvedCdsVersion, resolvedCdsDkVersion } = combination;\n    const cacheDirName = `cds-${hash}`;\n    const cacheDir = join(cacheRootDir, cacheDirName);\n\n    cdsExtractorLog(\n      'info',\n      `Processing dependency combination ${hash.substring(0, 8)} in cache directory: ${cacheDirName}`,\n    );\n\n    // Create the cache directory if it doesn't exist\n    if (!existsSync(cacheDir)) {\n      try {\n        mkdirSync(cacheDir, { recursive: true });\n        cdsExtractorLog('info', `Created cache subdirectory: ${cacheDirName}`);\n      } catch (err) {\n        cdsExtractorLog(\n          'error',\n          `Failed to create cache directory for combination ${hash.substring(0, 8)} (${cacheDirName}): ${\n            err instanceof Error ? err.message : String(err)\n          }`,\n        );\n        continue;\n      }\n\n      // Create a package.json for this dependency combination using resolved versions\n      const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n      const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n\n      const packageJson = {\n        name: `cds-extractor-cache-${hash}`,\n        version: '1.0.0',\n        private: true,\n        dependencies: {\n          '@sap/cds': actualCdsVersion,\n          '@sap/cds-dk': actualCdsDkVersion,\n        },\n      };\n\n      try {\n        writeFileSync(join(cacheDir, 'package.json'), JSON.stringify(packageJson, null, 2));\n        cdsExtractorLog('info', `Created package.json in cache subdirectory: ${cacheDirName}`);\n      } catch (err) {\n        cdsExtractorLog(\n          'error',\n          `Failed to create package.json in cache directory ${cacheDirName}: ${\n            err instanceof Error ? err.message : String(err)\n          }`,\n        );\n        continue;\n      }\n    }\n\n    // Try to install dependencies in the cache directory\n    // Get the first project package.json path for diagnostic purposes\n    const samplePackageJsonPath = Array.from(dependencyGraph.projects.values()).find(\n      project => project.packageJson,\n    )?.projectDir;\n    const packageJsonPath = samplePackageJsonPath\n      ? join(sourceRoot, samplePackageJsonPath, 'package.json')\n      : undefined;\n\n    const installSuccess = installDependenciesInCache(\n      cacheDir,\n      combination,\n      cacheDirName,\n      packageJsonPath,\n      codeqlExePath,\n    );\n\n    if (!installSuccess) {\n      cdsExtractorLog(\n        'warn',\n        `Skipping failed dependency combination ${hash.substring(0, 8)} (cache directory: ${cacheDirName})`,\n      );\n      continue;\n    }\n\n    successfulInstallations++;\n\n    // Associate projects with this dependency combination\n    for (const [projectDir, project] of Array.from(dependencyGraph.projects.entries())) {\n      if (!project.packageJson) {\n        continue;\n      }\n      const p_cdsVersion = project.packageJson.dependencies?.['@sap/cds'] ?? 'latest';\n      const p_cdsDkVersion = project.packageJson.devDependencies?.['@sap/cds-dk'] ?? p_cdsVersion;\n\n      // Resolve the project's versions to match against the combination's resolved versions\n      const projectResolvedVersions = resolveCdsVersions(p_cdsVersion, p_cdsDkVersion);\n      const projectActualCdsVersion = projectResolvedVersions.resolvedCdsVersion ?? p_cdsVersion;\n      const projectActualCdsDkVersion =\n        projectResolvedVersions.resolvedCdsDkVersion ?? p_cdsDkVersion;\n\n      // Match based on resolved versions since that's what the hash is based on\n      const combinationActualCdsVersion = combination.resolvedCdsVersion ?? combination.cdsVersion;\n      const combinationActualCdsDkVersion =\n        combination.resolvedCdsDkVersion ?? combination.cdsDkVersion;\n\n      if (\n        projectActualCdsVersion === combinationActualCdsVersion &&\n        projectActualCdsDkVersion === combinationActualCdsDkVersion\n      ) {\n        projectCacheDirMap.set(projectDir, cacheDir);\n      }\n    }\n  }\n\n  // Log final status\n  if (successfulInstallations === 0) {\n    cdsExtractorLog('error', 'Failed to install any dependency combinations.');\n    if (dependencyCombinations.length > 0) {\n      cdsExtractorLog(\n        'error',\n        `All ${dependencyCombinations.length} dependency combination(s) failed to install. This will likely cause compilation failures.`,\n      );\n    }\n  } else if (successfulInstallations < dependencyCombinations.length) {\n    cdsExtractorLog(\n      'warn',\n      `Successfully installed ${successfulInstallations} out of ${dependencyCombinations.length} dependency combinations.`,\n    );\n  } else {\n    cdsExtractorLog('info', 'All dependency combinations installed successfully.');\n  }\n\n  // Log project-to-cache-directory mappings for transparency.\n  if (projectCacheDirMap.size > 0) {\n    cdsExtractorLog('info', `Project to cache directory mappings:`);\n    for (const [projectDir, cacheDir] of Array.from(projectCacheDirMap.entries())) {\n      const cacheDirName = join(cacheDir).split('/').pop() ?? 'unknown';\n      cdsExtractorLog('info', `  ${projectDir} \u2192 ${cacheDirName}`);\n    }\n  } else {\n    cdsExtractorLog(\n      'warn',\n      'No project to cache directory mappings created. Projects may not have compatible dependencies installed.',\n    );\n  }\n\n  return projectCacheDirMap;\n}\n\n/**\n * Attempt to install dependencies in a cache directory with fallback logic\n * @param cacheDir Cache directory path\n * @param combination Dependency combination to install\n * @param cacheDirName Name of the cache directory for logging\n * @param packageJsonPath Optional package.json path for diagnostics\n * @param codeqlExePath Optional CodeQL executable path for diagnostics\n * @returns True if installation succeeded, false otherwise\n */\nfunction installDependenciesInCache(\n  cacheDir: string,\n  combination: CdsDependencyCombination,\n  cacheDirName: string,\n  packageJsonPath?: string,\n  codeqlExePath?: string,\n): boolean {\n  const { resolvedCdsVersion, resolvedCdsDkVersion, isFallback, warning } = combination;\n\n  // Check if node_modules directory already exists in the cache dir\n  const nodeModulesExists =\n    existsSync(join(cacheDir, 'node_modules', '@sap', 'cds')) &&\n    existsSync(join(cacheDir, 'node_modules', '@sap', 'cds-dk'));\n\n  if (nodeModulesExists) {\n    cdsExtractorLog(\n      'info',\n      `Using cached dependencies for @sap/cds@${resolvedCdsVersion} and @sap/cds-dk@${resolvedCdsDkVersion} from ${cacheDirName}`,\n    );\n\n    // Add warning diagnostic if using fallback versions\n    if (isFallback && warning && packageJsonPath && codeqlExePath) {\n      addDependencyVersionWarning(packageJsonPath, warning, codeqlExePath);\n    }\n\n    return true;\n  }\n\n  if (!resolvedCdsVersion || !resolvedCdsDkVersion) {\n    cdsExtractorLog('error', 'Cannot install dependencies: no compatible versions found');\n    return false;\n  }\n\n  // Install dependencies in the cache directory\n  cdsExtractorLog(\n    'info',\n    `Installing @sap/cds@${resolvedCdsVersion} and @sap/cds-dk@${resolvedCdsDkVersion} in cache directory: ${cacheDirName}`,\n  );\n\n  if (isFallback && warning) {\n    cdsExtractorLog('warn', warning);\n  }\n\n  try {\n    execFileSync('npm', ['install', '--quiet', '--no-audit', '--no-fund'], {\n      cwd: cacheDir,\n      stdio: 'inherit',\n    });\n\n    // Add warning diagnostic if using fallback versions\n    if (isFallback && warning && packageJsonPath && codeqlExePath) {\n      addDependencyVersionWarning(packageJsonPath, warning, codeqlExePath);\n    }\n\n    return true;\n  } catch (err) {\n    const errorMessage = `Failed to install resolved dependencies in cache directory ${cacheDir}: ${err instanceof Error ? err.message : String(err)}`;\n    cdsExtractorLog('error', errorMessage);\n    return false;\n  }\n}\n", "import { execSync } from 'child_process';\n\nimport type { SemanticVersion } from './types';\nimport { cdsExtractorLog } from '../logging';\n\n/**\n * Cache for storing available versions for npm packages to avoid duplicate\n * `npm view` calls.\n */\nconst availableVersionsCache = new Map<string, string[]>();\n\n// Define the set of allowed npm packages for which we cache versions.\ntype CachedPackageName = '@sap/cds' | '@sap/cds-dk';\n\n/**\n * Cache statistics for debugging purposes\n */\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  get hitRate() {\n    const total = this.hits + this.misses;\n    return total > 0 ? ((this.hits / total) * 100).toFixed(1) : '0.0';\n  },\n};\n\n/**\n * Check if @sap/cds and @sap/cds-dk versions are likely compatible.\n * @param cdsVersion The @sap/cds version\n * @param cdsDkVersion The @sap/cds-dk version\n * @returns Object with compatibility information and warnings\n */\nexport function checkVersionCompatibility(\n  cdsVersion: string,\n  cdsDkVersion: string,\n): {\n  isCompatible: boolean;\n  warning?: string;\n} {\n  // If either version is 'latest', assume they are compatible\n  if (cdsVersion === 'latest' || cdsDkVersion === 'latest') {\n    return { isCompatible: true };\n  }\n\n  const parsedCds = parseSemanticVersion(cdsVersion);\n  const parsedCdsDk = parseSemanticVersion(cdsDkVersion);\n\n  if (!parsedCds || !parsedCdsDk) {\n    return {\n      isCompatible: false,\n      warning: 'Unable to parse version numbers for compatibility check',\n    };\n  }\n\n  // Generally, @sap/cds and @sap/cds-dk should have the same major version\n  // and ideally the same minor version for best compatibility\n  const majorVersionsMatch = parsedCds.major === parsedCdsDk.major;\n  const minorVersionsMatch = parsedCds.minor === parsedCdsDk.minor;\n\n  if (!majorVersionsMatch) {\n    return {\n      isCompatible: false,\n      warning: `Major version mismatch: @sap/cds ${cdsVersion} and @sap/cds-dk ${cdsDkVersion} may not be compatible`,\n    };\n  }\n\n  if (!minorVersionsMatch) {\n    return {\n      isCompatible: true,\n      warning: `Minor version difference: @sap/cds ${cdsVersion} and @sap/cds-dk ${cdsDkVersion} - consider aligning versions for best compatibility`,\n    };\n  }\n\n  return { isCompatible: true };\n}\n\n/**\n * Compare two semantic versions\n * @param a First version\n * @param b Second version\n * @returns Negative if a < b, 0 if equal, positive if a > b\n */\nexport function compareVersions(a: SemanticVersion, b: SemanticVersion): number {\n  if (a.major !== b.major) return a.major - b.major;\n  if (a.minor !== b.minor) return a.minor - b.minor;\n  if (a.patch !== b.patch) return a.patch - b.patch;\n\n  // Handle prerelease versions (prerelease < release)\n  if (a.prerelease && !b.prerelease) return -1;\n  if (!a.prerelease && b.prerelease) return 1;\n  if (a.prerelease && b.prerelease) {\n    return a.prerelease.localeCompare(b.prerelease);\n  }\n\n  return 0;\n}\n\n/**\n * Find the best available version from a list of versions for a given requirement\n * @param availableVersions List of available version strings\n * @param requiredVersion Required version string\n * @returns Best matching version or null if no compatible version found\n */\nexport function findBestAvailableVersion(\n  availableVersions: string[],\n  requiredVersion: string,\n): string | null {\n  const parsedVersions = availableVersions\n    .map(v => parseSemanticVersion(v))\n    .filter((v): v is SemanticVersion => v !== null);\n\n  if (parsedVersions.length === 0) {\n    return null;\n  }\n\n  // First, try to find versions that satisfy the range\n  const satisfyingVersions = parsedVersions.filter(v => satisfiesRange(v, requiredVersion));\n\n  if (satisfyingVersions.length > 0) {\n    // Sort in descending order (newest first) and return the best match\n    satisfyingVersions.sort((a, b) => compareVersions(b, a));\n    return satisfyingVersions[0].original;\n  }\n\n  // If no exact match, prefer newer versions over older ones\n  // Sort all versions in descending order and return the newest\n  parsedVersions.sort((a, b) => compareVersions(b, a));\n  return parsedVersions[0].original;\n}\n\n/**\n * Get available versions for an npm package with caching to avoid duplicate\n * calls of the `npm view` command.\n * @param packageName The {@link CachedPackageName} for which to get versions\n * @returns Array of available version strings\n */\nexport function getAvailableVersions(packageName: CachedPackageName): string[] {\n  // Check cache first\n  if (availableVersionsCache.has(packageName)) {\n    cacheStats.hits++;\n    return availableVersionsCache.get(packageName)!;\n  }\n\n  // Cache miss - fetch from npm\n  cacheStats.misses++;\n  try {\n    const output = execSync(`npm view ${packageName} versions --json`, {\n      encoding: 'utf8',\n      timeout: 30000, // 30 second timeout\n    });\n\n    const versions: unknown = JSON.parse(output);\n    let versionArray: string[] = [];\n\n    if (Array.isArray(versions)) {\n      versionArray = versions.filter((v): v is string => typeof v === 'string');\n    } else if (typeof versions === 'string') {\n      versionArray = [versions];\n    }\n\n    // Cache the result\n    availableVersionsCache.set(packageName, versionArray);\n\n    return versionArray;\n  } catch (error) {\n    cdsExtractorLog('warn', `Failed to fetch versions for ${packageName}: ${String(error)}`);\n    // Cache empty array to avoid repeated failures\n    availableVersionsCache.set(packageName, []);\n    return [];\n  }\n}\n\n/**\n * Get cache statistics for debugging purposes\n * @returns Object with cache hit/miss statistics\n */\nexport function getCacheStatistics(): {\n  hits: number;\n  misses: number;\n  hitRate: string;\n  cachedPackages: string[];\n} {\n  return {\n    hits: cacheStats.hits,\n    misses: cacheStats.misses,\n    hitRate: cacheStats.hitRate,\n    cachedPackages: Array.from(availableVersionsCache.keys()),\n  };\n}\n\n/**\n * Parse a semantic version string\n * @param version Version string to parse (e.g., \"6.1.3\", \"^6.0.0\", \"~6.1.0\", \"latest\")\n * @returns Parsed semantic version or null if invalid\n */\nexport function parseSemanticVersion(version: string): SemanticVersion | null {\n  if (version === 'latest') {\n    // Return a very high version number for 'latest' to ensure it's preferred\n    return {\n      major: 999,\n      minor: 999,\n      patch: 999,\n      original: version,\n    };\n  }\n\n  // Remove common version prefixes\n  const cleanVersion = version.replace(/^[\\^~>=<]+/, '');\n\n  // Basic semver regex\n  const semverRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9.-]+))?(?:\\+([a-zA-Z0-9.-]+))?$/;\n  const match = cleanVersion.match(semverRegex);\n\n  if (!match) {\n    return null;\n  }\n\n  return {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n    patch: parseInt(match[3], 10),\n    prerelease: match[4],\n    build: match[5],\n    original: version,\n  };\n}\n\n/**\n * Check if a resolved version satisfies the originally requested version.\n * @param resolvedVersion The version that was resolved\n * @param requestedVersion The originally requested version\n * @returns true if the resolved version satisfies the requested version range\n */\nfunction isSatisfyingVersion(resolvedVersion: string, requestedVersion: string): boolean {\n  // Exact string match or 'latest' case\n  if (resolvedVersion === requestedVersion || requestedVersion === 'latest') {\n    return true;\n  }\n\n  const parsedResolved = parseSemanticVersion(resolvedVersion);\n  if (!parsedResolved) {\n    return false;\n  }\n\n  return satisfiesRange(parsedResolved, requestedVersion);\n}\n\n/**\n * Resolve the best available version for CDS dependencies\n * @param cdsVersion Required @sap/cds version\n * @param cdsDkVersion Required @sap/cds-dk version\n * @returns Object with resolved versions and compatibility info\n */\nexport function resolveCdsVersions(\n  cdsVersion: string,\n  cdsDkVersion: string,\n): {\n  resolvedCdsVersion: string | null;\n  resolvedCdsDkVersion: string | null;\n  cdsExactMatch: boolean;\n  cdsDkExactMatch: boolean;\n  warning?: string;\n  isFallback?: boolean;\n} {\n  const cdsVersions = getAvailableVersions('@sap/cds');\n  const cdsDkVersions = getAvailableVersions('@sap/cds-dk');\n\n  const resolvedCdsVersion = findBestAvailableVersion(cdsVersions, cdsVersion);\n  const resolvedCdsDkVersion = findBestAvailableVersion(cdsDkVersions, cdsDkVersion);\n\n  // Check if resolved versions are exact matches (string equality or 'latest' case).\n  const cdsExactMatch =\n    resolvedCdsVersion === cdsVersion || (cdsVersion === 'latest' && resolvedCdsVersion !== null);\n  const cdsDkExactMatch =\n    resolvedCdsDkVersion === cdsDkVersion ||\n    (cdsDkVersion === 'latest' && resolvedCdsDkVersion !== null);\n\n  // Check if resolved versions satisfy the requested ranges (including exact matches).\n  const cdsSatisfiesRange = resolvedCdsVersion\n    ? isSatisfyingVersion(resolvedCdsVersion, cdsVersion)\n    : false;\n  const cdsDkSatisfiesRange = resolvedCdsDkVersion\n    ? isSatisfyingVersion(resolvedCdsDkVersion, cdsDkVersion)\n    : false;\n\n  // Only consider it a fallback if we couldn't find a satisfying version.\n  const isFallback = !cdsSatisfiesRange || !cdsDkSatisfiesRange;\n\n  let warning: string | undefined;\n\n  // Check compatibility between resolved versions (only if both were resolved).\n  // Show warnings when:\n  // 1. We're using fallback versions (couldn't find compatible versions), OR\n  // 2. At least one version isn't an exact match (version range was used), OR\n  // 3. Resolved versions have actual compatibility issues (e.g., major version mismatch).\n  if (resolvedCdsVersion && resolvedCdsDkVersion) {\n    const compatibility = checkVersionCompatibility(resolvedCdsVersion, resolvedCdsDkVersion);\n\n    const shouldShowWarning =\n      isFallback ||\n      !cdsExactMatch ||\n      !cdsDkExactMatch ||\n      (compatibility.warning && !compatibility.isCompatible);\n\n    if (compatibility.warning && shouldShowWarning) {\n      warning = compatibility.warning;\n    }\n  }\n\n  return {\n    resolvedCdsVersion,\n    resolvedCdsDkVersion,\n    cdsExactMatch,\n    cdsDkExactMatch,\n    warning,\n    isFallback,\n  };\n}\n\n/**\n * Check if version satisfies a version range.\n * @param version Version to check\n * @param range Version range (e.g., \"^6.0.0\", \"~6.1.0\", \">=6.0.0\")\n * @returns true if version satisfies the range\n */\nexport function satisfiesRange(version: SemanticVersion, range: string): boolean {\n  if (range === 'latest') {\n    return true;\n  }\n\n  const rangeVersion = parseSemanticVersion(range);\n  if (!rangeVersion) {\n    return false;\n  }\n\n  if (range.startsWith('^')) {\n    // Caret range: compatible within same major version\n    return version.major === rangeVersion.major && compareVersions(version, rangeVersion) >= 0;\n  } else if (range.startsWith('~')) {\n    // Tilde range: compatible within same minor version\n    return (\n      version.major === rangeVersion.major &&\n      version.minor === rangeVersion.minor &&\n      compareVersions(version, rangeVersion) >= 0\n    );\n  } else if (range.startsWith('>=')) {\n    // Greater than or equal\n    return compareVersions(version, rangeVersion) >= 0;\n  } else if (range.startsWith('>')) {\n    // Greater than\n    return compareVersions(version, rangeVersion) > 0;\n  } else if (range.startsWith('<=')) {\n    // Less than or equal\n    return compareVersions(version, rangeVersion) <= 0;\n  } else if (range.startsWith('<')) {\n    // Less than\n    return compareVersions(version, rangeVersion) < 0;\n  } else {\n    // Exact match\n    return compareVersions(version, rangeVersion) === 0;\n  }\n}\n\n/**\n * Test-only exports - DO NOT USE IN PRODUCTION CODE\n * These are exported only for testing purposes\n */\nexport const __testOnly__ = {\n  availableVersionsCache,\n  cacheStats,\n};\n", "import { resolve } from 'path';\n\nconst USAGE_MESSAGE = `\\tUsage: node <script> <source-root>`;\n\n/**\n * Resolves and validates a source root directory path.\n *\n * This function takes a source root path, validates it, normalizes it,\n * and returns an absolute path to the directory.\n *\n * @param sourceRoot - The source root path to resolve\n * @returns The normalized absolute path to the source root directory\n * @throws {Error} If the source root is null, undefined, an empty string,\n *                 or does not point to a valid directory\n */\nfunction resolveSourceRoot(sourceRoot: string): string {\n  // Check for null, undefined, or empty string\n  if (!sourceRoot || typeof sourceRoot !== 'string') {\n    throw new Error('Source root must be a non-empty string');\n  }\n\n  // Normalize the path and resolve it to an absolute path.\n  const normalizedPath = resolve(sourceRoot);\n\n  // Check if the resolved path points to a valid, existing directory.\n  if (!normalizedPath || normalizedPath === '/') {\n    throw new Error('Source root must point to a valid directory');\n  }\n\n  return normalizedPath;\n}\n\n/**\n * Check if the script was invoked with the required arguments.\n * This function validates and sanitizes script arguments and returns them if valid.\n *\n * Requirements:\n * - Only requires: <source-root>\n *\n * @param args Command line arguments to check.\n * @returns Object with validation result, usage message if failed, and validated\n * arguments if successful.\n */\nexport function validateArguments(args: string[]): {\n  isValid: boolean;\n  usageMessage?: string;\n  args?: {\n    sourceRoot: string;\n  };\n} {\n  // Minimum arguments: node, script, source-root (3 total)\n  if (args.length < 3) {\n    return {\n      isValid: false,\n      usageMessage: USAGE_MESSAGE,\n    };\n  }\n\n  // Get the source root from args (now the first parameter after script name)\n  const rawSourceRoot: string = args[2];\n\n  // Validate and sanitize the source root path\n  let sourceRoot: string;\n  try {\n    sourceRoot = resolveSourceRoot(rawSourceRoot);\n  } catch (error) {\n    return {\n      isValid: false,\n      usageMessage: `Invalid source root: ${String(error)}`,\n    };\n  }\n\n  // Return the validated arguments\n  return {\n    isValid: true,\n    usageMessage: `<source-root>`,\n    args: {\n      sourceRoot,\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["import_path", "glob", "i", "acc", "ext", "glob", "hasMagic", "start", "final", "ext", "qmark", "star", "regExpEscape", "import_node_url", "v", "bf", "Stream", "p", "ret", "resolve", "res", "rps", "readdirCB", "path", "p", "resolve", "sep", "filter", "process", "sync", "platform", "defaultPlatform", "platform", "relative", "path", "rest", "path", "abs", "target", "defaultPlatform", "import_fs", "import_path", "import_fs", "sourceRoot", "totalDuration", "dependencyGraph", "sourceRoot", "sourceRoot", "import_child_process", "import_path", "import_child_process", "import_path", "match", "sourceRoot", "import_child_process", "import_fs", "import_path", "sourceRoot", "cacheSubDirName", "import_fs", "import_path", "sourceRoot", "dependencyGraph", "validationResult", "import_child_process", "import_path", "codeqlExePath", "dependencyGraph", "codeqlExePath", "dependencyGraph", "codeqlExePath", "projectCacheDirMap", "import_path", "import_path", "import_fs", "import_path", "match", "path", "parentDir", "hasDbDir", "hasSrvDir", "hasAppDir", "dependencyGraph", "import_child_process", "sourceRoot", "autobuildScriptPath", "codeqlExePath", "import_child_process", "import_fs", "import_path", "platformInfo", "codeqlExePath", "sourceRoot", "errorMessages", "autobuildScriptPath", "import_child_process", "import_fs", "import_path", "import_child_process", "match", "range", "codeqlExePath", "dependencyGraph", "sourceRoot", "projectCacheDirMap", "import_path", "sourceRoot"]
}
