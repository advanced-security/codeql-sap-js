{
  "version": 3,
  "sources": ["../node_modules/shell-quote/quote.js", "../node_modules/shell-quote/parse.js", "../node_modules/shell-quote/index.js", "../cds-extractor.ts", "../node_modules/@isaacs/balanced-match/src/index.ts", "../node_modules/@isaacs/brace-expansion/src/index.ts", "../node_modules/glob/node_modules/minimatch/src/assert-valid-pattern.ts", "../node_modules/glob/node_modules/minimatch/src/brace-expressions.ts", "../node_modules/glob/node_modules/minimatch/src/unescape.ts", "../node_modules/glob/node_modules/minimatch/src/ast.ts", "../node_modules/glob/node_modules/minimatch/src/escape.ts", "../node_modules/glob/node_modules/minimatch/src/index.ts", "../node_modules/glob/src/glob.ts", "../node_modules/path-scurry/node_modules/lru-cache/src/index.ts", "../node_modules/path-scurry/src/index.ts", "../node_modules/minipass/src/index.ts", "../node_modules/glob/src/pattern.ts", "../node_modules/glob/src/ignore.ts", "../node_modules/glob/src/processor.ts", "../node_modules/glob/src/walker.ts", "../node_modules/glob/src/has-magic.ts", "../node_modules/glob/src/index.ts", "../src/cds/compiler/command.ts", "../src/filesystem.ts", "../src/logging/cdsExtractorLog.ts", "../src/logging/statusReport.ts", "../src/cds/compiler/compile.ts", "../src/cds/compiler/version.ts", "../src/diagnostics.ts", "../src/cds/compiler/graph.ts", "../src/cds/compiler/project.ts", "../src/cds/parser/graph.ts", "../src/cds/parser/functions.ts", "../src/codeql.ts", "../src/environment.ts", "../src/packageManager/installer.ts", "../src/packageManager/versionResolver.ts", "../src/utils.ts"],
  "sourcesContent": ["'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s === '') {\n\t\t\treturn '\\'\\'';\n\t\t}\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s\\\\]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n", "'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n", "'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n", "import { join } from 'path';\n\nimport { sync as globSync } from 'glob';\n\nimport { orchestrateCompilation } from './src/cds/compiler';\nimport { buildCdsProjectDependencyGraph } from './src/cds/parser';\nimport { runJavaScriptExtractor } from './src/codeql';\nimport { addCompilationDiagnostic } from './src/diagnostics';\nimport { configureLgtmIndexFilters, setupAndValidateEnvironment } from './src/environment';\nimport {\n  cdsExtractorLog,\n  generateStatusReport,\n  logExtractorStart,\n  logExtractorStop,\n  logPerformanceMilestone,\n  logPerformanceTrackingStart,\n  logPerformanceTrackingStop,\n  setSourceRootDirectory,\n} from './src/logging';\nimport { installDependencies } from './src/packageManager';\nimport { validateArguments } from './src/utils';\n\n// Validate the script arguments.\nconst validationResult = validateArguments(process.argv);\nif (!validationResult.isValid) {\n  console.warn(validationResult.usageMessage);\n  // Exit with an error code on invalid use of this script.\n  process.exit(1);\n}\n\n// Get the validated and sanitized arguments.\nconst { sourceRoot } = validationResult.args!;\n\n// Initialize the unified logging system with the source root directory.\nsetSourceRootDirectory(sourceRoot);\n\n// Log the start of the CDS extractor session as a whole.\nlogExtractorStart(sourceRoot);\n\n// Setup the environment and validate all requirements first, before changing\n// directory back to the \"sourceRoot\" directory. This ensures we can properly locate\n// the CodeQL tools.\nlogPerformanceTrackingStart('Environment Setup');\nconst {\n  success: envSetupSuccess,\n  errorMessages,\n  codeqlExePath,\n  autobuildScriptPath,\n  platformInfo,\n} = setupAndValidateEnvironment(sourceRoot);\nlogPerformanceTrackingStop('Environment Setup');\n\nif (!envSetupSuccess) {\n  const codeqlExe = platformInfo.isWindows ? 'codeql.exe' : 'codeql';\n  cdsExtractorLog(\n    'warn',\n    `'${codeqlExe} database index-files --language cds' terminated early due to: ${errorMessages.join(\n      ', ',\n    )}.`,\n  );\n  // Exit with an error code when environment setup fails.\n  logExtractorStop(false, 'Terminated: Environment setup failed');\n  process.exit(1);\n}\n\n// Force this script, and any process it spawns, to use the project (source) root\n// directory as the current working directory.\nprocess.chdir(sourceRoot);\n\ncdsExtractorLog(\n  'info',\n  `CodeQL CDS extractor using autobuild mode for scan of project source root directory '${sourceRoot}'.`,\n);\n\ncdsExtractorLog('info', 'Building CDS project dependency graph...');\n\n// Build the CDS project `dependencyGraph` as the foundation for the extraction process.\n// This graph will contain all discovered CDS projects, their dependencies, the `.cds`\n// files discovered within each project, the expected `.cds.json` files for each project\n// and the compilation status of such `.cds.json` files.\n//\n// The `dependencyGraph` will be updated as CDS extractor phases progress, allowing for\n// a single data structure to be used for planning, execution, retries (i.e. error handling),\n// debugging, and final reporting.\nlet dependencyGraph;\n\ntry {\n  logPerformanceTrackingStart('Dependency Graph Build');\n  dependencyGraph = buildCdsProjectDependencyGraph(sourceRoot);\n  logPerformanceTrackingStop('Dependency Graph Build');\n\n  logPerformanceMilestone(\n    'Dependency graph created',\n    `${dependencyGraph.projects.size} projects, ${dependencyGraph.statusSummary.totalCdsFiles} CDS files`,\n  );\n\n  // Log details about discovered projects for debugging\n  if (dependencyGraph.projects.size > 0) {\n    for (const [projectDir, project] of dependencyGraph.projects.entries()) {\n      cdsExtractorLog(\n        'info',\n        `Project: ${projectDir}, Status: ${project.status}, CDS files: ${project.cdsFiles.length}, Compilations to run: ${project.cdsFilesToCompile.length}`,\n      );\n    }\n  } else {\n    cdsExtractorLog(\n      'error',\n      'No CDS projects were detected. This is an unrecoverable error as there is nothing to scan.',\n    );\n    // Let's also try to find CDS files directly as a backup check\n    try {\n      const allCdsFiles = Array.from(\n        new Set([\n          ...globSync(join(sourceRoot, '**/*.cds'), {\n            ignore: ['**/node_modules/**', '**/.git/**'],\n          }),\n        ]),\n      );\n      cdsExtractorLog(\n        'info',\n        `Direct search found ${allCdsFiles.length} CDS files in the source tree.`,\n      );\n      if (allCdsFiles.length > 0) {\n        cdsExtractorLog(\n          'info',\n          `Sample CDS files: ${allCdsFiles.slice(0, 5).join(', ')}${allCdsFiles.length > 5 ? ', ...' : ''}`,\n        );\n        cdsExtractorLog(\n          'error',\n          'CDS files were found but no projects were detected. This indicates a problem with project detection logic.',\n        );\n      } else {\n        cdsExtractorLog(\n          'info',\n          'No CDS files found in the source tree. This may be expected if the source does not contain CAP/CDS projects.',\n        );\n      }\n    } catch (globError) {\n      cdsExtractorLog('warn', `Could not perform direct CDS file search: ${String(globError)}`);\n    }\n\n    // Exit early since we have no CDS projects to process\n    logExtractorStop(false, 'Terminated: No CDS projects detected');\n    process.exit(1);\n  }\n} catch (error) {\n  cdsExtractorLog('error', `Failed to build CDS dependency graph: ${String(error)}`);\n  // Exit with error since we can't continue without a proper dependency graph\n  logExtractorStop(false, 'Terminated: Dependency graph build failed');\n  process.exit(1);\n}\n\nlogPerformanceTrackingStart('Dependency Installation');\nconst projectCacheDirMap = installDependencies(dependencyGraph, sourceRoot, codeqlExePath);\nlogPerformanceTrackingStop('Dependency Installation');\n\n// Check if dependency installation resulted in any usable project mappings\nif (projectCacheDirMap.size === 0) {\n  cdsExtractorLog(\n    'error',\n    'No project cache directory mappings were created. This indicates that dependency installation failed for all discovered projects.',\n  );\n\n  // This is a critical error if we have projects but no cache mappings\n  if (dependencyGraph.projects.size > 0) {\n    cdsExtractorLog(\n      'error',\n      `Found ${dependencyGraph.projects.size} CDS projects but failed to install dependencies for any of them. Cannot proceed with compilation.`,\n    );\n    logExtractorStop(false, 'Terminated: Dependency installation failed for all projects');\n    process.exit(1);\n  }\n\n  // If we have no projects and no cache mappings, this should have been caught earlier\n  cdsExtractorLog(\n    'warn',\n    'No projects and no cache mappings - this should have been detected earlier.',\n  );\n}\n\nconst cdsFilePathsToProcess: string[] = [];\n\n// Use the dependency graph to collect all `.cds` files from each project.\n// We want to \"extract\" all `.cds` files from all projects so that we have a copy\n// of each `.cds` source file in the CodeQL database.\nfor (const project of dependencyGraph.projects.values()) {\n  cdsFilePathsToProcess.push(...project.cdsFiles);\n}\n\n// TODO : Improve logging / debugging of dependencyGraph.statusSummary. Just log the JSON?\ncdsExtractorLog(\n  'info',\n  `Found ${cdsFilePathsToProcess.length} total CDS files, ${dependencyGraph.statusSummary.totalCdsFiles} CDS files in dependency graph`,\n);\n\nlogPerformanceTrackingStart('CDS Compilation');\ntry {\n  // Use the new orchestrated compilation approach (autobuild mode, no debug)\n  orchestrateCompilation(dependencyGraph, projectCacheDirMap, codeqlExePath);\n\n  // Handle compilation failures for normal mode\n  if (!dependencyGraph.statusSummary.overallSuccess) {\n    cdsExtractorLog(\n      'error',\n      `Compilation completed with failures: ${dependencyGraph.statusSummary.failedCompilations} failed out of ${dependencyGraph.statusSummary.totalCompilationTasks} total tasks`,\n    );\n\n    // Add diagnostics for critical errors\n    for (const error of dependencyGraph.errors.critical) {\n      cdsExtractorLog('error', `Critical error in ${error.phase}: ${error.message}`);\n    }\n\n    // Don't exit with error - let the JavaScript extractor run on whatever was compiled\n  }\n\n  logPerformanceTrackingStop('CDS Compilation');\n  logPerformanceMilestone('CDS compilation completed');\n} catch (error) {\n  logPerformanceTrackingStop('CDS Compilation');\n  cdsExtractorLog('error', `Compilation orchestration failed: ${String(error)}`);\n\n  // Add diagnostic for the overall failure\n  if (cdsFilePathsToProcess.length > 0) {\n    addCompilationDiagnostic(\n      cdsFilePathsToProcess[0], // Use first file as representative\n      `Compilation orchestration failed: ${String(error)}`,\n      codeqlExePath,\n    );\n  }\n}\n\n// Configure the \"LGTM\" index filters for proper extraction.\nconfigureLgtmIndexFilters();\n\n// Run CodeQL's JavaScript extractor to process the .cds source files and\n// the compiled .cds.json files.\nlogPerformanceTrackingStart('JavaScript Extraction');\nconst extractionStartTime = Date.now();\nconst extractorResult = runJavaScriptExtractor(sourceRoot, autobuildScriptPath, codeqlExePath);\nconst extractionEndTime = Date.now();\nlogPerformanceTrackingStop('JavaScript Extraction');\n\n// Update the dependency graph's performance metrics with the extraction duration\ndependencyGraph.statusSummary.performance.extractionDurationMs =\n  extractionEndTime - extractionStartTime;\n\n// Calculate total duration by summing all phases\nconst totalDuration =\n  dependencyGraph.statusSummary.performance.parsingDurationMs +\n  dependencyGraph.statusSummary.performance.compilationDurationMs +\n  dependencyGraph.statusSummary.performance.extractionDurationMs;\ndependencyGraph.statusSummary.performance.totalDurationMs = totalDuration;\n\nif (!extractorResult.success && extractorResult.error) {\n  cdsExtractorLog('error', `Error running JavaScript extractor: ${extractorResult.error}`);\n  logExtractorStop(false, 'JavaScript extractor failed');\n} else {\n  logExtractorStop(true, 'CDS extraction completed successfully');\n}\n\ncdsExtractorLog(\n  'info',\n  'CDS Extractor Status Report : Final...\\n' + generateStatusReport(dependencyGraph),\n);\n\n// Use the `cds-extractor.js` name in the log message as that is the name of the script\n// that is actually run by the `codeql database index-files` command. This TypeScript\n// file is where the code/logic is edited/implemented, but the runnable script is\n// generated by the TypeScript compiler and is named `cds-extractor.js`.\nconsole.log(`Completed run of the cds-extractor.js script for the CDS extractor.`);\n", "export const balanced = (\n  a: string | RegExp,\n  b: string | RegExp,\n  str: string,\n) => {\n  const ma = a instanceof RegExp ? maybeMatch(a, str) : a\n  const mb = b instanceof RegExp ? maybeMatch(b, str) : b\n\n  const r = ma !== null && mb != null && range(ma, mb, str)\n\n  return (\n    r && {\n      start: r[0],\n      end: r[1],\n      pre: str.slice(0, r[0]),\n      body: str.slice(r[0] + ma.length, r[1]),\n      post: str.slice(r[1] + mb.length),\n    }\n  )\n}\n\nconst maybeMatch = (reg: RegExp, str: string) => {\n  const m = str.match(reg)\n  return m ? m[0] : null\n}\n\nexport const range = (\n  a: string,\n  b: string,\n  str: string,\n): undefined | [number, number] => {\n  let begs: number[],\n    beg: number | undefined,\n    left: number,\n    right: number | undefined = undefined,\n    result: undefined | [number, number]\n  let ai = str.indexOf(a)\n  let bi = str.indexOf(b, ai + 1)\n  let i = ai\n\n  if (ai >= 0 && bi > 0) {\n    if (a === b) {\n      return [ai, bi]\n    }\n    begs = []\n    left = str.length\n\n    while (i >= 0 && !result) {\n      if (i === ai) {\n        begs.push(i)\n        ai = str.indexOf(a, i + 1)\n      } else if (begs.length === 1) {\n        const r = begs.pop()\n        if (r !== undefined) result = [r, bi]\n      } else {\n        beg = begs.pop()\n        if (beg !== undefined && beg < left) {\n          left = beg\n          right = bi\n        }\n\n        bi = str.indexOf(b, i + 1)\n      }\n\n      i = ai < bi && ai >= 0 ? ai : bi\n    }\n\n    if (begs.length && right !== undefined) {\n      result = [left, right]\n    }\n  }\n\n  return result\n}\n", "import { balanced } from '@isaacs/balanced-match'\n\nconst escSlash = '\\0SLASH' + Math.random() + '\\0'\nconst escOpen = '\\0OPEN' + Math.random() + '\\0'\nconst escClose = '\\0CLOSE' + Math.random() + '\\0'\nconst escComma = '\\0COMMA' + Math.random() + '\\0'\nconst escPeriod = '\\0PERIOD' + Math.random() + '\\0'\nconst escSlashPattern = new RegExp(escSlash, 'g')\nconst escOpenPattern = new RegExp(escOpen, 'g')\nconst escClosePattern = new RegExp(escClose, 'g')\nconst escCommaPattern = new RegExp(escComma, 'g')\nconst escPeriodPattern = new RegExp(escPeriod, 'g')\nconst slashPattern = /\\\\\\\\/g\nconst openPattern = /\\\\{/g\nconst closePattern = /\\\\}/g\nconst commaPattern = /\\\\,/g\nconst periodPattern = /\\\\./g\n\nfunction numeric(str: string) {\n  return !isNaN(str as any) ? parseInt(str, 10) : str.charCodeAt(0)\n}\n\nfunction escapeBraces(str: string) {\n  return str\n    .replace(slashPattern, escSlash)\n    .replace(openPattern, escOpen)\n    .replace(closePattern, escClose)\n    .replace(commaPattern, escComma)\n    .replace(periodPattern, escPeriod)\n}\n\nfunction unescapeBraces(str: string) {\n  return str\n    .replace(escSlashPattern, '\\\\')\n    .replace(escOpenPattern, '{')\n    .replace(escClosePattern, '}')\n    .replace(escCommaPattern, ',')\n    .replace(escPeriodPattern, '.')\n}\n\n/**\n * Basically just str.split(\",\"), but handling cases\n * where we have nested braced sections, which should be\n * treated as individual members, like {a,{b,c},d}\n */\nfunction parseCommaParts(str: string) {\n  if (!str) {\n    return ['']\n  }\n\n  const parts: string[] = []\n  const m = balanced('{', '}', str)\n\n  if (!m) {\n    return str.split(',')\n  }\n\n  const { pre, body, post } = m\n  const p = pre.split(',')\n\n  p[p.length - 1] += '{' + body + '}'\n  const postParts = parseCommaParts(post)\n  if (post.length) {\n    ;(p[p.length - 1] as string) += postParts.shift()\n    p.push.apply(p, postParts)\n  }\n\n  parts.push.apply(parts, p)\n\n  return parts\n}\n\nexport function expand(str: string) {\n  if (!str) {\n    return []\n  }\n\n  // I don't know why Bash 4.3 does this, but it does.\n  // Anything starting with {} will have the first two bytes preserved\n  // but *only* at the top level, so {},a}b will not expand to anything,\n  // but a{},b}c will be expanded to [a}c,abc].\n  // One could argue that this is a bug in Bash, but since the goal of\n  // this module is to match Bash's rules, we escape a leading {}\n  if (str.slice(0, 2) === '{}') {\n    str = '\\\\{\\\\}' + str.slice(2)\n  }\n\n  return expand_(escapeBraces(str), true).map(unescapeBraces)\n}\n\nfunction embrace(str: string) {\n  return '{' + str + '}'\n}\n\nfunction isPadded(el: string) {\n  return /^-?0\\d/.test(el)\n}\n\nfunction lte(i: number, y: number) {\n  return i <= y\n}\n\nfunction gte(i: number, y: number) {\n  return i >= y\n}\n\nfunction expand_(str: string, isTop?: boolean): string[] {\n  /** @type {string[]} */\n  const expansions: string[] = []\n\n  const m = balanced('{', '}', str)\n  if (!m) return [str]\n\n  // no need to expand pre, since it is guaranteed to be free of brace-sets\n  const pre = m.pre\n  const post: string[] = m.post.length ? expand_(m.post, false) : ['']\n\n  if (/\\$$/.test(m.pre)) {\n    for (let k = 0; k < post.length; k++) {\n      const expansion = pre + '{' + m.body + '}' + post[k]\n      expansions.push(expansion)\n    }\n  } else {\n    const isNumericSequence = /^-?\\d+\\.\\.-?\\d+(?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isAlphaSequence = /^[a-zA-Z]\\.\\.[a-zA-Z](?:\\.\\.-?\\d+)?$/.test(m.body)\n    const isSequence = isNumericSequence || isAlphaSequence\n    const isOptions = m.body.indexOf(',') >= 0\n    if (!isSequence && !isOptions) {\n      // {a},b}\n      if (m.post.match(/,(?!,).*\\}/)) {\n        str = m.pre + '{' + m.body + escClose + m.post\n        return expand_(str)\n      }\n      return [str]\n    }\n\n    let n: string[]\n    if (isSequence) {\n      n = m.body.split(/\\.\\./)\n    } else {\n      n = parseCommaParts(m.body)\n      if (n.length === 1 && n[0] !== undefined) {\n        // x{{a,b}}y ==> x{a}y x{b}y\n        n = expand_(n[0], false).map(embrace)\n        //XXX is this necessary? Can't seem to hit it in tests.\n        /* c8 ignore start */\n        if (n.length === 1) {\n          return post.map(p => m.pre + n[0] + p)\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    // at this point, n is the parts, and we know it's not a comma set\n    // with a single entry.\n    let N: string[]\n\n    if (isSequence && n[0] !== undefined && n[1] !== undefined) {\n      const x = numeric(n[0])\n      const y = numeric(n[1])\n      const width = Math.max(n[0].length, n[1].length)\n      let incr =\n        n.length === 3 && n[2] !== undefined ? Math.abs(numeric(n[2])) : 1\n      let test = lte\n      const reverse = y < x\n      if (reverse) {\n        incr *= -1\n        test = gte\n      }\n      const pad = n.some(isPadded)\n\n      N = []\n\n      for (let i = x; test(i, y); i += incr) {\n        let c\n        if (isAlphaSequence) {\n          c = String.fromCharCode(i)\n          if (c === '\\\\') {\n            c = ''\n          }\n        } else {\n          c = String(i)\n          if (pad) {\n            const need = width - c.length\n            if (need > 0) {\n              const z = new Array(need + 1).join('0')\n              if (i < 0) {\n                c = '-' + z + c.slice(1)\n              } else {\n                c = z + c\n              }\n            }\n          }\n        }\n        N.push(c)\n      }\n    } else {\n      N = []\n\n      for (let j = 0; j < n.length; j++) {\n        N.push.apply(N, expand_(n[j] as string, false))\n      }\n    }\n\n    for (let j = 0; j < N.length; j++) {\n      for (let k = 0; k < post.length; k++) {\n        const expansion = pre + N[j] + post[k]\n        if (!isTop || isSequence || expansion) {\n          expansions.push(expansion)\n        }\n      }\n    }\n  }\n\n  return expansions\n}\n", "const MAX_PATTERN_LENGTH = 1024 * 64\nexport const assertValidPattern: (pattern: any) => void = (\n  pattern: any\n): asserts pattern is string => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n", "// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Un-escape a string that has been escaped with {@link escape}.\n *\n * If the {@link windowsPathsNoEscape} option is used, then square-brace\n * escapes are removed, but not backslash escapes.  For example, it will turn\n * the string `'[*]'` into `*`, but it will not turn `'\\\\*'` into `'*'`,\n * becuase `\\` is a path separator in `windowsPathsNoEscape` mode.\n *\n * When `windowsPathsNoEscape` is not set, then both brace escapes and\n * backslash escapes are removed.\n *\n * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped\n * or unescaped.\n */\nexport const unescape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  return windowsPathsNoEscape\n    ? s.replace(/\\[([^\\/\\\\])\\]/g, '$1')\n    : s.replace(/((?!\\\\).|^)\\[([^\\/\\\\])\\]/g, '$1$2').replace(/\\\\([^\\/])/g, '$1')\n}\n", "// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n", "import { MinimatchOptions } from './index.js'\n/**\n * Escape all magic characters in a glob pattern.\n *\n * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}\n * option is used, then characters are escaped by wrapping in `[]`, because\n * a magic character wrapped in a character class can only be satisfied by\n * that exact character.  In this mode, `\\` is _not_ escaped, because it is\n * not interpreted as a magic character, but instead as a path separator.\n */\nexport const escape = (\n  s: string,\n  {\n    windowsPathsNoEscape = false,\n  }: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n) => {\n  // don't need to escape +@! because we escape the parens\n  // that make those magic, and escaping ! as [!] isn't valid,\n  // because [!]] is a valid glob class meaning not ']'.\n  return windowsPathsNoEscape\n    ? s.replace(/[?*()[\\]]/g, '[$&]')\n    : s.replace(/[?*()[\\]\\\\]/g, '\\\\$&')\n}\n", "import { expand } from '@isaacs/brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n", "import { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { fileURLToPath } from 'node:url'\nimport {\n  FSOption,\n  Path,\n  PathScurry,\n  PathScurryDarwin,\n  PathScurryPosix,\n  PathScurryWin32,\n} from 'path-scurry'\nimport { IgnoreLike } from './ignore.js'\nimport { Pattern } from './pattern.js'\nimport { GlobStream, GlobWalker } from './walker.js'\n\nexport type MatchSet = Minimatch['set']\nexport type GlobParts = Exclude<Minimatch['globParts'], undefined>\n\n// if no process global, just call it linux.\n// so we default to case-sensitive, / separators\nconst defaultPlatform: NodeJS.Platform =\n  (\n    typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n  ) ?\n    process.platform\n  : 'linux'\n\n/**\n * A `GlobOptions` object may be provided to any of the exported methods, and\n * must be provided to the `Glob` constructor.\n *\n * All options are optional, boolean, and false by default, unless otherwise\n * noted.\n *\n * All resolved options are added to the Glob object as properties.\n *\n * If you are running many `glob` operations, you can pass a Glob object as the\n * `options` argument to a subsequent operation to share the previously loaded\n * cache.\n */\nexport interface GlobOptions {\n  /**\n   * Set to `true` to always receive absolute paths for\n   * matched files. Set to `false` to always return relative paths.\n   *\n   * When this option is not set, absolute paths are returned for patterns\n   * that are absolute, and otherwise paths are returned that are relative\n   * to the `cwd` setting.\n   *\n   * This does _not_ make an extra system call to get\n   * the realpath, it only does string path resolution.\n   *\n   * Conflicts with {@link withFileTypes}\n   */\n  absolute?: boolean\n\n  /**\n   * Set to false to enable {@link windowsPathsNoEscape}\n   *\n   * @deprecated\n   */\n  allowWindowsEscape?: boolean\n\n  /**\n   * The current working directory in which to search. Defaults to\n   * `process.cwd()`.\n   *\n   * May be eiher a string path or a `file://` URL object or string.\n   */\n  cwd?: string | URL\n\n  /**\n   * Include `.dot` files in normal matches and `globstar`\n   * matches. Note that an explicit dot in a portion of the pattern\n   * will always match dot files.\n   */\n  dot?: boolean\n\n  /**\n   * Prepend all relative path strings with `./` (or `.\\` on Windows).\n   *\n   * Without this option, returned relative paths are \"bare\", so instead of\n   * returning `'./foo/bar'`, they are returned as `'foo/bar'`.\n   *\n   * Relative patterns starting with `'../'` are not prepended with `./`, even\n   * if this option is set.\n   */\n  dotRelative?: boolean\n\n  /**\n   * Follow symlinked directories when expanding `**`\n   * patterns. This can result in a lot of duplicate references in\n   * the presence of cyclic links, and make performance quite bad.\n   *\n   * By default, a `**` in a pattern will follow 1 symbolic link if\n   * it is not the first item in the pattern, or none if it is the\n   * first item in the pattern, following the same behavior as Bash.\n   */\n  follow?: boolean\n\n  /**\n   * string or string[], or an object with `ignored` and `childrenIgnored`\n   * methods.\n   *\n   * If a string or string[] is provided, then this is treated as a glob\n   * pattern or array of glob patterns to exclude from matches. To ignore all\n   * children within a directory, as well as the entry itself, append `'/**'`\n   * to the ignore pattern.\n   *\n   * **Note** `ignore` patterns are _always_ in `dot:true` mode, regardless of\n   * any other settings.\n   *\n   * If an object is provided that has `ignored(path)` and/or\n   * `childrenIgnored(path)` methods, then these methods will be called to\n   * determine whether any Path is a match or if its children should be\n   * traversed, respectively.\n   */\n  ignore?: string | string[] | IgnoreLike\n\n  /**\n   * Treat brace expansion like `{a,b}` as a \"magic\" pattern. Has no\n   * effect if {@link nobrace} is set.\n   *\n   * Only has effect on the {@link hasMagic} function.\n   */\n  magicalBraces?: boolean\n\n  /**\n   * Add a `/` character to directory matches. Note that this requires\n   * additional stat calls in some cases.\n   */\n  mark?: boolean\n\n  /**\n   * Perform a basename-only match if the pattern does not contain any slash\n   * characters. That is, `*.js` would be treated as equivalent to\n   * `**\\/*.js`, matching all js files in all directories.\n   */\n  matchBase?: boolean\n\n  /**\n   * Limit the directory traversal to a given depth below the cwd.\n   * Note that this does NOT prevent traversal to sibling folders,\n   * root patterns, and so on. It only limits the maximum folder depth\n   * that the walk will descend, relative to the cwd.\n   */\n  maxDepth?: number\n\n  /**\n   * Do not expand `{a,b}` and `{1..3}` brace sets.\n   */\n  nobrace?: boolean\n\n  /**\n   * Perform a case-insensitive match. This defaults to `true` on macOS and\n   * Windows systems, and `false` on all others.\n   *\n   * **Note** `nocase` should only be explicitly set when it is\n   * known that the filesystem's case sensitivity differs from the\n   * platform default. If set `true` on case-sensitive file\n   * systems, or `false` on case-insensitive file systems, then the\n   * walk may return more or less results than expected.\n   */\n  nocase?: boolean\n\n  /**\n   * Do not match directories, only files. (Note: to match\n   * _only_ directories, put a `/` at the end of the pattern.)\n   */\n  nodir?: boolean\n\n  /**\n   * Do not match \"extglob\" patterns such as `+(a|b)`.\n   */\n  noext?: boolean\n\n  /**\n   * Do not match `**` against multiple filenames. (Ie, treat it as a normal\n   * `*` instead.)\n   *\n   * Conflicts with {@link matchBase}\n   */\n  noglobstar?: boolean\n\n  /**\n   * Defaults to value of `process.platform` if available, or `'linux'` if\n   * not. Setting `platform:'win32'` on non-Windows systems may cause strange\n   * behavior.\n   */\n  platform?: NodeJS.Platform\n\n  /**\n   * Set to true to call `fs.realpath` on all of the\n   * results. In the case of an entry that cannot be resolved, the\n   * entry is omitted. This incurs a slight performance penalty, of\n   * course, because of the added system calls.\n   */\n  realpath?: boolean\n\n  /**\n   *\n   * A string path resolved against the `cwd` option, which\n   * is used as the starting point for absolute patterns that start\n   * with `/`, (but not drive letters or UNC paths on Windows).\n   *\n   * Note that this _doesn't_ necessarily limit the walk to the\n   * `root` directory, and doesn't affect the cwd starting point for\n   * non-absolute patterns. A pattern containing `..` will still be\n   * able to traverse out of the root directory, if it is not an\n   * actual root directory on the filesystem, and any non-absolute\n   * patterns will be matched in the `cwd`. For example, the\n   * pattern `/../*` with `{root:'/some/path'}` will return all\n   * files in `/some`, not all files in `/some/path`. The pattern\n   * `*` with `{root:'/some/path'}` will return all the entries in\n   * the cwd, not the entries in `/some/path`.\n   *\n   * To start absolute and non-absolute patterns in the same\n   * path, you can use `{root:''}`. However, be aware that on\n   * Windows systems, a pattern like `x:/*` or `//host/share/*` will\n   * _always_ start in the `x:/` or `//host/share` directory,\n   * regardless of the `root` setting.\n   */\n  root?: string\n\n  /**\n   * A [PathScurry](http://npm.im/path-scurry) object used\n   * to traverse the file system. If the `nocase` option is set\n   * explicitly, then any provided `scurry` object must match this\n   * setting.\n   */\n  scurry?: PathScurry\n\n  /**\n   * Call `lstat()` on all entries, whether required or not to determine\n   * if it's a valid match. When used with {@link withFileTypes}, this means\n   * that matches will include data such as modified time, permissions, and\n   * so on.  Note that this will incur a performance cost due to the added\n   * system calls.\n   */\n  stat?: boolean\n\n  /**\n   * An AbortSignal which will cancel the Glob walk when\n   * triggered.\n   */\n  signal?: AbortSignal\n\n  /**\n   * Use `\\\\` as a path separator _only_, and\n   *  _never_ as an escape character. If set, all `\\\\` characters are\n   *  replaced with `/` in the pattern.\n   *\n   *  Note that this makes it **impossible** to match against paths\n   *  containing literal glob pattern characters, but allows matching\n   *  with patterns constructed using `path.join()` and\n   *  `path.resolve()` on Windows platforms, mimicking the (buggy!)\n   *  behavior of Glob v7 and before on Windows. Please use with\n   *  caution, and be mindful of [the caveat below about Windows\n   *  paths](#windows). (For legacy reasons, this is also set if\n   *  `allowWindowsEscape` is set to the exact value `false`.)\n   */\n  windowsPathsNoEscape?: boolean\n\n  /**\n   * Return [PathScurry](http://npm.im/path-scurry)\n   * `Path` objects instead of strings. These are similar to a\n   * NodeJS `Dirent` object, but with additional methods and\n   * properties.\n   *\n   * Conflicts with {@link absolute}\n   */\n  withFileTypes?: boolean\n\n  /**\n   * An fs implementation to override some or all of the defaults.  See\n   * http://npm.im/path-scurry for details about what can be overridden.\n   */\n  fs?: FSOption\n\n  /**\n   * Just passed along to Minimatch.  Note that this makes all pattern\n   * matching operations slower and *extremely* noisy.\n   */\n  debug?: boolean\n\n  /**\n   * Return `/` delimited paths, even on Windows.\n   *\n   * On posix systems, this has no effect.  But, on Windows, it means that\n   * paths will be `/` delimited, and absolute paths will be their full\n   * resolved UNC forms, eg instead of `'C:\\\\foo\\\\bar'`, it would return\n   * `'//?/C:/foo/bar'`\n   */\n  posix?: boolean\n\n  /**\n   * Do not match any children of any matches. For example, the pattern\n   * `**\\/foo` would match `a/foo`, but not `a/foo/b/foo` in this mode.\n   *\n   * This is especially useful for cases like \"find all `node_modules`\n   * folders, but not the ones in `node_modules`\".\n   *\n   * In order to support this, the `Ignore` implementation must support an\n   * `add(pattern: string)` method. If using the default `Ignore` class, then\n   * this is fine, but if this is set to `false`, and a custom `Ignore` is\n   * provided that does not have an `add()` method, then it will throw an\n   * error.\n   *\n   * **Caveat** It *only* ignores matches that would be a descendant of a\n   * previous match, and only if that descendant is matched *after* the\n   * ancestor is encountered. Since the file system walk happens in\n   * indeterminate order, it's possible that a match will already be added\n   * before its ancestor, if multiple or braced patterns are used.\n   *\n   * For example:\n   *\n   * ```ts\n   * const results = await glob([\n   *   // likely to match first, since it's just a stat\n   *   'a/b/c/d/e/f',\n   *\n   *   // this pattern is more complicated! It must to various readdir()\n   *   // calls and test the results against a regular expression, and that\n   *   // is certainly going to take a little bit longer.\n   *   //\n   *   // So, later on, it encounters a match at 'a/b/c/d/e', but it's too\n   *   // late to ignore a/b/c/d/e/f, because it's already been emitted.\n   *   'a/[bdf]/?/[a-z]/*',\n   * ], { includeChildMatches: false })\n   * ```\n   *\n   * It's best to only set this to `false` if you can be reasonably sure that\n   * no components of the pattern will potentially match one another's file\n   * system descendants, or if the occasional included child entry will not\n   * cause problems.\n   *\n   * @default true\n   */\n  includeChildMatches?: boolean\n}\n\nexport type GlobOptionsWithFileTypesTrue = GlobOptions & {\n  withFileTypes: true\n  // string options not relevant if returning Path objects.\n  absolute?: undefined\n  mark?: undefined\n  posix?: undefined\n}\n\nexport type GlobOptionsWithFileTypesFalse = GlobOptions & {\n  withFileTypes?: false\n}\n\nexport type GlobOptionsWithFileTypesUnset = GlobOptions & {\n  withFileTypes?: undefined\n}\n\nexport type Result<Opts> =\n  Opts extends GlobOptionsWithFileTypesTrue ? Path\n  : Opts extends GlobOptionsWithFileTypesFalse ? string\n  : Opts extends GlobOptionsWithFileTypesUnset ? string\n  : string | Path\nexport type Results<Opts> = Result<Opts>[]\n\nexport type FileTypes<Opts> =\n  Opts extends GlobOptionsWithFileTypesTrue ? true\n  : Opts extends GlobOptionsWithFileTypesFalse ? false\n  : Opts extends GlobOptionsWithFileTypesUnset ? false\n  : boolean\n\n/**\n * An object that can perform glob pattern traversals.\n */\nexport class Glob<Opts extends GlobOptions> implements GlobOptions {\n  absolute?: boolean\n  cwd: string\n  root?: string\n  dot: boolean\n  dotRelative: boolean\n  follow: boolean\n  ignore?: string | string[] | IgnoreLike\n  magicalBraces: boolean\n  mark?: boolean\n  matchBase: boolean\n  maxDepth: number\n  nobrace: boolean\n  nocase: boolean\n  nodir: boolean\n  noext: boolean\n  noglobstar: boolean\n  pattern: string[]\n  platform: NodeJS.Platform\n  realpath: boolean\n  scurry: PathScurry\n  stat: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape: boolean\n  withFileTypes: FileTypes<Opts>\n  includeChildMatches: boolean\n\n  /**\n   * The options provided to the constructor.\n   */\n  opts: Opts\n\n  /**\n   * An array of parsed immutable {@link Pattern} objects.\n   */\n  patterns: Pattern[]\n\n  /**\n   * All options are stored as properties on the `Glob` object.\n   *\n   * See {@link GlobOptions} for full options descriptions.\n   *\n   * Note that a previous `Glob` object can be passed as the\n   * `GlobOptions` to another `Glob` instantiation to re-use settings\n   * and caches with a new pattern.\n   *\n   * Traversal functions can be called multiple times to run the walk\n   * again.\n   */\n  constructor(pattern: string | string[], opts: Opts) {\n    /* c8 ignore start */\n    if (!opts) throw new TypeError('glob options required')\n    /* c8 ignore stop */\n    this.withFileTypes = !!opts.withFileTypes as FileTypes<Opts>\n    this.signal = opts.signal\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.dotRelative = !!opts.dotRelative\n    this.nodir = !!opts.nodir\n    this.mark = !!opts.mark\n    if (!opts.cwd) {\n      this.cwd = ''\n    } else if (opts.cwd instanceof URL || opts.cwd.startsWith('file://')) {\n      opts.cwd = fileURLToPath(opts.cwd)\n    }\n    this.cwd = opts.cwd || ''\n    this.root = opts.root\n    this.magicalBraces = !!opts.magicalBraces\n    this.nobrace = !!opts.nobrace\n    this.noext = !!opts.noext\n    this.realpath = !!opts.realpath\n    this.absolute = opts.absolute\n    this.includeChildMatches = opts.includeChildMatches !== false\n\n    this.noglobstar = !!opts.noglobstar\n    this.matchBase = !!opts.matchBase\n    this.maxDepth =\n      typeof opts.maxDepth === 'number' ? opts.maxDepth : Infinity\n    this.stat = !!opts.stat\n    this.ignore = opts.ignore\n\n    if (this.withFileTypes && this.absolute !== undefined) {\n      throw new Error('cannot set absolute and withFileTypes:true')\n    }\n\n    if (typeof pattern === 'string') {\n      pattern = [pattern]\n    }\n\n    this.windowsPathsNoEscape =\n      !!opts.windowsPathsNoEscape ||\n      (opts as { allowWindowsEscape?: boolean }).allowWindowsEscape ===\n        false\n\n    if (this.windowsPathsNoEscape) {\n      pattern = pattern.map(p => p.replace(/\\\\/g, '/'))\n    }\n\n    if (this.matchBase) {\n      if (opts.noglobstar) {\n        throw new TypeError('base matching requires globstar')\n      }\n      pattern = pattern.map(p => (p.includes('/') ? p : `./**/${p}`))\n    }\n\n    this.pattern = pattern\n\n    this.platform = opts.platform || defaultPlatform\n    this.opts = { ...opts, platform: this.platform }\n    if (opts.scurry) {\n      this.scurry = opts.scurry\n      if (\n        opts.nocase !== undefined &&\n        opts.nocase !== opts.scurry.nocase\n      ) {\n        throw new Error('nocase option contradicts provided scurry option')\n      }\n    } else {\n      const Scurry =\n        opts.platform === 'win32' ? PathScurryWin32\n        : opts.platform === 'darwin' ? PathScurryDarwin\n        : opts.platform ? PathScurryPosix\n        : PathScurry\n      this.scurry = new Scurry(this.cwd, {\n        nocase: opts.nocase,\n        fs: opts.fs,\n      })\n    }\n    this.nocase = this.scurry.nocase\n\n    // If you do nocase:true on a case-sensitive file system, then\n    // we need to use regexps instead of strings for non-magic\n    // path portions, because statting `aBc` won't return results\n    // for the file `AbC` for example.\n    const nocaseMagicOnly =\n      this.platform === 'darwin' || this.platform === 'win32'\n\n    const mmo: MinimatchOptions = {\n      // default nocase based on platform\n      ...opts,\n      dot: this.dot,\n      matchBase: this.matchBase,\n      nobrace: this.nobrace,\n      nocase: this.nocase,\n      nocaseMagicOnly,\n      nocomment: true,\n      noext: this.noext,\n      nonegate: true,\n      optimizationLevel: 2,\n      platform: this.platform,\n      windowsPathsNoEscape: this.windowsPathsNoEscape,\n      debug: !!this.opts.debug,\n    }\n\n    const mms = this.pattern.map(p => new Minimatch(p, mmo))\n    const [matchSet, globParts] = mms.reduce(\n      (set: [MatchSet, GlobParts], m) => {\n        set[0].push(...m.set)\n        set[1].push(...m.globParts)\n        return set\n      },\n      [[], []],\n    )\n    this.patterns = matchSet.map((set, i) => {\n      const g = globParts[i]\n      /* c8 ignore start */\n      if (!g) throw new Error('invalid pattern object')\n      /* c8 ignore stop */\n      return new Pattern(set, g, 0, this.platform)\n    })\n  }\n\n  /**\n   * Returns a Promise that resolves to the results array.\n   */\n  async walk(): Promise<Results<Opts>>\n  async walk(): Promise<(string | Path)[]> {\n    // Walkers always return array of Path objects, so we just have to\n    // coerce them into the right shape.  It will have already called\n    // realpath() if the option was set to do so, so we know that's cached.\n    // start out knowing the cwd, at least\n    return [\n      ...(await new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity ?\n            this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n        includeChildMatches: this.includeChildMatches,\n      }).walk()),\n    ]\n  }\n\n  /**\n   * synchronous {@link Glob.walk}\n   */\n  walkSync(): Results<Opts>\n  walkSync(): (string | Path)[] {\n    return [\n      ...new GlobWalker(this.patterns, this.scurry.cwd, {\n        ...this.opts,\n        maxDepth:\n          this.maxDepth !== Infinity ?\n            this.maxDepth + this.scurry.cwd.depth()\n          : Infinity,\n        platform: this.platform,\n        nocase: this.nocase,\n        includeChildMatches: this.includeChildMatches,\n      }).walkSync(),\n    ]\n  }\n\n  /**\n   * Stream results asynchronously.\n   */\n  stream(): Minipass<Result<Opts>, Result<Opts>>\n  stream(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity ?\n          this.maxDepth + this.scurry.cwd.depth()\n        : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n      includeChildMatches: this.includeChildMatches,\n    }).stream()\n  }\n\n  /**\n   * Stream results synchronously.\n   */\n  streamSync(): Minipass<Result<Opts>, Result<Opts>>\n  streamSync(): Minipass<string | Path, string | Path> {\n    return new GlobStream(this.patterns, this.scurry.cwd, {\n      ...this.opts,\n      maxDepth:\n        this.maxDepth !== Infinity ?\n          this.maxDepth + this.scurry.cwd.depth()\n        : Infinity,\n      platform: this.platform,\n      nocase: this.nocase,\n      includeChildMatches: this.includeChildMatches,\n    }).streamSync()\n  }\n\n  /**\n   * Default sync iteration function. Returns a Generator that\n   * iterates over the results.\n   */\n  iterateSync(): Generator<Result<Opts>, void, void> {\n    return this.streamSync()[Symbol.iterator]()\n  }\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  /**\n   * Default async iteration function. Returns an AsyncGenerator that\n   * iterates over the results.\n   */\n  iterate(): AsyncGenerator<Result<Opts>, void, void> {\n    return this.stream()[Symbol.asyncIterator]()\n  }\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n}\n", "/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * The reason why an item was added to the cache, passed\n   * to the {@link Inserter} methods.\n   *\n   * - `add`: the item was not found in the cache, and was added\n   * - `update`: the item was in the cache, with the same value provided\n   * - `replace`: the item was in the cache, and replaced\n   */\n  export type InsertReason = 'add' | 'update' | 'replace'\n\n  /**\n   * A method called upon item insertion, passed as the\n   * {@link OptionsBase.insert}\n   */\n  export type Inserter<K, V> = (\n    value: V,\n    key: K,\n    reason: InsertReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * Function that is called when new items are inserted into the cache,\n     * as `onInsert(value, key, reason)`.\n     *\n     * This can be useful if you need to perform actions when an item is\n     * added, such as logging or tracking insertions.\n     *\n     * Unlike some other options, this may _not_ be overridden by passing\n     * an option to `set()`, for performance and consistency reasons.\n     */\n    onInsert?: Inserter<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown> {\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #onInsert?: LRUCache.Inserter<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n  #hasOnInsert: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.onInsert} (read-only)\n   */\n  get onInsert() {\n    return this.#onInsert\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      onInsert,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof onInsert === 'function') {\n      this.#onInsert = onInsert\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasOnInsert = !!this.#onInsert\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n      if (this.#hasOnInsert) {\n        this.#onInsert?.(v as V, k, 'add')\n      }\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n\n      if (this.#hasOnInsert) {\n        this.onInsert?.(v as V, k, v === oldVal ? 'update' : 'replace');\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link LRUCache.OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'node:path'\n\nimport { fileURLToPath } from 'node:url'\n\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nimport * as actualFS from 'node:fs'\n\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\n\nimport { lstat, readdir, readlink, realpath } from 'node:fs/promises'\n\nimport { Minipass } from 'minipass'\nimport type { Dirent, Stats } from 'node:fs'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true },\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS ?\n    defaultFS\n  : {\n      ...defaultFS,\n      ...fsOption,\n      promises: {\n        ...defaultFS.promises,\n        ...(fsOption.promises || {}),\n      },\n    }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile() ? IFREG\n  : s.isDirectory() ? IFDIR\n  : s.isSymbolicLink() ? IFLNK\n  : s.isCharacterDevice() ? IFCHR\n  : s.isBlockDevice() ? IFBLK\n  : s.isSocket() ? IFSOCK\n  : s.isFIFO() ? IFIFO\n  : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * boolean indicating that this path is the current working directory\n   * of the PathScurry collection that contains it.\n   */\n  isCWD: boolean = false\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['parentPath'] refers to the path of the\n   * directory that was passed to readdir. For root entries, it's the path\n   * to the entry itself.\n   */\n  get parentPath(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n   * this property refers to the *parent* path, not the path object itself.\n   *\n   * @deprecated\n   */\n  get path(): string {\n    return this.parentPath\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase =\n      rootPath ?\n        this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name =\n      this.nocase ? normalizeNocase(pathPart) : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath =\n      this.#fullpath ? this.#fullpath + s + pathPart : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.isCWD) return ''\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.isCWD) return ''\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return (\n      this.isUnknown() ? 'Unknown'\n      : this.isDirectory() ? 'Directory'\n      : this.isFile() ? 'File'\n      : this.isSymbolicLink() ? 'SymbolicLink'\n      : this.isFIFO() ? 'FIFO'\n      : this.isCharacterDevice() ? 'CharacterDevice'\n      : this.isBlockDevice() ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket() ? 'Socket'\n      : 'Unknown'\n    )\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase ?\n        this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = (await this.parent.realpath())?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.realpathSync()?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      const c = children[p]\n      if (c) c.#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name =\n        this.nocase ? normalizeNocase(e.name) : normalize(e.name)\n      if (name !== pchild!.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild!, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children,\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[],\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false,\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res),\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean,\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n    oldCwd.isCWD = false\n    this.isCWD = true\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this,\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {},\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor',\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd,\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void,\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next(),\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {},\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false,\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r,\n                    ),\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true),\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32' ? PathScurryWin32\n  : process.platform === 'darwin' ? PathScurryDarwin\n  : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n", "const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'node:events'\nimport Stream from 'node:stream'\nimport { StringDecoder } from 'node:string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> =\n    | ObjectModeOptions\n    | (T extends string\n        ? EncodingOptions\n        : T extends Buffer\n        ? BufferOptions\n        : SharedOptions)\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args:\n      | [Minipass.ObjectModeOptions]\n      | (RType extends Buffer\n          ? [] | [Minipass.Options<RType>]\n          : [Minipass.Options<RType>])\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): this {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data as RType) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n", "// this is just a very light wrapper around 2 arrays with an offset index\n\nimport { GLOBSTAR } from 'minimatch'\nexport type MMPattern = string | RegExp | typeof GLOBSTAR\n\n// an array of length >= 1\nexport type PatternList = [p: MMPattern, ...rest: MMPattern[]]\nexport type UNCPatternList = [\n  p0: '',\n  p1: '',\n  p2: string,\n  p3: string,\n  ...rest: MMPattern[],\n]\nexport type DrivePatternList = [p0: string, ...rest: MMPattern[]]\nexport type AbsolutePatternList = [p0: '', ...rest: MMPattern[]]\nexport type GlobList = [p: string, ...rest: string[]]\n\nconst isPatternList = (pl: MMPattern[]): pl is PatternList =>\n  pl.length >= 1\nconst isGlobList = (gl: string[]): gl is GlobList => gl.length >= 1\n\n/**\n * An immutable-ish view on an array of glob parts and their parsed\n * results\n */\nexport class Pattern {\n  readonly #patternList: PatternList\n  readonly #globList: GlobList\n  readonly #index: number\n  readonly length: number\n  readonly #platform: NodeJS.Platform\n  #rest?: Pattern | null\n  #globString?: string\n  #isDrive?: boolean\n  #isUNC?: boolean\n  #isAbsolute?: boolean\n  #followGlobstar: boolean = true\n\n  constructor(\n    patternList: MMPattern[],\n    globList: string[],\n    index: number,\n    platform: NodeJS.Platform,\n  ) {\n    if (!isPatternList(patternList)) {\n      throw new TypeError('empty pattern list')\n    }\n    if (!isGlobList(globList)) {\n      throw new TypeError('empty glob list')\n    }\n    if (globList.length !== patternList.length) {\n      throw new TypeError('mismatched pattern list and glob list lengths')\n    }\n    this.length = patternList.length\n    if (index < 0 || index >= this.length) {\n      throw new TypeError('index out of range')\n    }\n    this.#patternList = patternList\n    this.#globList = globList\n    this.#index = index\n    this.#platform = platform\n\n    // normalize root entries of absolute patterns on initial creation.\n    if (this.#index === 0) {\n      // c: => ['c:/']\n      // C:/ => ['C:/']\n      // C:/x => ['C:/', 'x']\n      // //host/share => ['//host/share/']\n      // //host/share/ => ['//host/share/']\n      // //host/share/x => ['//host/share/', 'x']\n      // /etc => ['/', 'etc']\n      // / => ['/']\n      if (this.isUNC()) {\n        // '' / '' / 'host' / 'share'\n        const [p0, p1, p2, p3, ...prest] = this.#patternList\n        const [g0, g1, g2, g3, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = [p0, p1, p2, p3, ''].join('/')\n        const g = [g0, g1, g2, g3, ''].join('/')\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      } else if (this.isDrive() || this.isAbsolute()) {\n        const [p1, ...prest] = this.#patternList\n        const [g1, ...grest] = this.#globList\n        if (prest[0] === '') {\n          // ends in /\n          prest.shift()\n          grest.shift()\n        }\n        const p = (p1 as string) + '/'\n        const g = g1 + '/'\n        this.#patternList = [p, ...prest]\n        this.#globList = [g, ...grest]\n        this.length = this.#patternList.length\n      }\n    }\n  }\n\n  /**\n   * The first entry in the parsed list of patterns\n   */\n  pattern(): MMPattern {\n    return this.#patternList[this.#index] as MMPattern\n  }\n\n  /**\n   * true of if pattern() returns a string\n   */\n  isString(): boolean {\n    return typeof this.#patternList[this.#index] === 'string'\n  }\n  /**\n   * true of if pattern() returns GLOBSTAR\n   */\n  isGlobstar(): boolean {\n    return this.#patternList[this.#index] === GLOBSTAR\n  }\n  /**\n   * true if pattern() returns a regexp\n   */\n  isRegExp(): boolean {\n    return this.#patternList[this.#index] instanceof RegExp\n  }\n\n  /**\n   * The /-joined set of glob parts that make up this pattern\n   */\n  globString(): string {\n    return (this.#globString =\n      this.#globString ||\n      (this.#index === 0 ?\n        this.isAbsolute() ?\n          this.#globList[0] + this.#globList.slice(1).join('/')\n        : this.#globList.join('/')\n      : this.#globList.slice(this.#index).join('/')))\n  }\n\n  /**\n   * true if there are more pattern parts after this one\n   */\n  hasMore(): boolean {\n    return this.length > this.#index + 1\n  }\n\n  /**\n   * The rest of the pattern after this part, or null if this is the end\n   */\n  rest(): Pattern | null {\n    if (this.#rest !== undefined) return this.#rest\n    if (!this.hasMore()) return (this.#rest = null)\n    this.#rest = new Pattern(\n      this.#patternList,\n      this.#globList,\n      this.#index + 1,\n      this.#platform,\n    )\n    this.#rest.#isAbsolute = this.#isAbsolute\n    this.#rest.#isUNC = this.#isUNC\n    this.#rest.#isDrive = this.#isDrive\n    return this.#rest\n  }\n\n  /**\n   * true if the pattern represents a //unc/path/ on windows\n   */\n  isUNC(): boolean {\n    const pl = this.#patternList\n    return this.#isUNC !== undefined ?\n        this.#isUNC\n      : (this.#isUNC =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          pl[0] === '' &&\n          pl[1] === '' &&\n          typeof pl[2] === 'string' &&\n          !!pl[2] &&\n          typeof pl[3] === 'string' &&\n          !!pl[3])\n  }\n\n  // pattern like C:/...\n  // split = ['C:', ...]\n  // XXX: would be nice to handle patterns like `c:*` to test the cwd\n  // in c: for *, but I don't know of a way to even figure out what that\n  // cwd is without actually chdir'ing into it?\n  /**\n   * True if the pattern starts with a drive letter on Windows\n   */\n  isDrive(): boolean {\n    const pl = this.#patternList\n    return this.#isDrive !== undefined ?\n        this.#isDrive\n      : (this.#isDrive =\n          this.#platform === 'win32' &&\n          this.#index === 0 &&\n          this.length > 1 &&\n          typeof pl[0] === 'string' &&\n          /^[a-z]:$/i.test(pl[0]))\n  }\n\n  // pattern = '/' or '/...' or '/x/...'\n  // split = ['', ''] or ['', ...] or ['', 'x', ...]\n  // Drive and UNC both considered absolute on windows\n  /**\n   * True if the pattern is rooted on an absolute path\n   */\n  isAbsolute(): boolean {\n    const pl = this.#patternList\n    return this.#isAbsolute !== undefined ?\n        this.#isAbsolute\n      : (this.#isAbsolute =\n          (pl[0] === '' && pl.length > 1) ||\n          this.isDrive() ||\n          this.isUNC())\n  }\n\n  /**\n   * consume the root of the pattern, and return it\n   */\n  root(): string {\n    const p = this.#patternList[0]\n    return (\n        typeof p === 'string' && this.isAbsolute() && this.#index === 0\n      ) ?\n        p\n      : ''\n  }\n\n  /**\n   * Check to see if the current globstar pattern is allowed to follow\n   * a symbolic link.\n   */\n  checkFollowGlobstar(): boolean {\n    return !(\n      this.#index === 0 ||\n      !this.isGlobstar() ||\n      !this.#followGlobstar\n    )\n  }\n\n  /**\n   * Mark that the current globstar pattern is following a symbolic link\n   */\n  markFollowGlobstar(): boolean {\n    if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)\n      return false\n    this.#followGlobstar = false\n    return true\n  }\n}\n", "// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n  add?: (ignore: string) => void\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  (\n    typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n  ) ?\n    process.platform\n  : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n  platform: NodeJS.Platform\n  mmopts: MinimatchOptions\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts,\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    this.platform = platform\n    this.mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n    for (const ign of ignored) this.add(ign)\n  }\n\n  add(ign: string) {\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    const mm = new Minimatch(ign, this.mmopts)\n    for (let i = 0; i < mm.set.length; i++) {\n      const parsed = mm.set[i]\n      const globParts = mm.globParts[i]\n      /* c8 ignore start */\n      if (!parsed || !globParts) {\n        throw new Error('invalid pattern object')\n      }\n      // strip off leading ./ portions\n      // https://github.com/isaacs/node-glob/issues/570\n      while (parsed[0] === '.' && globParts[0] === '.') {\n        parsed.shift()\n        globParts.shift()\n      }\n      /* c8 ignore stop */\n      const p = new Pattern(parsed, globParts, 0, this.platform)\n      const m = new Minimatch(p.globString(), this.mmopts)\n      const children = globParts[globParts.length - 1] === '**'\n      const absolute = p.isAbsolute()\n      if (absolute) this.absolute.push(m)\n      else this.relative.push(m)\n      if (children) {\n        if (absolute) this.absoluteChildren.push(m)\n        else this.relativeChildren.push(m)\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n", "// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache =\n      hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined ?\n            this.opts.root\n          : root,\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n", "/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n  includeChildMatches?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Path\n  : O extends GWOFileTypesFalse ? string\n  : O extends GWOFileTypesUnset ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Set<Path>\n  : O extends GWOFileTypesFalse ? Set<string>\n  : O extends GWOFileTypesUnset ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> = Minipass<\n  Result<O>,\n  Result<O>\n>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts,\n): IgnoreLike =>\n  typeof ignore === 'string' ? new Ignore([ignore], opts)\n  : Array.isArray(ignore) ? new Ignore(ignore, opts)\n  : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n  includeChildMatches: boolean\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    this.includeChildMatches = opts.includeChildMatches !== false\n    if (opts.ignore || !this.includeChildMatches) {\n      this.#ignore = makeIgnore(opts.ignore ?? [], opts)\n      if (\n        !this.includeChildMatches &&\n        typeof this.#ignore.add !== 'function'\n      ) {\n        const m = 'cannot ignore child matches, ignore lacks add() method.'\n        throw new Error(m)\n      }\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? await e.lstat() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath()\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat()\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return (\n        e &&\n          (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n          (!ifDir || e.canReaddir()) &&\n          (!this.opts.nodir || !e.isDirectory()) &&\n          (!this.opts.nodir ||\n            !this.opts.follow ||\n            !e.isSymbolicLink() ||\n            !e.realpathCached()?.isDirectory()) &&\n          !this.#ignored(e)\n      ) ?\n        e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? e.lstatSync() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync()\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync()\n      }\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    // we know we have an ignore if this is false, but TS doesn't\n    if (!this.includeChildMatches && this.#ignore?.add) {\n      const ign = `${e.relativePosix()}/**`\n      this.#ignore.add(ign)\n    }\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n          '.' + this.#sep\n        : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true,\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb),\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  matches = new Set<Result<O>>()\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Set<Result<O>>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Set<Result<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  results: Minipass<Result<O>, Result<O>>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass<Result<O>, Result<O>>({\n      signal: this.signal,\n      objectMode: true,\n    })\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n", "import { Minimatch } from 'minimatch'\nimport { GlobOptions } from './glob.js'\n\n/**\n * Return true if the patterns provided contain any magic glob characters,\n * given the options provided.\n *\n * Brace expansion is not considered \"magic\" unless the `magicalBraces` option\n * is set, as brace expansion just turns one string into an array of strings.\n * So a pattern like `'x{a,b}y'` would return `false`, because `'xay'` and\n * `'xby'` both do not contain any magic glob characters, and it's treated the\n * same as if you had called it on `['xay', 'xby']`. When `magicalBraces:true`\n * is in the options, brace expansion _is_ treated as a pattern having magic.\n */\nexport const hasMagic = (\n  pattern: string | string[],\n  options: GlobOptions = {},\n): boolean => {\n  if (!Array.isArray(pattern)) {\n    pattern = [pattern]\n  }\n  for (const p of pattern) {\n    if (new Minimatch(p, options).hasMagic()) return true\n  }\n  return false\n}\n", "import { escape, unescape } from 'minimatch'\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nimport { Glob } from './glob.js'\nimport { hasMagic } from './has-magic.js'\n\nexport { escape, unescape } from 'minimatch'\nexport type {\n  FSOption,\n  Path,\n  WalkOptions,\n  WalkOptionsWithFileTypesTrue,\n  WalkOptionsWithFileTypesUnset,\n} from 'path-scurry'\nexport { Glob } from './glob.js'\nexport type {\n  GlobOptions,\n  GlobOptionsWithFileTypesFalse,\n  GlobOptionsWithFileTypesTrue,\n  GlobOptionsWithFileTypesUnset,\n} from './glob.js'\nexport { hasMagic } from './has-magic.js'\nexport { Ignore } from './ignore.js'\nexport type { IgnoreLike } from './ignore.js'\nexport type { MatchStream } from './walker.js'\n\n/**\n * Syncronous form of {@link globStream}. Will read all the matches as fast as\n * you consume them, even all in a single tick if you consume them immediately,\n * but will still respond to backpressure if they're not consumed immediately.\n */\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Minipass<Path, Path>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesUnset,\n): Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStreamSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).streamSync()\n}\n\n/**\n * Return a stream that emits all the strings or `Path` objects and\n * then emits `end` when completed.\n */\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Minipass<Path, Path>\nexport function globStream(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions,\n): Minipass<Path, Path> | Minipass<string, string>\nexport function globStream(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).stream()\n}\n\n/**\n * Synchronous form of {@link glob}\n */\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Path[]\nexport function globSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Path[] | string[]\nexport function globSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).walkSync()\n}\n\n/**\n * Perform an asynchronous glob search for the pattern(s) specified. Returns\n * [Path](https://isaacs.github.io/path-scurry/classes/PathBase) objects if the\n * {@link withFileTypes} option is set to `true`. See {@link GlobOptions} for\n * full option descriptions.\n */\nasync function glob_(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Promise<Path[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Promise<string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions,\n): Promise<Path[] | string[]>\nasync function glob_(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).walk()\n}\n\n/**\n * Return a sync iterator for walking glob pattern matches.\n */\nexport function globIterateSync(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): Generator<Path, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions,\n): Generator<Path, void, void> | Generator<string, void, void>\nexport function globIterateSync(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).iterateSync()\n}\n\n/**\n * Return an async iterator for walking glob pattern matches.\n */\nexport function globIterate(\n  pattern: string | string[],\n  options?: GlobOptionsWithFileTypesUnset | undefined,\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesTrue,\n): AsyncGenerator<Path, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptionsWithFileTypesFalse,\n): AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions,\n): AsyncGenerator<Path, void, void> | AsyncGenerator<string, void, void>\nexport function globIterate(\n  pattern: string | string[],\n  options: GlobOptions = {},\n) {\n  return new Glob(pattern, options).iterate()\n}\n\n// aliases: glob.sync.stream() glob.stream.sync() glob.sync() etc\nexport const streamSync = globStreamSync\nexport const stream = Object.assign(globStream, { sync: globStreamSync })\nexport const iterateSync = globIterateSync\nexport const iterate = Object.assign(globIterate, {\n  sync: globIterateSync,\n})\nexport const sync = Object.assign(globSync, {\n  stream: globStreamSync,\n  iterate: globIterateSync,\n})\n\nexport const glob = Object.assign(glob_, {\n  glob: glob_,\n  globSync,\n  sync,\n  globStream,\n  stream,\n  globStreamSync,\n  streamSync,\n  globIterate,\n  iterate,\n  globIterateSync,\n  iterateSync,\n  Glob,\n  hasMagic,\n  escape,\n  unescape,\n})\nglob.glob = glob\n", "import { execFileSync } from 'child_process';\nimport { existsSync, readdirSync } from 'fs';\nimport { join } from 'path';\n\nimport { quote } from 'shell-quote';\n\nimport { fileExists } from '../../filesystem';\nimport { cdsExtractorLog } from '../../logging';\n\n/**\n * Cache for CDS command test results to avoid running the same CLI commands repeatedly.\n */\ninterface CdsCommandCache {\n  /** Map of command strings to their test results */\n  commandResults: Map<string, { works: boolean; version?: string; error?: string }>;\n  /** Available cache directories discovered during testing */\n  availableCacheDirs: string[];\n  /** Global command test results */\n  globalCommand?: string;\n  /** Whether cache has been initialized */\n  initialized: boolean;\n}\n\n// Global cache instance to share results across all calls\nconst cdsCommandCache: CdsCommandCache = {\n  commandResults: new Map(),\n  availableCacheDirs: [],\n  initialized: false,\n};\n\n/**\n * Determine the `cds` command to use based on the environment and cache directory.\n *\n * This function uses a caching strategy to minimize repeated CLI command testing:\n * - Initializes a global cache on first call\n * - Tests global commands once and caches results\n * - Discovers all available cache directories upfront\n * - Reuses test results across multiple calls\n */\nexport function determineCdsCommand(cacheDir: string | undefined, sourceRoot: string): string {\n  try {\n    // Always use the efficient path - debug information is collected separately\n    return getBestCdsCommand(cacheDir, sourceRoot);\n  } catch (error) {\n    const errorMessage = `Failed to determine CDS command: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n    throw new Error(errorMessage);\n  }\n}\n\n/**\n * Discover all available cache directories in the source tree\n * @param sourceRoot The source root directory\n * @returns Array of cache directory paths\n */\nfunction discoverAvailableCacheDirs(sourceRoot: string): string[] {\n  if (cdsCommandCache.availableCacheDirs.length > 0) {\n    return cdsCommandCache.availableCacheDirs;\n  }\n\n  const cacheRootDir = join(sourceRoot, '.cds-extractor-cache');\n  const availableDirs: string[] = [];\n\n  try {\n    if (existsSync(cacheRootDir)) {\n      const entries = readdirSync(cacheRootDir, { withFileTypes: true });\n      for (const entry of entries) {\n        if (entry.isDirectory() && entry.name.startsWith('cds-')) {\n          const cacheDir = join(cacheRootDir, entry.name);\n          const cdsBin = join(cacheDir, 'node_modules', '.bin', 'cds');\n          if (fileExists(cdsBin)) {\n            availableDirs.push(cacheDir);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    cdsExtractorLog('debug', `Failed to discover cache directories: ${String(error)}`);\n  }\n\n  cdsCommandCache.availableCacheDirs = availableDirs;\n  return availableDirs;\n}\n\n/**\n * Get the best CDS command for a specific cache directory\n * @param cacheDir Optional specific cache directory\n * @param sourceRoot The source root directory\n * @returns The best CDS command to use\n */\nfunction getBestCdsCommand(cacheDir: string | undefined, sourceRoot: string): string {\n  // Initialize cache if needed\n  initializeCdsCommandCache(sourceRoot);\n\n  // If a specific cache directory is provided and valid, prefer it\n  if (cacheDir) {\n    const localCdsBin = join(cacheDir, 'node_modules', '.bin', 'cds');\n    if (fileExists(localCdsBin)) {\n      const result = testCdsCommand(localCdsBin, sourceRoot, true);\n      if (result.works) {\n        return localCdsBin;\n      }\n    }\n  }\n\n  // Try any available cache directories\n  for (const availableCacheDir of cdsCommandCache.availableCacheDirs) {\n    const localCdsBin = join(availableCacheDir, 'node_modules', '.bin', 'cds');\n    const result = testCdsCommand(localCdsBin, sourceRoot, true);\n    if (result.works) {\n      return localCdsBin;\n    }\n  }\n\n  // Fall back to global command\n  if (cdsCommandCache.globalCommand) {\n    return cdsCommandCache.globalCommand;\n  }\n\n  // Final fallback: test remaining npx options\n  const fallbackCommands = ['npx -y --package @sap/cds cds', 'npx --yes @sap/cds-dk cds'];\n\n  for (const command of fallbackCommands) {\n    const result = testCdsCommand(command, sourceRoot, true);\n    if (result.works) {\n      return command;\n    }\n  }\n\n  // Return the default fallback even if it doesn't work, as tests expect this behavior\n  return 'npx -y --package @sap/cds-dk cds';\n}\n\n/**\n * Initialize the CDS command cache by testing global commands\n * @param sourceRoot The source root directory\n */\nfunction initializeCdsCommandCache(sourceRoot: string): void {\n  if (cdsCommandCache.initialized) {\n    return;\n  }\n\n  cdsExtractorLog('info', 'Initializing CDS command cache...');\n\n  // Test global commands first (most commonly used)\n  const globalCommands = ['cds', 'npx -y --package @sap/cds-dk cds'];\n\n  for (const command of globalCommands) {\n    const result = testCdsCommand(command, sourceRoot, true); // Silent testing\n    if (result.works) {\n      cdsCommandCache.globalCommand = command;\n      cdsExtractorLog(\n        'info',\n        `Found working global CDS command: ${command} (v${result.version ?? 'unknown'})`,\n      );\n      break;\n    }\n  }\n\n  // Discover available cache directories\n  const cacheDirs = discoverAvailableCacheDirs(sourceRoot);\n  if (cacheDirs.length > 0) {\n    cdsExtractorLog(\n      'info',\n      `Discovered ${cacheDirs.length} CDS cache director${cacheDirs.length === 1 ? 'y' : 'ies'}`,\n    );\n  }\n\n  cdsCommandCache.initialized = true;\n}\n\n/**\n * Reset the command cache - primarily for testing\n */\nexport function resetCdsCommandCache(): void {\n  cdsCommandCache.commandResults.clear();\n  cdsCommandCache.availableCacheDirs = [];\n  cdsCommandCache.globalCommand = undefined;\n  cdsCommandCache.initialized = false;\n}\n\n/**\n * Check if a CDS command is available and working\n * @param command The command to test\n * @param sourceRoot The source root directory to use as cwd when testing the command\n * @param silent Whether to suppress logging of test failures\n * @returns Object with test result and version information\n */\nfunction testCdsCommand(\n  command: string,\n  sourceRoot: string,\n  silent: boolean = false,\n): { works: boolean; version?: string; error?: string } {\n  // Check cache first\n  const cachedResult = cdsCommandCache.commandResults.get(command);\n  if (cachedResult) {\n    return cachedResult;\n  }\n\n  try {\n    // Try to run the command with --version to see if it works\n    // CRITICAL: Use sourceRoot as cwd and clean environment to avoid conflicts\n    let result: string;\n\n    const cleanEnv = {\n      ...process.env,\n      // Remove any CodeQL-specific environment variables that might interfere\n      CODEQL_EXTRACTOR_CDS_WIP_DATABASE: undefined,\n      CODEQL_RUNNER: undefined,\n    };\n\n    if (command.includes('node ')) {\n      // For node commands, we need to split and execute properly\n      const parts = command.split(' ');\n      const nodeExecutable = parts[0]; // 'node'\n      const scriptPath = parts[1].replace(/\"/g, ''); // Remove quotes from path\n      result = execFileSync(nodeExecutable, [scriptPath, '--version'], {\n        encoding: 'utf8',\n        stdio: 'pipe',\n        timeout: 5000, // Reduced timeout for faster failure\n        cwd: sourceRoot,\n        env: cleanEnv,\n      }).toString();\n    } else {\n      // Use shell-quote to properly escape the command and prevent injection\n      const escapedCommand = quote([command, '--version']);\n      result = execFileSync('sh', ['-c', escapedCommand], {\n        encoding: 'utf8',\n        stdio: 'pipe',\n        timeout: 5000, // Reduced timeout for faster failure\n        cwd: sourceRoot,\n        env: cleanEnv,\n      }).toString();\n    }\n\n    // Extract version from output (typically in format \"@sap/cds-dk: 6.1.3\" or just \"6.1.3\")\n    const versionMatch = result.match(/(\\d+\\.\\d+\\.\\d+)/);\n    const version = versionMatch ? versionMatch[1] : undefined;\n\n    const testResult = { works: true, version };\n    cdsCommandCache.commandResults.set(command, testResult);\n    return testResult;\n  } catch (error) {\n    const errorMessage = String(error);\n    if (!silent) {\n      cdsExtractorLog('debug', `CDS command test failed for '${command}': ${errorMessage}`);\n    }\n\n    const testResult = { works: false, error: errorMessage };\n    cdsCommandCache.commandResults.set(command, testResult);\n    return testResult;\n  }\n}\n", "import { existsSync, readdirSync, renameSync, statSync } from 'fs';\nimport { format, join, parse } from 'path';\n\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Check if a directory exists\n * @param dirPath Path to the directory to check\n * @returns True if the directory exists, false otherwise\n */\nexport function dirExists(dirPath: string): boolean {\n  return existsSync(dirPath) && statSync(dirPath).isDirectory();\n}\n\n/**\n * Check if a file exists and can be read\n * @param filePath Path to the file to check\n * @returns True if the file exists and can be read, false otherwise\n */\nexport function fileExists(filePath: string): boolean {\n  return existsSync(filePath) && statSync(filePath).isFile();\n}\n\n/**\n * Recursively renames all .json files to .cds.json in the given directory and\n * its subdirectories, except for those that already have .cds.json extension.\n *\n * @param {string} dirPath - The directory path to start recursion from\n */\nexport function recursivelyRenameJsonFiles(dirPath: string): void {\n  // Make sure the directory exists\n  if (!dirExists(dirPath)) {\n    cdsExtractorLog('info', `Directory not found: ${dirPath}`);\n    return;\n  }\n  cdsExtractorLog('info', `Processing JSON files in directory: ${dirPath}`);\n\n  // Get all entries in the directory\n  const entries = readdirSync(dirPath, { withFileTypes: true });\n\n  for (const entry of entries) {\n    const fullPath = join(dirPath, entry.name);\n\n    if (entry.isDirectory()) {\n      // Recursively process subdirectories\n      recursivelyRenameJsonFiles(fullPath);\n    } else if (\n      entry.isFile() &&\n      entry.name.endsWith('.json') &&\n      !entry.name.endsWith('.cds.json')\n    ) {\n      // Rename .json files to .cds.json\n      const newPath = format({ ...parse(fullPath), base: '', ext: '.cds.json' });\n      renameSync(fullPath, newPath);\n      cdsExtractorLog('info', `Renamed CDS output file from ${fullPath} to ${newPath}`);\n    }\n  }\n}\n", "import type { LogLevel } from './types';\n\n/**\n * Source root directory for logging context.\n */\nlet sourceRootDirectory: string | undefined;\n\n/**\n * Unique session ID for this CDS extractor run to help distinguish\n * between multiple concurrent or sequential runs in logs.\n * Uses the extractor start timestamp for uniqueness.\n */\nconst sessionId = Date.now().toString();\n\n/**\n * Start time of the CDS extractor session for performance tracking.\n */\nconst extractorStartTime = Date.now();\n\n/**\n * Performance tracking state for timing critical operations.\n */\nconst performanceTracking = new Map<string, number>();\n\n/**\n * Unified logging function for the CDS extractor. Provides consistent\n * log formatting with level prefixes, elapsed time, and session IDs.\n *\n * @param level - The log level ('debug', 'info', 'warn', 'error')\n * @param message - The primary message or data to log\n * @param optionalParams - Additional parameters to log (same as console.log)\n */\nexport function cdsExtractorLog(\n  level: LogLevel,\n  message: unknown,\n  ...optionalParams: unknown[]\n): void {\n  if (!sourceRootDirectory) {\n    throw new Error('Source root directory is not set. Call setSourceRootDirectory() first.');\n  }\n\n  const currentTime = Date.now();\n  const elapsedMs = currentTime - extractorStartTime;\n  const levelPrefix = `[CDS-${sessionId} ${elapsedMs}] ${level.toUpperCase()}: `;\n\n  // Select the appropriate console function based on log level\n  switch (level) {\n    case 'debug':\n    case 'info':\n      if (typeof message === 'string') {\n        console.log(levelPrefix + message, ...optionalParams);\n      } else {\n        console.log(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    case 'warn':\n      if (typeof message === 'string') {\n        console.warn(levelPrefix + message, ...optionalParams);\n      } else {\n        console.warn(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    case 'error':\n      if (typeof message === 'string') {\n        console.error(levelPrefix + message, ...optionalParams);\n      } else {\n        console.error(levelPrefix, message, ...optionalParams);\n      }\n      break;\n    default:\n      // This should never happen due to TypeScript typing\n      throw new Error(`Invalid log level: ${String(level)}`);\n  }\n}\n/**\n * Calculates elapsed time from start and formats it with appropriate units.\n *\n * @param startTime - The start timestamp in milliseconds\n * @param endTime - The end timestamp in milliseconds (defaults to current time)\n * @returns Formatted duration string\n */\nfunction formatDuration(startTime: number, endTime: number = Date.now()): string {\n  const durationMs = endTime - startTime;\n\n  if (durationMs < 1000) {\n    return `${durationMs}ms`;\n  } else if (durationMs < 60000) {\n    return `${(durationMs / 1000).toFixed(2)}s`;\n  } else {\n    const minutes = Math.floor(durationMs / 60000);\n    const seconds = ((durationMs % 60000) / 1000).toFixed(2);\n    return `${minutes}m ${seconds}s`;\n  }\n}\n\n/**\n * Logs the start of the CDS extractor session with session information.\n *\n * @param sourceRoot - The source root directory being processed\n */\nexport function logExtractorStart(sourceRoot: string): void {\n  cdsExtractorLog('info', `=== CDS EXTRACTOR START [${sessionId}] ===`);\n  cdsExtractorLog('info', `Source Root: ${sourceRoot}`);\n}\n\n/**\n * Logs the end of the CDS extractor session with final performance summary.\n *\n * @param success - Whether the extraction completed successfully\n * @param additionalSummary - Optional additional summary information\n */\nexport function logExtractorStop(success: boolean = true, additionalSummary?: string): void {\n  const endTime = Date.now();\n  const totalDuration = formatDuration(extractorStartTime, endTime);\n  const status = success ? 'SUCCESS' : 'FAILURE';\n\n  if (additionalSummary) {\n    cdsExtractorLog('info', additionalSummary);\n  }\n\n  cdsExtractorLog('info', `=== CDS EXTRACTOR END [${sessionId}] - ${status} ===`);\n  cdsExtractorLog('info', `Total Duration: ${totalDuration}`);\n}\n\n/**\n * Logs a performance milestone with timing information.\n *\n * @param milestone - Description of the milestone reached\n * @param additionalInfo - Optional additional information to include\n */\nexport function logPerformanceMilestone(milestone: string, additionalInfo?: string): void {\n  const currentTime = Date.now();\n  const overallDuration = formatDuration(extractorStartTime, currentTime);\n  const info = additionalInfo ? ` - ${additionalInfo}` : '';\n  cdsExtractorLog('info', `MILESTONE: ${milestone} (after ${overallDuration})${info}`);\n}\n\n/**\n * Starts tracking performance for a named operation.\n *\n * @param operationName - Name of the operation to track\n */\nexport function logPerformanceTrackingStart(operationName: string): void {\n  performanceTracking.set(operationName, Date.now());\n  cdsExtractorLog('debug', `Started: ${operationName}`);\n}\n\n/**\n * Ends tracking performance for a named operation and logs the duration.\n *\n * @param operationName - Name of the operation to stop tracking\n */\nexport function logPerformanceTrackingStop(operationName: string): void {\n  const startTime = performanceTracking.get(operationName);\n  if (startTime) {\n    const duration = formatDuration(startTime);\n    performanceTracking.delete(operationName);\n    cdsExtractorLog('info', `Completed: ${operationName} (took ${duration})`);\n  } else {\n    cdsExtractorLog('warn', `No start time found for operation: ${operationName}`);\n  }\n}\n\n/**\n * Sets the source root directory for logging context.\n * This should typically be called once at the start of the CDS extractor.\n *\n * @param sourceRoot - The absolute path to the source root directory\n */\nexport function setSourceRootDirectory(sourceRoot: string): void {\n  sourceRootDirectory = sourceRoot;\n}\n", "import type { CdsDependencyGraph } from '../cds/parser';\n\n/**\n * Generate a comprehensive status report for the dependency graph\n * Supports both normal execution and debug modes\n */\nexport function generateStatusReport(dependencyGraph: CdsDependencyGraph): string {\n  const summary = dependencyGraph.statusSummary;\n  const lines: string[] = [];\n\n  lines.push('='.repeat(80));\n  lines.push(`CDS EXTRACTOR STATUS REPORT`);\n  lines.push('='.repeat(80));\n  lines.push('');\n\n  // Overall summary\n  lines.push('OVERALL SUMMARY:');\n  lines.push(`  Status: ${summary.overallSuccess ? 'SUCCESS' : 'FAILED'}`);\n  lines.push(`  Current Phase: ${dependencyGraph.currentPhase.toUpperCase()}`);\n  lines.push(`  Projects: ${summary.totalProjects}`);\n  lines.push(`  CDS Files: ${summary.totalCdsFiles}`);\n  lines.push(`  JSON Files Generated: ${summary.jsonFilesGenerated}`);\n  lines.push('');\n\n  // Compilation summary\n  lines.push('COMPILATION SUMMARY:');\n  lines.push(`  Total Tasks: ${summary.totalCompilationTasks}`);\n  lines.push(`  Successful: ${summary.successfulCompilations}`);\n  lines.push(`  Failed: ${summary.failedCompilations}`);\n  lines.push(`  Skipped: ${summary.skippedCompilations}`);\n  lines.push('');\n\n  // Performance metrics\n  lines.push('PERFORMANCE:');\n  lines.push(`  Total Duration: ${summary.performance.totalDurationMs}ms`);\n  lines.push(`  Parsing: ${summary.performance.parsingDurationMs}ms`);\n  lines.push(`  Compilation: ${summary.performance.compilationDurationMs}ms`);\n  lines.push(`  Extraction: ${summary.performance.extractionDurationMs}ms`);\n\n  // Add percentage breakdown if total duration > 0\n  if (summary.performance.totalDurationMs > 0) {\n    const parsingPct = Math.round(\n      (summary.performance.parsingDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n    const compilationPct = Math.round(\n      (summary.performance.compilationDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n    const extractionPct = Math.round(\n      (summary.performance.extractionDurationMs / summary.performance.totalDurationMs) * 100,\n    );\n\n    lines.push('  Breakdown:');\n    lines.push(`    Parsing: ${parsingPct}%`);\n    lines.push(`    Compilation: ${compilationPct}%`);\n    lines.push(`    Extraction: ${extractionPct}%`);\n  }\n  lines.push('');\n\n  // Errors and warnings\n  if (summary.criticalErrors.length > 0) {\n    lines.push('CRITICAL ERRORS:');\n    for (const error of summary.criticalErrors) {\n      lines.push(`  - ${error}`);\n    }\n    lines.push('');\n  }\n\n  if (summary.warnings.length > 0) {\n    lines.push('WARNINGS:');\n    for (const warning of summary.warnings) {\n      lines.push(`  - ${warning}`);\n    }\n    lines.push('');\n  }\n\n  lines.push('='.repeat(80));\n\n  return lines.join('\\n');\n}\n", "import { spawnSync, SpawnSyncOptions } from 'child_process';\nimport { resolve, join, delimiter, relative } from 'path';\n\nimport { globSync } from 'glob';\n\nimport { CdsCompilationResult } from './types';\nimport { getCdsVersion } from './version';\nimport { fileExists, dirExists, recursivelyRenameJsonFiles } from '../../filesystem';\nimport { cdsExtractorLog } from '../../logging';\nimport { BasicCdsProject } from '../parser/types';\n\n/**\n * Compiles a CDS file to JSON using robust, project-aware compilation only.\n * This function has been refactored to align with the autobuild.md vision by removing all\n * forms of individual file compilation and ensuring only project-aware compilation is used.\n *\n * For root files, this will compile them to their 1:1 .cds.json representation if and only\n * if the file is a true root file in a project.\n *\n * @param cdsFilePath The path to the CDS file to compile, relative to the `sourceRoot`.\n * @param sourceRoot The source root directory scanned by the CDS extractor.\n * CRITICAL: All spawned processes must use this as their cwd to ensure paths in generated\n * JSON are relative to sourceRoot.\n *\n * @param cdsCommand The actual shell command to use for `cds compile`.\n * @param cacheDir Full path to the cache directory where dependencies are stored.\n * @param projectMap Map of project directories to {@link BasicCdsProject} instances.\n * @param projectDir The project directory to which `cdsFilePath` belongs.\n *\n * @returns The {@link CdsCompilationResult} of the compilation attempt.\n */\nexport function compileCdsToJson(\n  cdsFilePath: string,\n  sourceRoot: string,\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  projectMap: Map<string, BasicCdsProject>,\n  projectDir: string,\n): CdsCompilationResult {\n  try {\n    const resolvedCdsFilePath = resolve(cdsFilePath);\n    if (!fileExists(resolvedCdsFilePath)) {\n      throw new Error(`Expected CDS file '${resolvedCdsFilePath}' does not exist.`);\n    }\n\n    // Get and log the CDS version\n    const cdsVersion = getCdsVersion(cdsCommand, cacheDir);\n    const versionInfo = cdsVersion ? `with CDS v${cdsVersion}` : '';\n\n    // CRITICAL: Create spawn options with sourceRoot as cwd to ensure correct path generation\n    const spawnOptions = createSpawnOptions(sourceRoot, cdsCommand, cacheDir);\n\n    // Throw an error if projectDir cannot be found in the projectMap.\n    if (!projectMap || !projectDir || !projectMap.has(projectDir)) {\n      throw new Error(\n        `Project directory '${projectDir}' not found in projectMap. Ensure the project is properly initialized.`,\n      );\n    }\n\n    const project = projectMap.get(projectDir);\n    const relativePath = relative(sourceRoot, resolvedCdsFilePath);\n\n    // Check if this is a project-level compilation marker\n    if (shouldUseProjectLevelCompilation(project)) {\n      return compileProjectLevel(\n        resolvedCdsFilePath,\n        sourceRoot,\n        projectDir,\n        cdsCommand,\n        spawnOptions,\n        versionInfo,\n      );\n    }\n\n    // Check if this file is in the list of files to compile for this project\n    if (!shouldCompileIndividually(project, relativePath)) {\n      cdsExtractorLog(\n        'info',\n        `${resolvedCdsFilePath} is imported by other files - will be compiled as part of a project ${versionInfo}...`,\n      );\n      const cdsJsonOutPath = `${resolvedCdsFilePath}.json`;\n      return {\n        success: true,\n        outputPath: cdsJsonOutPath,\n        compiledAsProject: true,\n        message: 'File was compiled as part of a project-based compilation',\n      };\n    } else {\n      // This is a root file - compile it using project-aware approach to its 1:1 representation\n      cdsExtractorLog(\n        'info',\n        `${resolvedCdsFilePath} identified as a root CDS file - using project-aware compilation for root file ${versionInfo}...`,\n      );\n      return compileRootFileAsProject(\n        resolvedCdsFilePath,\n        sourceRoot,\n        projectDir,\n        cdsCommand,\n        spawnOptions,\n        versionInfo,\n      );\n    }\n  } catch (error) {\n    return { success: false, message: String(error) };\n  }\n}\n\n/**\n * Handles project-level compilation for CAP projects with typical directory structure.\n * CRITICAL: Uses the project directory as cwd and calculates paths relative to project directory.\n *\n * @param resolvedCdsFilePath The resolved CDS file path that triggered this compilation\n * @param sourceRoot The source root directory\n * @param projectDir The project directory (relative to sourceRoot)\n * @param cdsCommand The CDS command to use\n * @param spawnOptions Pre-configured spawn options with sourceRoot as cwd\n * @param versionInfo Version information for logging\n * @returns Compilation result\n */\nfunction compileProjectLevel(\n  resolvedCdsFilePath: string,\n  sourceRoot: string,\n  projectDir: string,\n  cdsCommand: string,\n  spawnOptions: SpawnSyncOptions,\n  _versionInfo: string,\n): CdsCompilationResult {\n  cdsExtractorLog(\n    'info',\n    `${resolvedCdsFilePath} is part of a CAP project - using project-aware compilation ${_versionInfo}...`,\n  );\n\n  // For project-level compilation, compile the entire project together\n  // This follows the CAP best practice of compiling db and srv directories together\n  const projectAbsolutePath = join(sourceRoot, projectDir);\n\n  // Common directories in CAP projects that should be compiled together\n  const capDirectories = ['db', 'srv', 'app'];\n  const existingDirectories: string[] = [];\n\n  for (const dir of capDirectories) {\n    const dirPath = join(projectAbsolutePath, dir);\n    if (dirExists(dirPath)) {\n      existingDirectories.push(dir);\n    }\n  }\n\n  // Check if there are any CDS files in the project at all before proceeding\n  const allCdsFiles = globSync(join(projectAbsolutePath, '**/*.cds'), {\n    nodir: true,\n    ignore: ['**/node_modules/**'],\n  });\n\n  if (allCdsFiles.length === 0) {\n    throw new Error(\n      `Project directory '${projectDir}' does not contain any CDS files and cannot be compiled`,\n    );\n  }\n\n  if (existingDirectories.length === 0) {\n    // If no standard directories, check if there are CDS files in the root\n    const rootCdsFiles = globSync(join(projectAbsolutePath, '*.cds'));\n    if (rootCdsFiles.length > 0) {\n      existingDirectories.push('.');\n    } else {\n      // Find directories that contain CDS files\n      const cdsFileParents = new Set(\n        allCdsFiles.map((file: string) => {\n          const relativePath = relative(projectAbsolutePath, file);\n          const firstDir = relativePath.split('/')[0];\n          return firstDir === relativePath ? '.' : firstDir;\n        }),\n      );\n      existingDirectories.push(...Array.from(cdsFileParents));\n    }\n  }\n\n  // Generate output path for the compiled model - relative to sourceRoot for consistency\n  const relativeOutputPath = join(projectDir, 'model.cds.json');\n  const projectJsonOutPath = join(sourceRoot, relativeOutputPath);\n\n  // Use sourceRoot as working directory but provide project-relative paths\n  const projectSpawnOptions: SpawnSyncOptions = {\n    ...spawnOptions,\n    cwd: sourceRoot, // Use sourceRoot as working directory for consistency\n  };\n\n  // Convert directories to be relative to sourceRoot (include project prefix)\n  const projectRelativeDirectories = existingDirectories.map(dir =>\n    dir === '.' ? projectDir : join(projectDir, dir),\n  );\n\n  const compileArgs = [\n    'compile',\n    ...projectRelativeDirectories, // Use paths relative to sourceRoot\n    '--to',\n    'json',\n    '--dest',\n    join(projectDir, 'model.cds.json'), // Output to specific model.cds.json file\n    '--locations',\n    '--log-level',\n    'warn',\n  ];\n\n  cdsExtractorLog('info', `Compiling CAP project directories: ${existingDirectories.join(', ')}`);\n  cdsExtractorLog(\n    'info',\n    `Executing CDS command in directory ${projectAbsolutePath}: command='${cdsCommand}' args='${JSON.stringify(compileArgs)}'`,\n  );\n\n  // CRITICAL: Use the project directory as cwd\n  // Use array arguments for consistent test behavior\n  const result = spawnSync(cdsCommand, compileArgs, projectSpawnOptions);\n\n  if (result.error) {\n    cdsExtractorLog('error', `SpawnSync error: ${result.error.message}`);\n    throw new Error(`Error executing CDS compiler: ${result.error.message}`);\n  }\n\n  // Log stderr for debugging even on success (CDS often writes warnings to stderr)\n  if (result.stderr && result.stderr.length > 0) {\n    cdsExtractorLog('warn', `CDS stderr output: ${result.stderr.toString()}`);\n  }\n\n  if (result.status !== 0) {\n    cdsExtractorLog('error', `CDS command failed with status ${result.status}`);\n    cdsExtractorLog(\n      'error',\n      `Command: ${cdsCommand} ${compileArgs.map(arg => (arg.includes(' ') ? `\"${arg}\"` : arg)).join(' ')}`,\n    );\n    cdsExtractorLog('error', `Stdout: ${result.stdout?.toString() || 'No stdout'}`);\n    cdsExtractorLog('error', `Stderr: ${result.stderr?.toString() || 'No stderr'}`);\n    throw new Error(\n      `Could not compile the CAP project ${projectDir}.\\nReported error(s):\\n\\`\\`\\`\\n${\n        result.stderr?.toString() || 'Unknown error'\n      }\\n\\`\\`\\``,\n    );\n  }\n\n  if (!fileExists(projectJsonOutPath) && !dirExists(projectJsonOutPath)) {\n    throw new Error(\n      `CAP project '${projectDir}' was not compiled to JSON. This is likely because the project structure is invalid.`,\n    );\n  }\n\n  // Handle directory output if the CDS compiler generated a directory\n  if (dirExists(projectJsonOutPath)) {\n    cdsExtractorLog(\n      'info',\n      `CDS compiler generated JSON to output directory: ${projectJsonOutPath}`,\n    );\n    // Recursively rename all .json files to have a .cds.json extension\n    recursivelyRenameJsonFiles(projectJsonOutPath);\n  } else {\n    cdsExtractorLog('info', `CDS compiler generated JSON to file: ${projectJsonOutPath}`);\n  }\n\n  return {\n    success: true,\n    outputPath: projectJsonOutPath,\n    compiledAsProject: true,\n    message: 'Project was compiled using project-aware compilation',\n  };\n}\n\n/**\n * Compiles a root CDS file using project-aware approach for 1:1 .cds.json representation.\n * This follows the autobuild.md vision of project-aware compilation only.\n *\n * @param resolvedCdsFilePath The resolved CDS file path\n * @param sourceRoot The source root directory\n * @param projectDir The project directory\n * @param cdsCommand The CDS command to use\n * @param spawnOptions Pre-configured spawn options\n * @param versionInfo Version information for logging\n * @returns Compilation result\n */\nfunction compileRootFileAsProject(\n  resolvedCdsFilePath: string,\n  sourceRoot: string,\n  _projectDir: string,\n  cdsCommand: string,\n  spawnOptions: SpawnSyncOptions,\n  _versionInfo: string,\n): CdsCompilationResult {\n  // Calculate relative path for the output file\n  const relativeCdsPath = relative(sourceRoot, resolvedCdsFilePath);\n  const cdsJsonOutPath = `${resolvedCdsFilePath}.json`;\n\n  // Use project-aware compilation with specific file target\n  const compileArgs = [\n    'compile',\n    relativeCdsPath, // Compile the specific file relative to sourceRoot\n    '--to',\n    'json',\n    '--dest',\n    `${relativeCdsPath}.json`,\n    '--locations',\n    '--log-level',\n    'warn',\n  ];\n\n  cdsExtractorLog(\n    'info',\n    `Compiling root CDS file using project-aware approach: ${relativeCdsPath}`,\n  );\n  cdsExtractorLog(\n    'info',\n    `Executing CDS command: command='${cdsCommand}' args='${JSON.stringify(compileArgs)}'`,\n  );\n\n  // Execute the compilation\n  const result = spawnSync(cdsCommand, compileArgs, spawnOptions);\n\n  if (result.error) {\n    cdsExtractorLog('error', `SpawnSync error: ${result.error.message}`);\n    throw new Error(`Error executing CDS compiler: ${result.error.message}`);\n  }\n\n  // Log stderr for debugging even on success\n  if (result.stderr && result.stderr.length > 0) {\n    cdsExtractorLog('warn', `CDS stderr output: ${result.stderr.toString()}`);\n  }\n\n  if (result.status !== 0) {\n    cdsExtractorLog('error', `CDS command failed with status ${result.status}`);\n    cdsExtractorLog(\n      'error',\n      `Command: ${cdsCommand} ${compileArgs.map(arg => (arg.includes(' ') ? `\"${arg}\"` : arg)).join(' ')}`,\n    );\n    cdsExtractorLog('error', `Stdout: ${result.stdout?.toString() || 'No stdout'}`);\n    cdsExtractorLog('error', `Stderr: ${result.stderr?.toString() || 'No stderr'}`);\n    throw new Error(\n      `Could not compile the root CDS file ${relativeCdsPath}.\\nReported error(s):\\n\\`\\`\\`\\n${\n        result.stderr?.toString() || 'Unknown error'\n      }\\n\\`\\`\\``,\n    );\n  }\n\n  if (!fileExists(cdsJsonOutPath) && !dirExists(cdsJsonOutPath)) {\n    throw new Error(\n      `Root CDS file '${relativeCdsPath}' was not compiled to JSON. Expected output: ${cdsJsonOutPath}`,\n    );\n  }\n\n  // Handle directory output if the CDS compiler generated a directory\n  if (dirExists(cdsJsonOutPath)) {\n    cdsExtractorLog('info', `CDS compiler generated JSON to output directory: ${cdsJsonOutPath}`);\n    // Recursively rename all .json files to have a .cds.json extension\n    recursivelyRenameJsonFiles(cdsJsonOutPath);\n  } else {\n    cdsExtractorLog('info', `CDS compiler generated JSON to file: ${cdsJsonOutPath}`);\n  }\n\n  return {\n    success: true,\n    outputPath: cdsJsonOutPath,\n    compiledAsProject: true,\n    message: 'Root file compiled using project-aware compilation',\n  };\n}\n\n/**\n * Creates spawn options for CDS compilation processes.\n * CRITICAL: Always sets cwd to sourceRoot to ensure generated JSON paths are relative to sourceRoot.\n *\n * @param sourceRoot The source root directory - used as cwd for all spawned processes\n * @param cdsCommand The CDS command to determine if we need Node.js environment setup\n * @param cacheDir Optional cache directory for dependencies\n * @returns Spawn options configured for CDS compilation\n */\nfunction createSpawnOptions(\n  sourceRoot: string,\n  cdsCommand: string,\n  cacheDir?: string,\n): SpawnSyncOptions {\n  const spawnOptions: SpawnSyncOptions = {\n    cwd: sourceRoot, // CRITICAL: Always use sourceRoot as cwd to ensure correct path generation\n    shell: false, // Use shell=false to ensure proper argument handling for paths with spaces\n    stdio: 'pipe',\n    env: { ...process.env },\n  };\n\n  // Check if we're using a direct binary path (contains node_modules/.bin/) or npx-style command\n  const isDirectBinary = cdsCommand.includes('node_modules/.bin/');\n\n  // Only set up Node.js environment for npx-style commands, not for direct binary execution\n  if (cacheDir && !isDirectBinary) {\n    const nodePath = join(cacheDir, 'node_modules');\n\n    // Set up environment to use the cached dependencies\n    spawnOptions.env = {\n      ...process.env,\n      NODE_PATH: `${nodePath}${delimiter}${process.env.NODE_PATH ?? ''}`,\n      PATH: `${join(nodePath, '.bin')}${delimiter}${process.env.PATH}`,\n      // Add NPM configuration to ensure dependencies are resolved from the cache directory\n      npm_config_prefix: cacheDir,\n      // Ensure we don't pick up global CDS installations that might conflict\n      npm_config_global: 'false',\n      // Clear any existing CDS environment variables that might interfere\n      CDS_HOME: cacheDir,\n    };\n  } else if (isDirectBinary) {\n    // For direct binary execution, use minimal environment to avoid conflicts\n    // Remove Node.js-specific environment variables that might interfere\n    const cleanEnv = { ...process.env };\n    delete cleanEnv.NODE_PATH;\n    delete cleanEnv.npm_config_prefix;\n    delete cleanEnv.npm_config_global;\n    delete cleanEnv.CDS_HOME;\n\n    spawnOptions.env = cleanEnv;\n  }\n\n  return spawnOptions;\n}\n\n/**\n * Determines if a file should be compiled individually or skipped because it's part of a project.\n *\n * @param project The CDS project\n * @param relativePath The relative path of the file being checked\n * @returns true if the file should be compiled individually\n */\nfunction shouldCompileIndividually(\n  project: BasicCdsProject | undefined,\n  relativePath: string,\n): boolean {\n  return project?.cdsFilesToCompile?.includes(relativePath) ?? true;\n}\n\n/**\n * Determines if the given project should use project-level compilation.\n *\n * @param project The CDS project to check\n * @returns true if project-level compilation should be used\n */\nfunction shouldUseProjectLevelCompilation(project: BasicCdsProject | undefined): boolean {\n  return project?.cdsFilesToCompile?.includes('__PROJECT_LEVEL_COMPILATION__') ?? false;\n}\n", "import { spawnSync, SpawnSyncOptions } from 'child_process';\nimport { join, delimiter } from 'path';\n\n/**\n * Get the CDS compiler version from a specific command or cache directory.\n * @param cdsCommand The CDS command to use.\n * @param cacheDir Optional path to a directory containing installed dependencies.\n * @returns The CDS compiler version string, or undefined if it couldn't be determined.\n */\nexport function getCdsVersion(cdsCommand: string, cacheDir?: string): string | undefined {\n  try {\n    // Set up environment vars if using a cache directory\n    const spawnOptions: SpawnSyncOptions = {\n      shell: true,\n      stdio: 'pipe',\n      env: { ...process.env },\n    };\n\n    // If a cache directory is provided, set NODE_PATH to use that cache\n    if (cacheDir) {\n      const nodePath = join(cacheDir, 'node_modules');\n\n      // Set up environment to use the cached dependencies\n      spawnOptions.env = {\n        ...process.env,\n        NODE_PATH: `${nodePath}${delimiter}${process.env.NODE_PATH ?? ''}`,\n        PATH: `${join(nodePath, '.bin')}${delimiter}${process.env.PATH}`,\n        npm_config_prefix: cacheDir,\n      };\n    }\n\n    // Execute the CDS command with the --version flag\n    const result = spawnSync(cdsCommand, ['--version'], spawnOptions);\n    if (result.status === 0 && result.stdout) {\n      const versionOutput = result.stdout.toString().trim();\n      // Extract version number, which is typically in formats like \"@sap/cds: 6.1.3\" or similar\n      const match = versionOutput.match(/@sap\\/cds[^0-9]*([0-9]+\\.[0-9]+\\.[0-9]+)/);\n      if (match?.[1]) {\n        return match[1]; // Return just the version number\n      }\n      return versionOutput; // Return full output if we couldn't parse it\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n", "import { execFileSync } from 'child_process';\nimport { resolve } from 'path';\n\nimport { quote } from 'shell-quote';\n\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Severity levels for diagnostics\n */\nexport enum DiagnosticSeverity {\n  Error = 'error',\n  Warning = 'warning',\n  Note = 'note',\n  Recommendation = 'recommendation',\n}\n\n/**\n * Base function to add a diagnostic to the CodeQL database\n * @param filePath Path to the file related to the diagnostic\n * @param message The diagnostic message\n * @param codeqlExePath Path to the CodeQL executable\n * @param sourceId The source ID for the diagnostic\n * @param sourceName The source name for the diagnostic\n * @param severity The severity level of the diagnostic\n * @param logPrefix Prefix for the log message\n * @returns True if the diagnostic was added, false otherwise\n */\nfunction addDiagnostic(\n  filePath: string,\n  message: string,\n  codeqlExePath: string,\n  sourceId: string,\n  sourceName: string,\n  severity: DiagnosticSeverity,\n  logPrefix: string,\n): boolean {\n  try {\n    // Use shell-quote to safely escape the message\n    const escapedMessage = quote([message]);\n\n    execFileSync(codeqlExePath, [\n      'database',\n      'add-diagnostic',\n      '--extractor-name=cds',\n      '--ready-for-status-page',\n      `--source-id=${sourceId}`,\n      `--source-name=${sourceName}`,\n      `--severity=${severity}`,\n      `--markdown-message=${escapedMessage.slice(1, -1)}`, // Remove the added quotes from shell-quote\n      `--file-path=${resolve(filePath)}`,\n      '--',\n      `${process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE ?? ''}`,\n    ]);\n    cdsExtractorLog('info', `Added ${severity} diagnostic for ${logPrefix}: ${filePath}`);\n    return true;\n  } catch (err) {\n    cdsExtractorLog(\n      'error',\n      `Failed to add ${severity} diagnostic for ${logPrefix}=${filePath} : ${String(err)}`,\n    );\n    return false;\n  }\n}\n\n/**\n * Add a diagnostic error to the CodeQL database for a failed CDS compilation\n * @param cdsFilePath Path to the CDS file that failed to compile\n * @param errorMessage The error message from the compilation\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nexport function addCompilationDiagnostic(\n  cdsFilePath: string,\n  errorMessage: string,\n  codeqlExePath: string,\n): boolean {\n  return addDiagnostic(\n    cdsFilePath,\n    errorMessage,\n    codeqlExePath,\n    'cds/compilation-failure',\n    'Failure to compile one or more SAP CAP CDS files',\n    DiagnosticSeverity.Error,\n    'source file',\n  );\n}\n\n/**\n * Add a diagnostic error to the CodeQL database for a JavaScript extractor failure\n * @param filePath Path to a relevant file for the error context\n * @param errorMessage The error message from the JavaScript extractor\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nexport function addJavaScriptExtractorDiagnostic(\n  filePath: string,\n  errorMessage: string,\n  codeqlExePath: string,\n): boolean {\n  return addDiagnostic(\n    filePath,\n    errorMessage,\n    codeqlExePath,\n    'cds/js-extractor-failure',\n    'Failure in JavaScript extractor for SAP CAP CDS files',\n    DiagnosticSeverity.Error,\n    'extraction file',\n  );\n}\n", "import { determineCdsCommand } from './command';\nimport { compileCdsToJson } from './compile';\nimport { CompilationAttempt, CompilationTask, CompilationConfig } from './types';\nimport { addCompilationDiagnostic } from '../../diagnostics';\nimport { cdsExtractorLog, generateStatusReport } from '../../logging';\nimport { CdsDependencyGraph, CdsProject } from '../parser/types';\n\n/** Attempt compilation with a specific command and configuration. */\nfunction attemptCompilation(\n  task: CompilationTask,\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  dependencyGraph: CdsDependencyGraph,\n): CompilationAttempt {\n  const attemptId = `${task.id}_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`;\n  const startTime = new Date();\n\n  const attempt: CompilationAttempt = {\n    id: attemptId,\n    cdsCommand,\n    cacheDir,\n    timestamp: startTime,\n    result: {\n      success: false,\n      timestamp: startTime,\n    },\n  };\n\n  try {\n    // For now, we'll use the first source file for compilation\n    // In a more sophisticated implementation, we might handle project-level compilation differently\n    const primarySourceFile = task.sourceFiles[0];\n\n    const compilationResult = compileCdsToJson(\n      primarySourceFile,\n      dependencyGraph.sourceRootDir,\n      cdsCommand,\n      cacheDir,\n      // Convert CDS projects to BasicCdsProject format expected by compileCdsToJson\n      new Map(\n        Array.from(dependencyGraph.projects.entries()).map(([key, value]) => [\n          key,\n          {\n            cdsFiles: value.cdsFiles,\n            cdsFilesToCompile: value.cdsFilesToCompile,\n            expectedOutputFiles: value.expectedOutputFiles,\n            projectDir: value.projectDir,\n            dependencies: value.dependencies,\n            imports: value.imports,\n            packageJson: value.packageJson,\n            compilationConfig: value.compilationConfig,\n          },\n        ]),\n      ),\n      task.projectDir,\n    );\n\n    const endTime = new Date();\n    attempt.result = {\n      ...compilationResult,\n      timestamp: endTime,\n      durationMs: endTime.getTime() - startTime.getTime(),\n      commandUsed: cdsCommand,\n      cacheDir,\n    };\n\n    if (compilationResult.success && compilationResult.outputPath) {\n      dependencyGraph.statusSummary.jsonFilesGenerated++;\n    }\n  } catch (error) {\n    const endTime = new Date();\n    attempt.error = {\n      message: String(error),\n      stack: error instanceof Error ? error.stack : undefined,\n    };\n    attempt.result.timestamp = endTime;\n    attempt.result.durationMs = endTime.getTime() - startTime.getTime();\n  }\n\n  task.attempts.push(attempt);\n  return attempt;\n}\n\n/**\n * Create a compilation task for a project or individual file\n */\nfunction createCompilationTask(\n  type: 'file' | 'project',\n  sourceFiles: string[],\n  expectedOutputFiles: string[],\n  projectDir: string,\n  useProjectLevelCompilation: boolean,\n): CompilationTask {\n  return {\n    id: `${type}_${projectDir}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    type,\n    status: 'pending',\n    sourceFiles,\n    expectedOutputFiles,\n    projectDir,\n    attempts: [],\n    useProjectLevelCompilation,\n    dependencies: [],\n  };\n}\n\nfunction createCompilationConfig(\n  cdsCommand: string,\n  cacheDir: string | undefined,\n  useProjectLevel: boolean,\n): CompilationConfig {\n  return {\n    cdsCommand: cdsCommand,\n    cacheDir: cacheDir,\n    useProjectLevelCompilation: useProjectLevel,\n    versionCompatibility: {\n      isCompatible: true, // Will be validated during planning\n    },\n    maxRetryAttempts: 3,\n  };\n}\n\n/**\n * Execute a single compilation task\n */\nfunction executeCompilationTask(\n  task: CompilationTask,\n  project: CdsProject,\n  dependencyGraph: CdsDependencyGraph,\n  codeqlExePath: string,\n): void {\n  task.status = 'in_progress';\n\n  const config = project.enhancedCompilationConfig;\n  if (!config) {\n    throw new Error(`No compilation configuration found for project ${project.projectDir}`);\n  }\n\n  const compilationAttempt = attemptCompilation(\n    task,\n    config.cdsCommand,\n    config.cacheDir,\n    dependencyGraph,\n  );\n\n  if (compilationAttempt.result.success) {\n    task.status = 'success';\n    dependencyGraph.statusSummary.successfulCompilations++;\n    return;\n  }\n\n  // Compilation failed - mark task as failed\n  const lastError = compilationAttempt.error\n    ? new Error(compilationAttempt.error.message)\n    : new Error('Compilation failed');\n\n  task.status = 'failed';\n  task.errorSummary = lastError?.message || 'Compilation failed';\n  dependencyGraph.statusSummary.failedCompilations++;\n\n  // Add diagnostic for failed compilation\n  for (const sourceFile of task.sourceFiles) {\n    addCompilationDiagnostic(sourceFile, task.errorSummary, codeqlExePath);\n  }\n\n  cdsExtractorLog('error', `Compilation failed for task ${task.id}: ${task.errorSummary}`);\n}\n\n/**\n * Executes all compilation tasks for the provided {@link CdsDependencyGraph}.\n * Uses the provided `codeqlExePath` to run the CodeQL CLI, as needed, for\n * generating diagnositic warnings and/or errors for problems encountered while\n * running the CodeQL CDS extractor.\n */\nfunction executeCompilationTasks(dependencyGraph: CdsDependencyGraph, codeqlExePath: string): void {\n  cdsExtractorLog('info', 'Starting compilation execution for all projects...');\n\n  dependencyGraph.currentPhase = 'compiling';\n  const compilationStartTime = new Date();\n\n  // Collect all compilation tasks from all projects.\n  const allTasks: Array<{ task: CompilationTask; project: CdsProject }> = [];\n\n  for (const project of dependencyGraph.projects.values()) {\n    for (const task of project.compilationTasks) {\n      allTasks.push({ task, project });\n    }\n  }\n\n  // Execute compilation tasks sequentially. There is room for optimization in the future.\n  // For now, we keep it simple to ensure consistent debug information collection.\n  cdsExtractorLog('info', `Executing ${allTasks.length} compilation task(s)...`);\n  for (const { task, project } of allTasks) {\n    try {\n      executeCompilationTask(task, project, dependencyGraph, codeqlExePath);\n    } catch (error) {\n      const errorMessage = `Failed to execute compilation task ${task.id}: ${String(error)}`;\n      cdsExtractorLog('error', errorMessage);\n\n      dependencyGraph.errors.critical.push({\n        phase: 'compiling',\n        message: errorMessage,\n        timestamp: new Date(),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n\n      task.status = 'failed';\n      task.errorSummary = errorMessage;\n      dependencyGraph.statusSummary.failedCompilations++;\n    }\n  }\n\n  // Update project statuses\n  for (const project of dependencyGraph.projects.values()) {\n    const allTasksCompleted = project.compilationTasks.every(\n      task => task.status === 'success' || task.status === 'failed',\n    );\n\n    if (allTasksCompleted) {\n      const hasFailedTasks = project.compilationTasks.some(task => task.status === 'failed');\n      project.status = hasFailedTasks ? 'failed' : 'completed';\n      project.timestamps.compilationCompleted = new Date();\n    }\n  }\n\n  const compilationEndTime = new Date();\n  dependencyGraph.statusSummary.performance.compilationDurationMs =\n    compilationEndTime.getTime() - compilationStartTime.getTime();\n\n  cdsExtractorLog(\n    'info',\n    `Compilation execution completed. Success: ${dependencyGraph.statusSummary.successfulCompilations}, Failed: ${dependencyGraph.statusSummary.failedCompilations}`,\n  );\n}\n\n/**\n * Orchestrates the compilation process for CDS files based on a dependency graph.\n *\n * This function coordinates the planning and execution of compilation tasks,\n * tracks the compilation status, and generates a post-compilation report.\n *\n * @param dependencyGraph - The {@link CdsDependencyGraph} representing the CDS projects,\n * project dependencies, expected compilation tasks, and their statuses.\n * @param projectCacheDirMap - A map from project identifiers to their cache directory paths.\n * @param codeqlExePath - The path to the CodeQL executable. Used for generating diagnostic\n * messages as part of the broader CodeQL (JavaScript) extraction process.\n * @throws Will rethrow any errors encountered during compilation, after logging them.\n */\nexport function orchestrateCompilation(\n  dependencyGraph: CdsDependencyGraph,\n  projectCacheDirMap: Map<string, string>,\n  codeqlExePath: string,\n): void {\n  try {\n    planCompilationTasks(dependencyGraph, projectCacheDirMap);\n\n    executeCompilationTasks(dependencyGraph, codeqlExePath);\n\n    // Update overall status\n    const hasFailures =\n      dependencyGraph.statusSummary.failedCompilations > 0 ||\n      dependencyGraph.errors.critical.length > 0;\n\n    dependencyGraph.statusSummary.overallSuccess = !hasFailures;\n    dependencyGraph.currentPhase = hasFailures ? 'failed' : 'completed';\n\n    // Generate and log a \"Post-Compilation\" status report, aka before the JavaScript extractor runs.\n    const statusReport = generateStatusReport(dependencyGraph);\n    cdsExtractorLog('info', 'CDS Extractor Status Report : Post-Compilation...\\n' + statusReport);\n  } catch (error) {\n    const errorMessage = `Compilation orchestration failed: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n\n    dependencyGraph.errors.critical.push({\n      phase: 'compiling',\n      message: errorMessage,\n      timestamp: new Date(),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n\n    dependencyGraph.currentPhase = 'failed';\n    dependencyGraph.statusSummary.overallSuccess = false;\n\n    throw error;\n  }\n}\n\n/** Plan compilation tasks for all projects in the dependency graph. */\nfunction planCompilationTasks(\n  dependencyGraph: CdsDependencyGraph,\n  projectCacheDirMap: Map<string, string>,\n): void {\n  cdsExtractorLog('info', 'Planning compilation tasks for all projects...');\n\n  dependencyGraph.currentPhase = 'compilation_planning';\n\n  for (const [projectDir, project] of dependencyGraph.projects.entries()) {\n    try {\n      const cacheDir = projectCacheDirMap.get(projectDir);\n\n      // Determine CDS command\n      const cdsCommand = determineCdsCommand(cacheDir, dependencyGraph.sourceRootDir);\n\n      // Create compilation configuration\n      const compilationConfig = createCompilationConfig(\n        cdsCommand,\n        cacheDir,\n        project.cdsFilesToCompile.includes('__PROJECT_LEVEL_COMPILATION__'),\n      );\n\n      project.enhancedCompilationConfig = compilationConfig;\n\n      // Create compilation tasks\n      if (project.cdsFilesToCompile.includes('__PROJECT_LEVEL_COMPILATION__')) {\n        // Project-level compilation\n        const task = createCompilationTask(\n          'project',\n          project.cdsFiles,\n          project.expectedOutputFiles,\n          projectDir,\n          true,\n        );\n        project.compilationTasks = [task];\n      } else {\n        // Individual file compilation\n        const tasks: CompilationTask[] = [];\n        for (const cdsFile of project.cdsFilesToCompile) {\n          const expectedOutput = `${cdsFile}.json`;\n          const task = createCompilationTask(\n            'file',\n            [cdsFile],\n            [expectedOutput],\n            projectDir,\n            false,\n          );\n          tasks.push(task);\n        }\n        project.compilationTasks = tasks;\n      }\n\n      project.status = 'compilation_planned';\n      project.timestamps.compilationStarted = new Date();\n\n      cdsExtractorLog(\n        'info',\n        `Planned ${project.compilationTasks.length} compilation task(s) for project ${projectDir}`,\n      );\n    } catch (error) {\n      const errorMessage = `Failed to plan compilation for project ${projectDir}: ${String(error)}`;\n      cdsExtractorLog('error', errorMessage);\n\n      dependencyGraph.errors.critical.push({\n        phase: 'compilation_planning',\n        message: errorMessage,\n        timestamp: new Date(),\n        stack: error instanceof Error ? error.stack : undefined,\n      });\n\n      project.status = 'failed';\n    }\n  }\n\n  const totalTasks = Array.from(dependencyGraph.projects.values()).reduce(\n    (sum, project) => sum + project.compilationTasks.length,\n    0,\n  );\n\n  dependencyGraph.statusSummary.totalCompilationTasks = totalTasks;\n\n  cdsExtractorLog('info', `Compilation planning completed. Total tasks: ${totalTasks}`);\n}\n", "import { relative } from 'path';\n\n/**\n * Helper functions for mapping CDS files to their projects and cache directories\n */\n\n/**\n * Find the project directory for a CDS file\n * @param cdsFilePath Path to the CDS file\n * @param sourceRoot Source root directory\n * @param projectMap Map of project directories to project objects\n * @returns The project directory the file belongs to, or undefined if not found\n */\nexport function findProjectForCdsFile(\n  cdsFilePath: string,\n  sourceRoot: string,\n  projectMap: Map<string, { cdsFiles: string[] }>,\n): string | undefined {\n  // Get the relative path to the project directory for this CDS file\n  const relativeCdsFilePath = relative(sourceRoot, cdsFilePath);\n\n  // If the file is outside the source root, path.relative() will start with '../'\n  // In this case, we should also check against the absolute path\n  const isOutsideSourceRoot = relativeCdsFilePath.startsWith('../');\n\n  // Find the project this file belongs to\n  for (const [projectDir, project] of projectMap.entries()) {\n    if (\n      project.cdsFiles.some(\n        cdsFile =>\n          cdsFile === relativeCdsFilePath ||\n          relativeCdsFilePath.startsWith(projectDir) ||\n          (isOutsideSourceRoot && cdsFile === cdsFilePath),\n      )\n    ) {\n      return projectDir;\n    }\n  }\n\n  return undefined;\n}\n", "import { dirname, join, resolve, sep } from 'path';\n\nimport {\n  determineCdsFilesForProjectDir,\n  determineCdsFilesToCompile,\n  determineCdsProjectsUnderSourceDir,\n  extractCdsImports,\n  readPackageJsonFile,\n} from './functions';\nimport { CdsDependencyGraph, CdsImport, CdsProject, BasicCdsProject } from './types';\nimport { cdsExtractorLog } from '../../logging';\n\n/**\n * Builds a basic dependency graph of CDS projects and performs the initial parsing stage of the CDS extractor.\n * This is the internal function that creates basic project structures.\n *\n * @param sourceRootDir - Source root directory\n * @returns Map of project directories to their BasicCdsProject objects with dependency information\n */\nfunction buildBasicCdsProjectDependencyGraph(sourceRootDir: string): Map<string, BasicCdsProject> {\n  // Find all CDS projects under the source directory\n  cdsExtractorLog('info', 'Detecting CDS projects...');\n  const projectDirs = determineCdsProjectsUnderSourceDir(sourceRootDir);\n\n  if (projectDirs.length === 0) {\n    cdsExtractorLog('info', 'No CDS projects found.');\n    return new Map<string, BasicCdsProject>();\n  }\n\n  cdsExtractorLog('info', `Found ${projectDirs.length} CDS project(s) under source directory.`);\n\n  const projectMap = new Map<string, BasicCdsProject>();\n\n  // First pass: create CdsProject objects for each project directory\n  for (const projectDir of projectDirs) {\n    const absoluteProjectDir = join(sourceRootDir, projectDir);\n    const cdsFiles = determineCdsFilesForProjectDir(sourceRootDir, absoluteProjectDir);\n\n    // Try to load package.json if it exists\n    const packageJsonPath = join(absoluteProjectDir, 'package.json');\n    const packageJson = readPackageJsonFile(packageJsonPath);\n\n    projectMap.set(projectDir, {\n      projectDir,\n      cdsFiles,\n      cdsFilesToCompile: [], // Will be populated in the third pass\n      expectedOutputFiles: [], // Will be populated in the fourth pass\n      packageJson,\n      dependencies: [],\n      imports: new Map<string, CdsImport[]>(),\n    });\n  }\n\n  // Second pass: analyze dependencies between projects\n  cdsExtractorLog('info', 'Analyzing dependencies between CDS projects...');\n  for (const [projectDir, project] of projectMap.entries()) {\n    // Check each CDS file for imports\n    for (const relativeFilePath of project.cdsFiles) {\n      const absoluteFilePath = join(sourceRootDir, relativeFilePath);\n\n      try {\n        const imports = extractCdsImports(absoluteFilePath);\n        const enrichedImports: CdsImport[] = [];\n\n        // Process each import\n        for (const importInfo of imports) {\n          const enrichedImport: CdsImport = { ...importInfo };\n\n          if (importInfo.isRelative) {\n            // Resolve the relative import path\n            const importedFilePath = resolve(dirname(absoluteFilePath), importInfo.path);\n            const normalizedImportedPath = importedFilePath.endsWith('.cds')\n              ? importedFilePath\n              : `${importedFilePath}.cds`;\n\n            // Store the resolved path relative to source root\n            try {\n              const relativeToDirPath = dirname(relativeFilePath);\n              const resolvedPath = resolve(join(sourceRootDir, relativeToDirPath), importInfo.path);\n              const normalizedResolvedPath = resolvedPath.endsWith('.cds')\n                ? resolvedPath\n                : `${resolvedPath}.cds`;\n\n              // Convert to relative path from source root\n              if (normalizedResolvedPath.startsWith(sourceRootDir)) {\n                enrichedImport.resolvedPath = normalizedResolvedPath\n                  .substring(sourceRootDir.length)\n                  .replace(/^[/\\\\]/, '');\n              }\n            } catch (error) {\n              cdsExtractorLog(\n                'warn',\n                `Could not resolve import path for ${importInfo.path} in ${relativeFilePath}: ${String(error)}`,\n              );\n            }\n\n            // Find which project contains this imported file\n            for (const [otherProjectDir, otherProject] of projectMap.entries()) {\n              if (otherProjectDir === projectDir) continue; // Skip self\n\n              const otherProjectAbsoluteDir = join(sourceRootDir, otherProjectDir);\n\n              // Check if the imported file is in the other project\n              const isInOtherProject = otherProject.cdsFiles.some(otherFile => {\n                const otherAbsolutePath = join(sourceRootDir, otherFile);\n                return (\n                  otherAbsolutePath === normalizedImportedPath ||\n                  normalizedImportedPath.startsWith(otherProjectAbsoluteDir + sep)\n                );\n              });\n\n              if (isInOtherProject) {\n                // Add dependency if not already present\n                project.dependencies ??= [];\n\n                if (!project.dependencies.includes(otherProject)) {\n                  project.dependencies.push(otherProject);\n                }\n              }\n            }\n          }\n          // For module imports, check package.json dependencies\n          else if (importInfo.isModule && project.packageJson) {\n            const dependencies = {\n              ...(project.packageJson.dependencies ?? {}),\n              ...(project.packageJson.devDependencies ?? {}),\n            };\n\n            // Extract module name from import path (e.g., '@sap/cds/common' -> '@sap/cds')\n            const moduleName = importInfo.path.split('/')[0].startsWith('@')\n              ? importInfo.path.split('/').slice(0, 2).join('/')\n              : importInfo.path.split('/')[0];\n\n            if (dependencies[moduleName]) {\n              // This is a valid module dependency, nothing more to do here\n              // In the future, we could track module dependencies separately\n            }\n          }\n\n          enrichedImports.push(enrichedImport);\n        }\n\n        // Store the enriched imports in the project\n        project.imports?.set(relativeFilePath, enrichedImports);\n      } catch (error: unknown) {\n        cdsExtractorLog(\n          'warn',\n          `Error processing imports in ${absoluteFilePath}: ${String(error)}`,\n        );\n      }\n    }\n  }\n\n  // Third pass: determine CDS files to compile and expected output files for each project\n  cdsExtractorLog(\n    'info',\n    'Determining CDS files to compile and expected output files for each project...',\n  );\n  for (const [, project] of projectMap.entries()) {\n    try {\n      const projectPlan = determineCdsFilesToCompile(sourceRootDir, project);\n\n      // Assign the calculated values back to the project\n      project.cdsFilesToCompile = projectPlan.filesToCompile;\n      project.expectedOutputFiles = projectPlan.expectedOutputFiles;\n\n      // Check if using project-level compilation\n      const usesProjectLevelCompilation = projectPlan.filesToCompile.includes(\n        '__PROJECT_LEVEL_COMPILATION__',\n      );\n\n      if (usesProjectLevelCompilation) {\n        cdsExtractorLog(\n          'info',\n          `Project ${project.projectDir}: using project-level compilation for all ${project.cdsFiles.length} CDS files, expecting ${projectPlan.expectedOutputFiles.length} output files`,\n        );\n      } else {\n        cdsExtractorLog(\n          'info',\n          `Project ${project.projectDir}: ${projectPlan.filesToCompile.length} files to compile out of ${project.cdsFiles.length} total CDS files, expecting ${projectPlan.expectedOutputFiles.length} output files`,\n        );\n      }\n    } catch (error) {\n      cdsExtractorLog(\n        'warn',\n        `Error determining files to compile for project ${project.projectDir}: ${String(error)}`,\n      );\n      // Fall back to compiling all files on error\n      project.cdsFilesToCompile = [...project.cdsFiles];\n      project.expectedOutputFiles = [];\n    }\n  }\n\n  return projectMap;\n}\n\n/**\n * Builds a CDS dependency graph with comprehensive tracking and debug information.\n * This is the main function that returns a CdsDependencyGraph instead of a simple Map.\n * The extractor now runs in autobuild mode by default.\n *\n * @param sourceRootDir - Source root directory\n * @returns CDS dependency graph with comprehensive tracking\n */\nexport function buildCdsProjectDependencyGraph(sourceRootDir: string): CdsDependencyGraph {\n  const startTime = new Date();\n\n  // Create the initial dependency graph structure\n  const dependencyGraph: CdsDependencyGraph = {\n    id: `cds_graph_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    sourceRootDir,\n    projects: new Map<string, CdsProject>(),\n    debugInfo: {\n      extractor: {\n        runMode: 'autobuild',\n        sourceRootDir,\n        startTime,\n        environment: {\n          nodeVersion: process.version,\n          platform: process.platform,\n          cwd: process.cwd(),\n          argv: process.argv,\n        },\n      },\n      parser: {\n        projectsDetected: 0,\n        cdsFilesFound: 0,\n        dependencyResolutionSuccess: true,\n        parsingErrors: [],\n        parsingWarnings: [],\n      },\n      compiler: {\n        availableCommands: [],\n        selectedCommand: '',\n        cacheDirectories: [],\n        cacheInitialized: false,\n      },\n    },\n    currentPhase: 'parsing',\n    statusSummary: {\n      overallSuccess: false,\n      totalProjects: 0,\n      totalCdsFiles: 0,\n      totalCompilationTasks: 0,\n      successfulCompilations: 0,\n      failedCompilations: 0,\n      skippedCompilations: 0,\n      jsonFilesGenerated: 0,\n      criticalErrors: [],\n      warnings: [],\n      performance: {\n        totalDurationMs: 0,\n        parsingDurationMs: 0,\n        compilationDurationMs: 0,\n        extractionDurationMs: 0,\n      },\n    },\n    config: {\n      maxRetryAttempts: 3,\n      enableDetailedLogging: false, // Debug modes removed\n      generateDebugOutput: false, // Debug modes removed\n      compilationTimeoutMs: 30000, // 30 seconds\n    },\n    errors: {\n      critical: [],\n      warnings: [],\n    },\n  };\n\n  try {\n    // Use the existing function to build the basic project map\n    const basicProjectMap = buildBasicCdsProjectDependencyGraph(sourceRootDir);\n\n    // Convert basic projects to CDS projects\n    for (const [projectDir, basicProject] of basicProjectMap.entries()) {\n      const cdsProject: CdsProject = {\n        ...basicProject,\n        id: `project_${projectDir.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}`,\n        enhancedCompilationConfig: undefined, // Will be set during compilation planning\n        compilationTasks: [],\n        parserDebugInfo: {\n          dependenciesResolved: [],\n          importErrors: [],\n          parseErrors: new Map<string, string>(),\n        },\n        status: 'discovered',\n        timestamps: {\n          discovered: new Date(),\n        },\n      };\n\n      dependencyGraph.projects.set(projectDir, cdsProject);\n    }\n\n    // Update summary statistics\n    dependencyGraph.statusSummary.totalProjects = dependencyGraph.projects.size;\n    dependencyGraph.statusSummary.totalCdsFiles = Array.from(\n      dependencyGraph.projects.values(),\n    ).reduce((sum, project) => sum + project.cdsFiles.length, 0);\n\n    dependencyGraph.debugInfo.parser.projectsDetected = dependencyGraph.projects.size;\n    dependencyGraph.debugInfo.parser.cdsFilesFound = dependencyGraph.statusSummary.totalCdsFiles;\n\n    // Mark dependency resolution phase as completed\n    dependencyGraph.currentPhase = 'dependency_resolution';\n\n    const endTime = new Date();\n    dependencyGraph.debugInfo.extractor.endTime = endTime;\n    dependencyGraph.debugInfo.extractor.durationMs = endTime.getTime() - startTime.getTime();\n    dependencyGraph.statusSummary.performance.parsingDurationMs =\n      dependencyGraph.debugInfo.extractor.durationMs;\n\n    cdsExtractorLog(\n      'info',\n      `CDS dependency graph created with ${dependencyGraph.projects.size} projects and ${dependencyGraph.statusSummary.totalCdsFiles} CDS files`,\n    );\n\n    return dependencyGraph;\n  } catch (error) {\n    const errorMessage = `Failed to build CDS dependency graph: ${String(error)}`;\n    cdsExtractorLog('error', errorMessage);\n\n    dependencyGraph.errors.critical.push({\n      phase: 'parsing',\n      message: errorMessage,\n      timestamp: new Date(),\n      stack: error instanceof Error ? error.stack : undefined,\n    });\n\n    dependencyGraph.currentPhase = 'failed';\n    return dependencyGraph;\n  }\n}\n", "import { existsSync, readFileSync, statSync } from 'fs';\nimport { basename, dirname, join, relative, sep } from 'path';\n\nimport { sync } from 'glob';\n\nimport { CdsFilesToCompile, CdsImport, PackageJson } from './types';\nimport { cdsExtractorLog } from '../../logging';\n\n/**\n * Determines the list of CDS files to be parsed for the specified project directory.\n *\n * @param sourceRootDir - The source root directory to search for CDS files. This is\n * used to resolve relative paths in relation to a common (source root) directory for\n * multiple projects.\n * @param projectDir - The full, local filesystem path of the directory that contains\n * the individual `.cds` definition files for some `CAP` project.\n * @returns An array of strings representing the paths, relative to the source root\n * directory, of the `.cds` files to be parsed for a given project.\n */\nexport function determineCdsFilesForProjectDir(\n  sourceRootDir: string,\n  projectDir: string,\n): string[] {\n  if (!sourceRootDir || !projectDir) {\n    throw new Error(\n      `Unable to determine CDS files for project dir '${projectDir}'; both sourceRootDir and projectDir must be provided.`,\n    );\n  }\n\n  // Normalize paths by removing trailing slashes for comparison\n  const normalizedSourceRoot = sourceRootDir.replace(/[/\\\\]+$/, '');\n  const normalizedProjectDir = projectDir.replace(/[/\\\\]+$/, '');\n\n  if (\n    !normalizedProjectDir.startsWith(normalizedSourceRoot) &&\n    normalizedProjectDir !== normalizedSourceRoot\n  ) {\n    throw new Error(\n      'projectDir must be a subdirectory of sourceRootDir or equal to sourceRootDir.',\n    );\n  }\n\n  try {\n    // Use glob to find all .cds files under the project directory, excluding node_modules\n    const cdsFiles = sync(join(projectDir, '**/*.cds'), {\n      nodir: true,\n      ignore: ['**/node_modules/**', '**/*.testproj/**'],\n    });\n\n    // Convert absolute paths to paths relative to sourceRootDir\n    return cdsFiles.map(file => relative(sourceRootDir, file));\n  } catch (error: unknown) {\n    cdsExtractorLog('error', `Error finding CDS files in ${projectDir}: ${String(error)}`);\n    return [];\n  }\n}\n\n/**\n * Determines the list of distinct CDS projects under the specified source\n * directory.\n * @param sourceRootDir - The source root directory to search for CDS projects.\n * @returns An array of strings representing the paths, relative to the source\n * root directory, of the detected CDS projects.\n */\nexport function determineCdsProjectsUnderSourceDir(sourceRootDir: string): string[] {\n  if (!sourceRootDir || !existsSync(sourceRootDir)) {\n    throw new Error(`Source root directory '${sourceRootDir}' does not exist.`);\n  }\n\n  const foundProjects = new Set<string>();\n\n  // Find all potential project directories by looking for package.json files and CDS files\n  const packageJsonFiles = sync(join(sourceRootDir, '**/package.json'), {\n    nodir: true,\n    ignore: ['**/node_modules/**', '**/*.testproj/**'],\n  });\n\n  const cdsFiles = sync(join(sourceRootDir, '**/*.cds'), {\n    nodir: true,\n    ignore: ['**/node_modules/**', '**/*.testproj/**'],\n  });\n\n  // Collect all potential project directories\n  const candidateDirectories = new Set<string>();\n\n  // Add directories with package.json files\n  for (const packageJsonFile of packageJsonFiles) {\n    candidateDirectories.add(dirname(packageJsonFile));\n  }\n\n  // Add directories with CDS files and try to find their project roots\n  for (const cdsFile of cdsFiles) {\n    const cdsDir = dirname(cdsFile);\n    const projectRoot = findProjectRootFromCdsFile(cdsDir, sourceRootDir);\n    if (projectRoot) {\n      candidateDirectories.add(projectRoot);\n    } else {\n      candidateDirectories.add(cdsDir);\n    }\n  }\n\n  // Filter candidates to only include likely CDS projects\n  for (const dir of candidateDirectories) {\n    if (isLikelyCdsProject(dir)) {\n      const relativePath = relative(sourceRootDir, dir);\n      const projectDir = relativePath || '.';\n\n      // Check if this project is already included as a parent or child of an existing project\n      let shouldAdd = true;\n      const existingProjects = Array.from(foundProjects);\n\n      for (const existingProject of existingProjects) {\n        const existingAbsPath = join(sourceRootDir, existingProject);\n\n        // Skip if this directory is a subdirectory of an existing project,\n        // but only if the parent is not a monorepo with its own CDS content\n        if (dir.startsWith(existingAbsPath + sep)) {\n          // Check if parent is a monorepo root with its own CDS content\n          const parentPackageJsonPath = join(existingAbsPath, 'package.json');\n          const parentPackageJson = readPackageJsonFile(parentPackageJsonPath);\n          const isParentMonorepo =\n            parentPackageJson?.workspaces &&\n            Array.isArray(parentPackageJson.workspaces) &&\n            parentPackageJson.workspaces.length > 0;\n\n          // If parent is a monorepo with CDS content, allow both parent and child\n          if (\n            isParentMonorepo &&\n            (hasStandardCdsContent(existingAbsPath) || hasDirectCdsContent(existingAbsPath))\n          ) {\n            // Both parent and child can coexist as separate CDS projects\n            shouldAdd = true;\n          } else {\n            // Traditional case: exclude subdirectory\n            shouldAdd = false;\n          }\n          break;\n        }\n\n        // Remove existing project if it's a subdirectory of the current directory,\n        // unless the current directory is a monorepo root and the existing project has its own CDS content\n        if (existingAbsPath.startsWith(dir + sep)) {\n          const currentPackageJsonPath = join(dir, 'package.json');\n          const currentPackageJson = readPackageJsonFile(currentPackageJsonPath);\n          const isCurrentMonorepo =\n            currentPackageJson?.workspaces &&\n            Array.isArray(currentPackageJson.workspaces) &&\n            currentPackageJson.workspaces.length > 0;\n\n          // If current is a monorepo and the existing project is a legitimate CDS project, keep both\n          if (!(isCurrentMonorepo && isLikelyCdsProject(existingAbsPath))) {\n            foundProjects.delete(existingProject);\n          }\n        }\n      }\n\n      if (shouldAdd) {\n        foundProjects.add(projectDir);\n      }\n    }\n  }\n\n  return Array.from(foundProjects).sort();\n}\n\n/**\n * Parses a CDS file to extract import statements\n *\n * @param filePath - Path to the CDS file\n * @returns Array of import statements found in the file\n */\nexport function extractCdsImports(filePath: string): CdsImport[] {\n  if (!existsSync(filePath)) {\n    throw new Error(`File does not exist: ${filePath}`);\n  }\n\n  const content = readFileSync(filePath, 'utf8');\n  const imports: CdsImport[] = [];\n\n  // Regular expression to match using statements\n  // This handles: using X from 'path'; and using { X, Y } from 'path';\n  // and also using X as Y from 'path';\n  const usingRegex =\n    /using\\s+(?:{[^}]+}|[\\w.]+(?:\\s+as\\s+[\\w.]+)?)\\s+from\\s+['\"`]([^'\"`]+)['\"`]\\s*;/g;\n\n  let match;\n  while ((match = usingRegex.exec(content)) !== null) {\n    const path = match[1];\n    imports.push({\n      statement: match[0],\n      path,\n      isRelative: path.startsWith('./') || path.startsWith('../'),\n      isModule: !path.startsWith('./') && !path.startsWith('../') && !path.startsWith('/'),\n    });\n  }\n\n  return imports;\n}\n\n/**\n * Attempts to find the project root directory starting from a directory containing a CDS file\n *\n * @param cdsFileDir - Directory containing a CDS file\n * @param sourceRootDir - Source root directory to limit the search\n * @returns The project root directory or null if not found\n */\nfunction findProjectRootFromCdsFile(cdsFileDir: string, sourceRootDir: string): string | null {\n  // Skip node_modules and testproj directories entirely\n  if (cdsFileDir.includes('node_modules') || cdsFileDir.includes('.testproj')) {\n    return null;\n  }\n\n  let currentDir = cdsFileDir;\n\n  // Limit the upward search to the sourceRootDir\n  while (currentDir.startsWith(sourceRootDir)) {\n    // Check if this directory looks like a project root\n    if (isLikelyCdsProject(currentDir)) {\n      // If this is a standard CAP subdirectory (srv, db, app), check if the parent\n      // directory should be the real project root\n      const currentDirName = basename(currentDir);\n      const isStandardSubdir = ['srv', 'db', 'app'].includes(currentDirName);\n\n      if (isStandardSubdir) {\n        const parentDir = dirname(currentDir);\n\n        if (\n          parentDir !== currentDir &&\n          parentDir.startsWith(sourceRootDir) &&\n          !parentDir.includes('node_modules') &&\n          !parentDir.includes('.testproj') &&\n          isLikelyCdsProject(parentDir)\n        ) {\n          // The parent is also a CDS project, so it's likely the real project root\n          return parentDir;\n        }\n      }\n\n      // For non-standard subdirectories, also check if the parent might be a better project root\n      const parentDir = dirname(currentDir);\n\n      if (\n        parentDir !== currentDir &&\n        parentDir.startsWith(sourceRootDir) &&\n        !parentDir.includes('node_modules') &&\n        !parentDir.includes('.testproj')\n      ) {\n        const hasDbDir =\n          existsSync(join(parentDir, 'db')) && statSync(join(parentDir, 'db')).isDirectory();\n        const hasSrvDir =\n          existsSync(join(parentDir, 'srv')) && statSync(join(parentDir, 'srv')).isDirectory();\n        const hasAppDir =\n          existsSync(join(parentDir, 'app')) && statSync(join(parentDir, 'app')).isDirectory();\n\n        // Use the same CAP project structure logic as below\n        if ((hasDbDir && hasSrvDir) || (hasSrvDir && hasAppDir)) {\n          return parentDir;\n        }\n      }\n\n      return currentDir;\n    }\n\n    // Check for typical CAP project structure indicators\n    const hasDbDir =\n      existsSync(join(currentDir, 'db')) && statSync(join(currentDir, 'db')).isDirectory();\n    const hasSrvDir =\n      existsSync(join(currentDir, 'srv')) && statSync(join(currentDir, 'srv')).isDirectory();\n    const hasAppDir =\n      existsSync(join(currentDir, 'app')) && statSync(join(currentDir, 'app')).isDirectory();\n\n    if ((hasDbDir && hasSrvDir) || (hasSrvDir && hasAppDir)) {\n      return currentDir;\n    }\n\n    // Move up one directory\n    const parentDir = dirname(currentDir);\n    if (parentDir === currentDir) {\n      // We've reached the root of the filesystem\n      break;\n    }\n    currentDir = parentDir;\n  }\n\n  // If we couldn't determine a proper project root, return the original directory\n  return cdsFileDir;\n}\n\n/**\n * Determines if a directory likely contains a CAP project by checking for key\n * indicators like package.json with CAP dependencies or .cds files in standard\n * locations.\n *\n * @param dir - Directory to check\n * @returns true if the directory likely contains a CAP project\n */\nexport function isLikelyCdsProject(dir: string): boolean {\n  try {\n    // Skip node_modules and testproj directories entirely\n    if (dir.includes('node_modules') || dir.includes('.testproj')) {\n      return false;\n    }\n\n    // Check for CDS files in standard locations (checking both direct and nested files)\n    const hasStandardCdsDirectories = hasStandardCdsContent(dir);\n    const hasDirectCdsFiles = hasDirectCdsContent(dir);\n    const hasCdsFiles = hasStandardCdsDirectories || hasDirectCdsFiles;\n\n    // Check if package.json exists and has CAP dependencies\n    const hasCapDependencies = hasPackageJsonWithCapDeps(dir);\n\n    if (hasCapDependencies) {\n      // If there are CAP dependencies but no CDS files, there's nothing for us to do\n      if (!hasCdsFiles) {\n        return false;\n      }\n\n      // Check if this is a monorepo root\n      const packageJsonPath = join(dir, 'package.json');\n      const packageJson = readPackageJsonFile(packageJsonPath);\n\n      if (\n        packageJson?.workspaces &&\n        Array.isArray(packageJson.workspaces) &&\n        packageJson.workspaces.length > 0\n      ) {\n        // This is likely a monorepo - only treat as CDS project if it has actual CDS content\n        if (!hasCdsFiles) {\n          // This is a monorepo root without its own CDS content\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    // If no CAP dependencies, only consider it a CDS project if it has CDS files\n    return hasCdsFiles;\n  } catch (error: unknown) {\n    cdsExtractorLog('error', `Error checking directory ${dir}: ${String(error)}`);\n    return false;\n  }\n}\n\n/**\n * Check if a directory has CDS content in standard CAP directories.\n */\nfunction hasStandardCdsContent(dir: string): boolean {\n  const standardLocations = [join(dir, 'db'), join(dir, 'srv'), join(dir, 'app')];\n\n  for (const location of standardLocations) {\n    if (existsSync(location) && statSync(location).isDirectory()) {\n      // Check for any .cds files at any level under these directories.\n      const cdsFiles = sync(join(location, '**/*.cds'), { nodir: true });\n      if (cdsFiles.length > 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if a directory has direct CDS files.\n */\nfunction hasDirectCdsContent(dir: string): boolean {\n  const directCdsFiles = sync(join(dir, '*.cds'));\n  return directCdsFiles.length > 0;\n}\n\n/**\n * Safely parses a package.json file, using the cache if available\n * @param filePath - Path to the package.json file\n * @returns The parsed package.json content or undefined if the file doesn't exist or can't be parsed\n */\nexport function readPackageJsonFile(filePath: string): PackageJson | undefined {\n  if (!existsSync(filePath)) {\n    return undefined;\n  }\n\n  try {\n    const content = readFileSync(filePath, 'utf8');\n    const packageJson = JSON.parse(content) as PackageJson;\n    return packageJson;\n  } catch (error) {\n    cdsExtractorLog('warn', `Error parsing package.json at ${filePath}: ${String(error)}`);\n    return undefined;\n  }\n}\n\n/**\n * Determines which CDS files should be compiled for a given project and what output files to expect.\n * This function analyzes the project structure and dependencies to decide\n * whether to use project-level compilation or individual file compilation.\n *\n * For CAP projects (identified by either having @sap/cds dependencies or\n * typical CAP directory structure), it returns a special marker indicating\n * project-level compilation should be used. For other projects, it attempts\n * to identify root files (files that are not imported by others) and returns\n * those for individual compilation.\n *\n * @param sourceRootDir - The source root directory\n * @param project - The project to analyze, containing cdsFiles, imports, and projectDir\n * @returns Object containing files to compile and expected output files\n */\nexport function determineCdsFilesToCompile(\n  sourceRootDir: string,\n  project: {\n    cdsFiles: string[];\n    imports?: Map<string, CdsImport[]>;\n    projectDir: string;\n  },\n): CdsFilesToCompile {\n  if (!project.cdsFiles || project.cdsFiles.length === 0) {\n    return {\n      filesToCompile: [],\n      expectedOutputFiles: [],\n    };\n  }\n\n  // If there's only one CDS file, it should be compiled individually.\n  if (project.cdsFiles.length === 1) {\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  const absoluteProjectDir = join(sourceRootDir, project.projectDir);\n  const hasCapStructure = hasTypicalCapDirectoryStructure(project.cdsFiles);\n  const hasCapDeps = hasPackageJsonWithCapDeps(absoluteProjectDir);\n\n  // Use project-level compilation only if:\n  // 1. It has CAP package.json dependencies, OR\n  // 2. It has the typical CAP directory structure (db/, srv/ etc.)\n  if (project.cdsFiles.length > 1 && (hasCapStructure || hasCapDeps)) {\n    // For CAP projects, we should use project-level compilation\n    // Return a special marker that indicates the entire project should be compiled together\n    const filesToCompile = ['__PROJECT_LEVEL_COMPILATION__'];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  // For non-CAP projects or when we can't determine project type,\n  // fall back to the original logic of identifying root files\n  if (!project.imports || project.imports.size === 0) {\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n\n  try {\n    // Create a map to track imported files in the project\n    const importedFiles = new Map<string, boolean>();\n\n    // First pass: collect all imported files in the project\n    for (const file of project.cdsFiles) {\n      try {\n        const absoluteFilePath = join(sourceRootDir, file);\n        if (existsSync(absoluteFilePath)) {\n          // Get imports for this file\n          const imports = project.imports.get(file) ?? [];\n\n          // Mark imported files\n          for (const importInfo of imports) {\n            if (importInfo.resolvedPath) {\n              importedFiles.set(importInfo.resolvedPath, true);\n            }\n          }\n        }\n      } catch (error) {\n        cdsExtractorLog('warn', `Error processing imports for ${file}: ${String(error)}`);\n      }\n    }\n\n    // Second pass: identify root files (files that are not imported by others)\n    const rootFiles: string[] = [];\n    for (const file of project.cdsFiles) {\n      const relativePath = relative(sourceRootDir, join(sourceRootDir, file));\n      const isImported = importedFiles.has(relativePath);\n\n      if (!isImported) {\n        rootFiles.push(file);\n      }\n    }\n\n    // If no root files were identified, fall back to compiling all files\n    if (rootFiles.length === 0) {\n      cdsExtractorLog(\n        'warn',\n        `No root CDS files identified in project ${project.projectDir}, will compile all files`,\n      );\n      const filesToCompile = [...project.cdsFiles];\n      return {\n        filesToCompile,\n        expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n      };\n    }\n\n    return {\n      filesToCompile: rootFiles,\n      expectedOutputFiles: computeExpectedOutputFiles(rootFiles, project.projectDir),\n    };\n  } catch (error) {\n    cdsExtractorLog(\n      'warn',\n      `Error determining files to compile for project ${project.projectDir}: ${String(error)}`,\n    );\n    // Fall back to compiling all files on error\n    const filesToCompile = [...project.cdsFiles];\n    return {\n      filesToCompile,\n      expectedOutputFiles: computeExpectedOutputFiles(filesToCompile, project.projectDir),\n    };\n  }\n}\n\n/**\n * Computes the expected output files for a given set of files to compile.\n * This function predicts what .cds.json files will be generated during compilation.\n *\n * @param filesToCompile - Array of files to compile (may include special markers)\n * @param projectDir - The project directory\n * @returns Array of expected output file paths (relative to source root)\n */\nfunction computeExpectedOutputFiles(filesToCompile: string[], projectDir: string): string[] {\n  const expectedFiles: string[] = [];\n\n  // Check if this project uses project-level compilation.\n  const usesProjectLevelCompilation = filesToCompile.includes('__PROJECT_LEVEL_COMPILATION__');\n\n  // Validate that __PROJECT_LEVEL_COMPILATION__ element does not coexist with other\n  // files. We either expect a single project-level compilation marker or a list of\n  // individual files to compile, not both.\n  if (usesProjectLevelCompilation && filesToCompile.length !== 1) {\n    throw new Error(\n      `Invalid compilation configuration: '__PROJECT_LEVEL_COMPILATION__' must be the only element in filesToCompile array, but found ${filesToCompile.length} elements: ${filesToCompile.join(', ')}`,\n    );\n  }\n\n  if (usesProjectLevelCompilation) {\n    // For project-level compilation, expect a single model.cds.json file in the project\n    // root directory.\n    const projectModelFile = join(projectDir, 'model.cds.json');\n    expectedFiles.push(projectModelFile);\n  } else {\n    // For individual file compilation, expect a .cds.json file for each .cds file compiled.\n    for (const cdsFile of filesToCompile) {\n      expectedFiles.push(`${cdsFile}.json`);\n    }\n  }\n\n  return expectedFiles;\n}\n\n/**\n * Determines the expected output files for a project based on its compilation strategy.\n * This function predicts what .cds.json files will be generated during compilation.\n *\n * @param project - The CDS project to analyze\n * @returns Array of expected output file paths (relative to source root)\n */\nexport function determineExpectedOutputFiles(project: {\n  cdsFilesToCompile: string[];\n  projectDir: string;\n}): string[] {\n  const expectedFiles: string[] = [];\n\n  // Check if this project uses project-level compilation.\n  const usesProjectLevelCompilation = project.cdsFilesToCompile.includes(\n    '__PROJECT_LEVEL_COMPILATION__',\n  );\n  // Validate that __PROJECT_LEVEL_COMPILATION__ element does not coexist with other\n  // files. We either expect a single project-level compilation marker or a list of\n  // individual files to compile, not both.\n  if (usesProjectLevelCompilation && project.cdsFilesToCompile.length !== 1) {\n    throw new Error(\n      `Invalid compilation configuration: '__PROJECT_LEVEL_COMPILATION__' must be the only element in cdsFilesToCompile array, but found ${project.cdsFilesToCompile.length} elements: ${project.cdsFilesToCompile.join(', ')}`,\n    );\n  }\n\n  if (usesProjectLevelCompilation) {\n    // For project-level compilation, expect a single model.cds.json file in the project\n    // root directory.\n    const projectModelFile = join(project.projectDir, 'model.cds.json');\n    expectedFiles.push(projectModelFile);\n  } else {\n    // For individual file compilation, expect a .cds.json file for each .cds file compiled.\n    for (const cdsFile of project.cdsFilesToCompile) {\n      expectedFiles.push(`${cdsFile}.json`);\n    }\n  }\n\n  return expectedFiles;\n}\n\n/**\n * Checks if a project has a typical CAP directory structure by looking at the file paths.\n * This is used as a heuristic to determine if project-level compilation should be used.\n *\n * @param cdsFiles - List of CDS files in the project (relative to source root)\n * @returns true if the project appears to have a CAP structure\n */\nfunction hasTypicalCapDirectoryStructure(cdsFiles: string[]): boolean {\n  // Check if there are files in common CAP directories\n  const hasDbFiles = cdsFiles.some(file => file.includes('db/') || file.includes('database/'));\n  const hasSrvFiles = cdsFiles.some(file => file.includes('srv/') || file.includes('service/'));\n\n  // If we have both db and srv files, this looks like a CAP project\n  if (hasDbFiles && hasSrvFiles) {\n    return true;\n  }\n\n  // Check if files are spread across multiple meaningful directories (not just the root)\n  const meaningfulDirectories = new Set(\n    cdsFiles.map(file => dirname(file)).filter(dir => dir !== '.' && dir !== ''), // Exclude root directory\n  );\n\n  // If there are multiple meaningful directories with CDS files, this might be a structured project\n  // But we need to be more selective - only consider it structured if there are actual subdirectories\n  return meaningfulDirectories.size >= 2;\n}\n\n/**\n * Checks if a directory has a package.json with CAP dependencies.\n * This function is used to determine if a directory has the necessary CAP packages installed,\n * which is one indicator that it might be a CAP project.\n *\n * @param dir - Directory to check for package.json with CAP dependencies\n * @returns true if the directory has a package.json with CAP dependencies\n */\nexport function hasPackageJsonWithCapDeps(dir: string): boolean {\n  try {\n    const packageJsonPath = join(dir, 'package.json');\n    const packageJson = readPackageJsonFile(packageJsonPath);\n\n    if (packageJson) {\n      const dependencies = {\n        ...(packageJson.dependencies ?? {}),\n        ...(packageJson.devDependencies ?? {}),\n      };\n\n      // Check for common CAP dependencies\n      return !!(dependencies['@sap/cds'] || dependencies['@sap/cds-dk']);\n    }\n\n    return false;\n  } catch {\n    return false;\n  }\n}\n", "import { spawnSync, SpawnSyncReturns } from 'child_process';\n\nimport { addJavaScriptExtractorDiagnostic } from './diagnostics';\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Run the JavaScript extractor autobuild script\n * @param sourceRoot The source root directory\n * @param autobuildScriptPath Path to the autobuild script\n * @param codeqlExePath Path to the CodeQL executable (optional)\n * @returns Success status and any error message\n */\nexport function runJavaScriptExtractor(\n  sourceRoot: string,\n  autobuildScriptPath: string,\n  codeqlExePath?: string,\n): { success: boolean; error?: string } {\n  cdsExtractorLog(\n    'info',\n    `Extracting the .cds.json files by running the 'javascript' extractor autobuild script:\n        ${autobuildScriptPath}`,\n  );\n\n  /**\n   * Invoke the javascript autobuilder to index the .cds.json files only.\n   *\n   * Environment variables must be passed from this script's process to the\n   * process that invokes the autobuild script, otherwise the CDS autobuild.sh\n   * script will not be invoked by the autobuild script built into the\n   * 'javascript' extractor.\n   *\n   * IMPORTANT: The JavaScript extractor autobuild script must be invoked with\n   * the current working directory set to the project (source) root directory\n   * because it assumes it is running from there.\n   */\n  const result: SpawnSyncReturns<Buffer> = spawnSync(autobuildScriptPath, [], {\n    cwd: sourceRoot,\n    env: process.env,\n    shell: true,\n    stdio: 'inherit',\n  });\n\n  if (result.error) {\n    const errorMessage = `Error running JavaScript extractor: ${result.error.message}`;\n    if (codeqlExePath) {\n      addJavaScriptExtractorDiagnostic(sourceRoot, errorMessage, codeqlExePath);\n    }\n    return {\n      success: false,\n      error: errorMessage,\n    };\n  }\n\n  if (result.status !== 0) {\n    const errorMessage = `JavaScript extractor failed with exit code ${String(result.status)}`;\n    if (codeqlExePath) {\n      addJavaScriptExtractorDiagnostic(sourceRoot, errorMessage, codeqlExePath);\n    }\n    return {\n      success: false,\n      error: errorMessage,\n    };\n  }\n\n  return { success: true };\n}\n", "import { execFileSync } from 'child_process';\nimport { existsSync } from 'fs';\nimport { arch, platform } from 'os';\nimport { join, resolve } from 'path';\n\nimport { dirExists } from './filesystem';\nimport { cdsExtractorLog } from './logging';\n\n/**\n * Interface for platform information\n */\nexport interface PlatformInfo {\n  platform: string;\n  arch: string;\n  isWindows: boolean;\n  exeExtension: string;\n}\n\n/**\n * Interface for environment validation results\n */\nexport interface EnvironmentSetupResult {\n  success: boolean;\n  errorMessages: string[];\n  codeqlExePath: string;\n  jsExtractorRoot: string;\n  autobuildScriptPath: string;\n  platformInfo: PlatformInfo;\n}\n\n/**\n * Get platform information\n * @returns Platform information including OS platform, architecture, and whether it's Windows\n */\nexport function getPlatformInfo(): PlatformInfo {\n  const osPlatform: string = platform();\n  const osPlatformArch: string = arch();\n  const isWindows = osPlatform === 'win32';\n  const exeExtension = isWindows ? '.exe' : '';\n\n  return {\n    platform: osPlatform,\n    arch: osPlatformArch,\n    isWindows,\n    exeExtension,\n  };\n}\n\n/**\n * Get the path to the CodeQL executable.\n * Prioritizes CODEQL_DIST if set and valid. Otherwise, tries to find CodeQL via system PATH.\n * @returns The resolved path to the CodeQL executable, or an empty string if not found.\n */\nexport function getCodeQLExePath(): string {\n  const platformInfo = getPlatformInfo();\n  const codeqlExeName: string = platformInfo.isWindows ? 'codeql.exe' : 'codeql';\n\n  // First, check if CODEQL_DIST is set and valid\n  const codeqlDist = process.env.CODEQL_DIST;\n  if (codeqlDist) {\n    const codeqlPathFromDist = resolve(join(codeqlDist, codeqlExeName));\n    if (existsSync(codeqlPathFromDist)) {\n      cdsExtractorLog('info', `Using CodeQL executable from CODEQL_DIST: ${codeqlPathFromDist}`);\n      return codeqlPathFromDist;\n    } else {\n      cdsExtractorLog(\n        'error',\n        `CODEQL_DIST is set to '${codeqlDist}', but CodeQL executable was not found at '${codeqlPathFromDist}'. Please ensure this path is correct. Falling back to PATH-based discovery.`,\n      );\n      // Fall through to PATH-based discovery\n    }\n  }\n\n  // CODEQL_DIST is not set or was invalid, attempt to find CodeQL via system PATH using 'codeql version --format=json'\n  cdsExtractorLog(\n    'info',\n    'CODEQL_DIST environment variable not set or invalid. Attempting to find CodeQL executable via system PATH using \"codeql version --format=json\".',\n  );\n  try {\n    const versionOutput = execFileSync(codeqlExeName, ['version', '--format=json'], {\n      encoding: 'utf8',\n      timeout: 5000, // 5 seconds timeout\n      stdio: 'pipe', // Suppress output to console\n    });\n\n    interface CodeQLVersionInfo {\n      unpackedLocation?: string;\n      cliVersion?: string; // For potential future use or richer logging\n    }\n\n    try {\n      const versionInfo = JSON.parse(versionOutput) as CodeQLVersionInfo;\n\n      if (\n        versionInfo &&\n        typeof versionInfo.unpackedLocation === 'string' &&\n        versionInfo.unpackedLocation\n      ) {\n        const resolvedPathFromVersion = resolve(join(versionInfo.unpackedLocation, codeqlExeName));\n        if (existsSync(resolvedPathFromVersion)) {\n          cdsExtractorLog(\n            'info',\n            `CodeQL executable found via 'codeql version --format=json' at: ${resolvedPathFromVersion}`,\n          );\n          return resolvedPathFromVersion;\n        }\n        cdsExtractorLog(\n          'warn',\n          `'codeql version --format=json' provided unpackedLocation '${versionInfo.unpackedLocation}', but executable not found at '${resolvedPathFromVersion}'.`,\n        );\n      } else {\n        cdsExtractorLog(\n          'warn',\n          \"Could not determine CodeQL executable path from 'codeql version --format=json' output. 'unpackedLocation' field missing, empty, or invalid.\",\n        );\n      }\n    } catch (parseError) {\n      cdsExtractorLog(\n        'warn',\n        `Failed to parse 'codeql version --format=json' output: ${String(parseError)}. Output was: ${versionOutput}`,\n      );\n    }\n  } catch (error) {\n    let errorMessage = `INFO: Failed to find CodeQL executable via 'codeql version --format=json'. Error: ${String(error)}`;\n    if (error && typeof error === 'object' && 'code' in error && error.code === 'ENOENT') {\n      errorMessage += `\\nINFO: The command '${codeqlExeName}' was not found in your system PATH.`;\n    }\n    cdsExtractorLog('info', errorMessage);\n  }\n\n  cdsExtractorLog(\n    'error',\n    'Failed to determine CodeQL executable path. Please ensure the CODEQL_DIST environment variable is set and points to a valid CodeQL distribution, or that the CodeQL CLI (codeql) is available in your system PATH and \"codeql version --format=json\" can provide its location.',\n  );\n  return ''; // Return empty string if all attempts fail\n}\n\n/**\n * Get the JavaScript extractor root path.\n * @param codeqlExePath The path to the CodeQL executable. If empty, resolution will be skipped.\n * @returns The JavaScript extractor root path, or an empty string if not found or if codeqlExePath is empty.\n */\nexport function getJavaScriptExtractorRoot(codeqlExePath: string): string {\n  let jsExtractorRoot = process.env.CODEQL_EXTRACTOR_JAVASCRIPT_ROOT ?? '';\n\n  if (jsExtractorRoot) {\n    cdsExtractorLog(\n      'info',\n      `Using JavaScript extractor root from environment variable CODEQL_EXTRACTOR_JAVASCRIPT_ROOT: ${jsExtractorRoot}`,\n    );\n    return jsExtractorRoot;\n  }\n\n  if (!codeqlExePath) {\n    cdsExtractorLog(\n      'warn',\n      'Cannot resolve JavaScript extractor root because the CodeQL executable path was not provided or found.',\n    );\n    return '';\n  }\n\n  try {\n    jsExtractorRoot = execFileSync(\n      codeqlExePath,\n      ['resolve', 'extractor', '--language=javascript'],\n      { stdio: 'pipe' }, // Suppress output from the command itself\n    )\n      .toString()\n      .trim();\n    if (jsExtractorRoot) {\n      cdsExtractorLog('info', `JavaScript extractor root resolved to: ${jsExtractorRoot}`);\n    } else {\n      cdsExtractorLog(\n        'warn',\n        `'codeql resolve extractor --language=javascript' using '${codeqlExePath}' returned an empty path.`,\n      );\n    }\n  } catch (error) {\n    cdsExtractorLog(\n      'error',\n      `Error resolving JavaScript extractor root using '${codeqlExePath}': ${String(error)}`,\n    );\n    jsExtractorRoot = ''; // Ensure it's empty on error\n  }\n  return jsExtractorRoot;\n}\n\n/**\n * Set JavaScript extractor environment variables using CDS extractor variables\n */\nexport function setupJavaScriptExtractorEnv(): void {\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_WIP_DATABASE =\n    process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_DIAGNOSTIC_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_DIAGNOSTIC_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_LOG_DIR = process.env.CODEQL_EXTRACTOR_CDS_LOG_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_SCRATCH_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_SCRATCH_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_TRAP_DIR = process.env.CODEQL_EXTRACTOR_CDS_TRAP_DIR;\n  process.env.CODEQL_EXTRACTOR_JAVASCRIPT_SOURCE_ARCHIVE_DIR =\n    process.env.CODEQL_EXTRACTOR_CDS_SOURCE_ARCHIVE_DIR;\n}\n\n/**\n * Get the path to the autobuild script\n * @param jsExtractorRoot The JavaScript extractor root path\n * @returns The path to the autobuild script, or an empty string if jsExtractorRoot is empty.\n */\nexport function getAutobuildScriptPath(jsExtractorRoot: string): string {\n  if (!jsExtractorRoot) return '';\n  const platformInfo = getPlatformInfo();\n  const autobuildScriptName: string = platformInfo.isWindows ? 'autobuild.cmd' : 'autobuild.sh';\n  return resolve(join(jsExtractorRoot, 'tools', autobuildScriptName));\n}\n\n/**\n * Configure LGTM index filters for CDS files\n */\nexport function configureLgtmIndexFilters(): void {\n  let excludeFilters = '';\n\n  if (process.env.LGTM_INDEX_FILTERS) {\n    cdsExtractorLog(\n      'info',\n      `Found $LGTM_INDEX_FILTERS already set to:\n${process.env.LGTM_INDEX_FILTERS}`,\n    );\n    const allowedExcludePatterns = [join('exclude:**', '*'), join('exclude:**', '*.*')];\n\n    excludeFilters =\n      '\\n' +\n      process.env.LGTM_INDEX_FILTERS.split('\\n')\n        .filter(\n          line =>\n            line.startsWith('exclude') &&\n            !allowedExcludePatterns.some(pattern => line.includes(pattern)),\n        )\n        .join('\\n');\n  }\n\n  // Enable extraction of the .cds.json files only.\n  const lgtmIndexFiltersPatterns = [\n    join('exclude:**', '*.*'),\n    join('include:**', '*.cds.json'),\n    join('include:**', '*.cds'),\n    join('exclude:**', 'node_modules', '**', '*.*'),\n  ].join('\\n');\n\n  process.env.LGTM_INDEX_FILTERS = lgtmIndexFiltersPatterns + excludeFilters;\n  process.env.LGTM_INDEX_TYPESCRIPT = 'NONE';\n  // Configure to copy over the .cds files as well, by pretending they are JSON.\n  process.env.LGTM_INDEX_FILETYPES = '.cds:JSON';\n}\n\n/**\n * Sets up the environment and validates key components for running the CDS extractor.\n * This includes checking for the CodeQL executable, validating the source root directory,\n * and setting up environment variables for the JavaScript extractor.\n *\n * @param sourceRoot The source root directory.\n *\n * @returns The {@link EnvironmentSetupResult} containing success status, error messages,\n *          CodeQL executable path, JavaScript extractor root, autobuild script path,\n *          and platform information.\n *\n * @throws Will throw an error if the environment setup fails.\n */\nexport function setupAndValidateEnvironment(sourceRoot: string): EnvironmentSetupResult {\n  const errorMessages: string[] = [];\n  const platformInfo = getPlatformInfo();\n\n  // Get the CodeQL executable path\n  const codeqlExePath = getCodeQLExePath();\n  if (!codeqlExePath) {\n    errorMessages.push(\n      'Failed to find CodeQL executable. Ensure CODEQL_DIST is set and valid, or CodeQL CLI is in PATH.',\n    );\n  }\n\n  // Validate that the required source root directory exists\n  if (!dirExists(sourceRoot)) {\n    errorMessages.push(`Project root directory '${sourceRoot}' does not exist.`);\n  }\n\n  // Get JavaScript extractor root\n  const jsExtractorRoot = getJavaScriptExtractorRoot(codeqlExePath);\n  if (!jsExtractorRoot) {\n    if (codeqlExePath) {\n      // Only add this error if codeqlExePath was found but JS extractor root wasn't\n      errorMessages.push(\n        'Failed to determine JavaScript extractor root using the found CodeQL executable.',\n      );\n    } else {\n      // If codeqlExePath is empty, the error from getCodeQLExePath is usually sufficient.\n      // However, we can add a more specific one if needed.\n      errorMessages.push(\n        'Cannot determine JavaScript extractor root because CodeQL executable was not found.',\n      );\n    }\n  }\n\n  // Set environment variables for JavaScript extractor only if jsExtractorRoot is valid\n  if (jsExtractorRoot) {\n    process.env.CODEQL_EXTRACTOR_JAVASCRIPT_ROOT = jsExtractorRoot;\n    setupJavaScriptExtractorEnv();\n  }\n\n  // Get autobuild script path\n  const autobuildScriptPath = jsExtractorRoot ? getAutobuildScriptPath(jsExtractorRoot) : '';\n  // Not having an autobuild script path might be an error depending on the run mode,\n  // but for now, the function just returns what it found.\n\n  return {\n    success: errorMessages.length === 0,\n    errorMessages,\n    codeqlExePath, // Will be '' if not found\n    jsExtractorRoot, // Will be '' if not found\n    autobuildScriptPath,\n    platformInfo,\n  };\n}\n", "import { execFileSync } from 'child_process';\nimport { createHash } from 'crypto';\nimport { existsSync, mkdirSync, writeFileSync } from 'fs';\nimport { join, resolve } from 'path';\n\nimport type { CdsDependencyCombination } from './types';\nimport { CdsDependencyGraph, CdsProject } from '../cds/parser/types';\nimport { DiagnosticSeverity } from '../diagnostics';\nimport { cdsExtractorLog } from '../logging';\nimport { resolveCdsVersions } from './versionResolver';\n\nconst cacheSubDirName = '.cds-extractor-cache';\n\n/**\n * Add a warning diagnostic for dependency version fallback\n * @param packageJsonPath Path to the package.json file\n * @param warningMessage The warning message\n * @param codeqlExePath Path to the CodeQL executable\n * @returns True if the diagnostic was added, false otherwise\n */\nfunction addDependencyVersionWarning(\n  packageJsonPath: string,\n  warningMessage: string,\n  codeqlExePath: string,\n): boolean {\n  try {\n    execFileSync(codeqlExePath, [\n      'database',\n      'add-diagnostic',\n      '--extractor-name=cds',\n      '--ready-for-status-page',\n      '--source-id=cds/dependency-version-fallback',\n      '--source-name=Using fallback versions for SAP CAP CDS dependencies',\n      `--severity=${DiagnosticSeverity.Warning}`,\n      `--markdown-message=${warningMessage}`,\n      `--file-path=${resolve(packageJsonPath)}`,\n      '--',\n      `${process.env.CODEQL_EXTRACTOR_CDS_WIP_DATABASE ?? ''}`,\n    ]);\n    cdsExtractorLog('info', `Added warning diagnostic for dependency fallback: ${packageJsonPath}`);\n    return true;\n  } catch (err) {\n    cdsExtractorLog(\n      'error',\n      `Failed to add warning diagnostic for ${packageJsonPath}: ${String(err)}`,\n    );\n    return false;\n  }\n}\n\n/**\n * Extracts unique dependency combinations from the dependency graph.\n * @param projects A map of projects from the dependency graph.\n * @returns An array of unique dependency combinations.\n */\nfunction extractUniqueDependencyCombinations(\n  projects: Map<string, CdsProject>,\n): CdsDependencyCombination[] {\n  const combinations = new Map<string, CdsDependencyCombination>();\n\n  for (const project of Array.from(projects.values())) {\n    if (!project.packageJson) {\n      continue;\n    }\n\n    const cdsVersion = project.packageJson.dependencies?.['@sap/cds'] ?? 'latest';\n    const cdsDkVersion = project.packageJson.devDependencies?.['@sap/cds-dk'] ?? cdsVersion;\n\n    // Resolve versions first to ensure we cache based on actual resolved versions\n    cdsExtractorLog(\n      'info',\n      `Resolving available dependency versions for project '${project.projectDir}' with dependencies: [@sap/cds@${cdsVersion}, @sap/cds-dk@${cdsDkVersion}]`,\n    );\n    const resolvedVersions = resolveCdsVersions(cdsVersion, cdsDkVersion);\n    const { resolvedCdsVersion, resolvedCdsDkVersion, ...rest } = resolvedVersions;\n\n    // Log the resolved CDS dependency versions for the project\n    if (resolvedCdsVersion && resolvedCdsDkVersion) {\n      let statusMsg: string;\n      if (resolvedVersions.cdsExactMatch && resolvedVersions.cdsDkExactMatch) {\n        statusMsg = ' (exact match)';\n      } else if (!resolvedVersions.isFallback) {\n        statusMsg = ' (compatible versions)';\n      } else {\n        statusMsg = ' (using fallback versions)';\n      }\n      cdsExtractorLog(\n        'info',\n        `Resolved to: @sap/cds@${resolvedCdsVersion}, @sap/cds-dk@${resolvedCdsDkVersion}${statusMsg}`,\n      );\n    } else {\n      cdsExtractorLog(\n        'error',\n        `Failed to resolve CDS dependencies: @sap/cds@${cdsVersion}, @sap/cds-dk@${cdsDkVersion}`,\n      );\n    }\n\n    // Calculate hash based on resolved versions to ensure proper cache reuse\n    const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n    const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n    const hash = createHash('sha256')\n      .update(`${actualCdsVersion}|${actualCdsDkVersion}`)\n      .digest('hex');\n\n    if (!combinations.has(hash)) {\n      combinations.set(hash, {\n        cdsVersion,\n        cdsDkVersion,\n        hash,\n        resolvedCdsVersion: resolvedCdsVersion ?? undefined,\n        resolvedCdsDkVersion: resolvedCdsDkVersion ?? undefined,\n        ...rest,\n      });\n    }\n  }\n\n  return Array.from(combinations.values());\n}\n\n/**\n * Install dependencies for CDS projects using a robust cache strategy with fallback logic\n * @param dependencyGraph The dependency graph of the project\n * @param sourceRoot Source root directory\n * @param codeqlExePath Path to the CodeQL executable (optional)\n * @returns Map of project directories to their corresponding cache directories\n */\nexport function installDependencies(\n  dependencyGraph: CdsDependencyGraph,\n  sourceRoot: string,\n  codeqlExePath?: string,\n): Map<string, string> {\n  // Sanity check that we found at least one project\n  if (dependencyGraph.projects.size === 0) {\n    cdsExtractorLog('info', 'No CDS projects found for dependency installation.');\n    cdsExtractorLog(\n      'info',\n      'This is expected if the source contains no CAP/CDS projects and should be handled by the caller.',\n    );\n    return new Map<string, string>();\n  }\n\n  // Extract unique dependency combinations from all projects with version resolution\n  const dependencyCombinations = extractUniqueDependencyCombinations(dependencyGraph.projects);\n\n  if (dependencyCombinations.length === 0) {\n    cdsExtractorLog(\n      'error',\n      'No CDS dependencies found in any project. This means projects were detected but lack proper @sap/cds dependencies.',\n    );\n    cdsExtractorLog(\n      'info',\n      'Will attempt to use system-installed CDS tools if available, but compilation may fail.',\n    );\n    return new Map<string, string>();\n  }\n\n  cdsExtractorLog(\n    'info',\n    `Found ${dependencyCombinations.length} unique CDS dependency combination(s).`,\n  );\n\n  // Log each dependency combination for transparency\n  for (const combination of dependencyCombinations) {\n    const { cdsVersion, cdsDkVersion, hash, resolvedCdsVersion, resolvedCdsDkVersion, isFallback } =\n      combination;\n    const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n    const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n    const fallbackNote = isFallback ? ' (using fallback versions)' : '';\n\n    cdsExtractorLog(\n      'info',\n      `Dependency combination ${hash.substring(0, 8)}: @sap/cds@${actualCdsVersion}, @sap/cds-dk@${actualCdsDkVersion}${fallbackNote}`,\n    );\n  }\n\n  // Create a cache directory under the source root directory.\n  const cacheRootDir = join(sourceRoot, cacheSubDirName);\n  cdsExtractorLog(\n    'info',\n    `Using cache directory '${cacheSubDirName}' within source root directory '${cacheRootDir}'`,\n  );\n\n  if (!existsSync(cacheRootDir)) {\n    try {\n      mkdirSync(cacheRootDir, { recursive: true });\n      cdsExtractorLog('info', `Created cache directory: ${cacheRootDir}`);\n    } catch (err) {\n      cdsExtractorLog(\n        'warn',\n        `Failed to create cache directory: ${err instanceof Error ? err.message : String(err)}`,\n      );\n      cdsExtractorLog('info', 'Skipping dependency installation due to cache directory failure.');\n      return new Map<string, string>();\n    }\n  } else {\n    cdsExtractorLog('info', `Cache directory already exists: ${cacheRootDir}`);\n  }\n\n  // Map to track which cache directory to use for each project\n  const projectCacheDirMap = new Map<string, string>();\n  let successfulInstallations = 0;\n\n  // Install each unique dependency combination in its own cache directory\n  for (const combination of dependencyCombinations) {\n    const { cdsVersion, cdsDkVersion, hash } = combination;\n    const { resolvedCdsVersion, resolvedCdsDkVersion } = combination;\n    const cacheDirName = `cds-${hash}`;\n    const cacheDir = join(cacheRootDir, cacheDirName);\n\n    cdsExtractorLog(\n      'info',\n      `Processing dependency combination ${hash.substring(0, 8)} in cache directory: ${cacheDirName}`,\n    );\n\n    // Create the cache directory if it doesn't exist\n    if (!existsSync(cacheDir)) {\n      try {\n        mkdirSync(cacheDir, { recursive: true });\n        cdsExtractorLog('info', `Created cache subdirectory: ${cacheDirName}`);\n      } catch (err) {\n        cdsExtractorLog(\n          'error',\n          `Failed to create cache directory for combination ${hash.substring(0, 8)} (${cacheDirName}): ${\n            err instanceof Error ? err.message : String(err)\n          }`,\n        );\n        continue;\n      }\n\n      // Create a package.json for this dependency combination using resolved versions\n      const actualCdsVersion = resolvedCdsVersion ?? cdsVersion;\n      const actualCdsDkVersion = resolvedCdsDkVersion ?? cdsDkVersion;\n\n      const packageJson = {\n        name: `cds-extractor-cache-${hash}`,\n        version: '1.0.0',\n        private: true,\n        dependencies: {\n          '@sap/cds': actualCdsVersion,\n          '@sap/cds-dk': actualCdsDkVersion,\n        },\n      };\n\n      try {\n        writeFileSync(join(cacheDir, 'package.json'), JSON.stringify(packageJson, null, 2));\n        cdsExtractorLog('info', `Created package.json in cache subdirectory: ${cacheDirName}`);\n      } catch (err) {\n        cdsExtractorLog(\n          'error',\n          `Failed to create package.json in cache directory ${cacheDirName}: ${\n            err instanceof Error ? err.message : String(err)\n          }`,\n        );\n        continue;\n      }\n    }\n\n    // Try to install dependencies in the cache directory\n    // Get the first project package.json path for diagnostic purposes\n    const samplePackageJsonPath = Array.from(dependencyGraph.projects.values()).find(\n      project => project.packageJson,\n    )?.projectDir;\n    const packageJsonPath = samplePackageJsonPath\n      ? join(sourceRoot, samplePackageJsonPath, 'package.json')\n      : undefined;\n\n    const installSuccess = installDependenciesInCache(\n      cacheDir,\n      combination,\n      cacheDirName,\n      packageJsonPath,\n      codeqlExePath,\n    );\n\n    if (!installSuccess) {\n      cdsExtractorLog(\n        'warn',\n        `Skipping failed dependency combination ${hash.substring(0, 8)} (cache directory: ${cacheDirName})`,\n      );\n      continue;\n    }\n\n    successfulInstallations++;\n\n    // Associate projects with this dependency combination\n    for (const [projectDir, project] of Array.from(dependencyGraph.projects.entries())) {\n      if (!project.packageJson) {\n        continue;\n      }\n      const p_cdsVersion = project.packageJson.dependencies?.['@sap/cds'] ?? 'latest';\n      const p_cdsDkVersion = project.packageJson.devDependencies?.['@sap/cds-dk'] ?? p_cdsVersion;\n\n      // Resolve the project's versions to match against the combination's resolved versions\n      const projectResolvedVersions = resolveCdsVersions(p_cdsVersion, p_cdsDkVersion);\n      const projectActualCdsVersion = projectResolvedVersions.resolvedCdsVersion ?? p_cdsVersion;\n      const projectActualCdsDkVersion =\n        projectResolvedVersions.resolvedCdsDkVersion ?? p_cdsDkVersion;\n\n      // Match based on resolved versions since that's what the hash is based on\n      const combinationActualCdsVersion = combination.resolvedCdsVersion ?? combination.cdsVersion;\n      const combinationActualCdsDkVersion =\n        combination.resolvedCdsDkVersion ?? combination.cdsDkVersion;\n\n      if (\n        projectActualCdsVersion === combinationActualCdsVersion &&\n        projectActualCdsDkVersion === combinationActualCdsDkVersion\n      ) {\n        projectCacheDirMap.set(projectDir, cacheDir);\n      }\n    }\n  }\n\n  // Log final status\n  if (successfulInstallations === 0) {\n    cdsExtractorLog('error', 'Failed to install any dependency combinations.');\n    if (dependencyCombinations.length > 0) {\n      cdsExtractorLog(\n        'error',\n        `All ${dependencyCombinations.length} dependency combination(s) failed to install. This will likely cause compilation failures.`,\n      );\n    }\n  } else if (successfulInstallations < dependencyCombinations.length) {\n    cdsExtractorLog(\n      'warn',\n      `Successfully installed ${successfulInstallations} out of ${dependencyCombinations.length} dependency combinations.`,\n    );\n  } else {\n    cdsExtractorLog('info', 'All dependency combinations installed successfully.');\n  }\n\n  // Log project-to-cache-directory mappings for transparency.\n  if (projectCacheDirMap.size > 0) {\n    cdsExtractorLog('info', `Project to cache directory mappings:`);\n    for (const [projectDir, cacheDir] of Array.from(projectCacheDirMap.entries())) {\n      const cacheDirName = join(cacheDir).split('/').pop() ?? 'unknown';\n      cdsExtractorLog('info', `  ${projectDir} \u2192 ${cacheDirName}`);\n    }\n  } else {\n    cdsExtractorLog(\n      'warn',\n      'No project to cache directory mappings created. Projects may not have compatible dependencies installed.',\n    );\n  }\n\n  return projectCacheDirMap;\n}\n\n/**\n * Attempt to install dependencies in a cache directory with fallback logic\n * @param cacheDir Cache directory path\n * @param combination Dependency combination to install\n * @param cacheDirName Name of the cache directory for logging\n * @param packageJsonPath Optional package.json path for diagnostics\n * @param codeqlExePath Optional CodeQL executable path for diagnostics\n * @returns True if installation succeeded, false otherwise\n */\nfunction installDependenciesInCache(\n  cacheDir: string,\n  combination: CdsDependencyCombination,\n  cacheDirName: string,\n  packageJsonPath?: string,\n  codeqlExePath?: string,\n): boolean {\n  const { resolvedCdsVersion, resolvedCdsDkVersion, isFallback, warning } = combination;\n\n  // Check if node_modules directory already exists in the cache dir\n  const nodeModulesExists =\n    existsSync(join(cacheDir, 'node_modules', '@sap', 'cds')) &&\n    existsSync(join(cacheDir, 'node_modules', '@sap', 'cds-dk'));\n\n  if (nodeModulesExists) {\n    cdsExtractorLog(\n      'info',\n      `Using cached dependencies for @sap/cds@${resolvedCdsVersion} and @sap/cds-dk@${resolvedCdsDkVersion} from ${cacheDirName}`,\n    );\n\n    // Add warning diagnostic if using fallback versions\n    if (isFallback && warning && packageJsonPath && codeqlExePath) {\n      addDependencyVersionWarning(packageJsonPath, warning, codeqlExePath);\n    }\n\n    return true;\n  }\n\n  if (!resolvedCdsVersion || !resolvedCdsDkVersion) {\n    cdsExtractorLog('error', 'Cannot install dependencies: no compatible versions found');\n    return false;\n  }\n\n  // Install dependencies in the cache directory\n  cdsExtractorLog(\n    'info',\n    `Installing @sap/cds@${resolvedCdsVersion} and @sap/cds-dk@${resolvedCdsDkVersion} in cache directory: ${cacheDirName}`,\n  );\n\n  if (isFallback && warning) {\n    cdsExtractorLog('warn', warning);\n  }\n\n  try {\n    execFileSync('npm', ['install', '--quiet', '--no-audit', '--no-fund'], {\n      cwd: cacheDir,\n      stdio: 'inherit',\n    });\n\n    // Add warning diagnostic if using fallback versions\n    if (isFallback && warning && packageJsonPath && codeqlExePath) {\n      addDependencyVersionWarning(packageJsonPath, warning, codeqlExePath);\n    }\n\n    return true;\n  } catch (err) {\n    const errorMessage = `Failed to install resolved dependencies in cache directory ${cacheDir}: ${err instanceof Error ? err.message : String(err)}`;\n    cdsExtractorLog('error', errorMessage);\n    return false;\n  }\n}\n", "import { execSync } from 'child_process';\n\nimport { quote } from 'shell-quote';\n\nimport type { SemanticVersion } from './types';\nimport { cdsExtractorLog } from '../logging';\n\n/**\n * Cache for storing available versions for npm packages to avoid duplicate\n * `npm view` calls.\n */\nconst availableVersionsCache = new Map<string, string[]>();\n\n/**\n * Cache statistics for debugging purposes\n */\nconst cacheStats = {\n  hits: 0,\n  misses: 0,\n  get hitRate() {\n    const total = this.hits + this.misses;\n    return total > 0 ? ((this.hits / total) * 100).toFixed(1) : '0.0';\n  },\n};\n\n/**\n * Check if @sap/cds and @sap/cds-dk versions are likely compatible.\n * @param cdsVersion The @sap/cds version\n * @param cdsDkVersion The @sap/cds-dk version\n * @returns Object with compatibility information and warnings\n */\nexport function checkVersionCompatibility(\n  cdsVersion: string,\n  cdsDkVersion: string,\n): {\n  isCompatible: boolean;\n  warning?: string;\n} {\n  // If either version is 'latest', assume they are compatible\n  if (cdsVersion === 'latest' || cdsDkVersion === 'latest') {\n    return { isCompatible: true };\n  }\n\n  const parsedCds = parseSemanticVersion(cdsVersion);\n  const parsedCdsDk = parseSemanticVersion(cdsDkVersion);\n\n  if (!parsedCds || !parsedCdsDk) {\n    return {\n      isCompatible: false,\n      warning: 'Unable to parse version numbers for compatibility check',\n    };\n  }\n\n  // Generally, @sap/cds and @sap/cds-dk should have the same major version\n  // and ideally the same minor version for best compatibility\n  const majorVersionsMatch = parsedCds.major === parsedCdsDk.major;\n  const minorVersionsMatch = parsedCds.minor === parsedCdsDk.minor;\n\n  if (!majorVersionsMatch) {\n    return {\n      isCompatible: false,\n      warning: `Major version mismatch: @sap/cds ${cdsVersion} and @sap/cds-dk ${cdsDkVersion} may not be compatible`,\n    };\n  }\n\n  if (!minorVersionsMatch) {\n    return {\n      isCompatible: true,\n      warning: `Minor version difference: @sap/cds ${cdsVersion} and @sap/cds-dk ${cdsDkVersion} - consider aligning versions for best compatibility`,\n    };\n  }\n\n  return { isCompatible: true };\n}\n\n/**\n * Compare two semantic versions\n * @param a First version\n * @param b Second version\n * @returns Negative if a < b, 0 if equal, positive if a > b\n */\nexport function compareVersions(a: SemanticVersion, b: SemanticVersion): number {\n  if (a.major !== b.major) return a.major - b.major;\n  if (a.minor !== b.minor) return a.minor - b.minor;\n  if (a.patch !== b.patch) return a.patch - b.patch;\n\n  // Handle prerelease versions (prerelease < release)\n  if (a.prerelease && !b.prerelease) return -1;\n  if (!a.prerelease && b.prerelease) return 1;\n  if (a.prerelease && b.prerelease) {\n    return a.prerelease.localeCompare(b.prerelease);\n  }\n\n  return 0;\n}\n\n/**\n * Find the best available version from a list of versions for a given requirement\n * @param availableVersions List of available version strings\n * @param requiredVersion Required version string\n * @returns Best matching version or null if no compatible version found\n */\nexport function findBestAvailableVersion(\n  availableVersions: string[],\n  requiredVersion: string,\n): string | null {\n  const parsedVersions = availableVersions\n    .map(v => parseSemanticVersion(v))\n    .filter((v): v is SemanticVersion => v !== null);\n\n  if (parsedVersions.length === 0) {\n    return null;\n  }\n\n  // First, try to find versions that satisfy the range\n  const satisfyingVersions = parsedVersions.filter(v => satisfiesRange(v, requiredVersion));\n\n  if (satisfyingVersions.length > 0) {\n    // Sort in descending order (newest first) and return the best match\n    satisfyingVersions.sort((a, b) => compareVersions(b, a));\n    return satisfyingVersions[0].original;\n  }\n\n  // If no exact match, prefer newer versions over older ones\n  // Sort all versions in descending order and return the newest\n  parsedVersions.sort((a, b) => compareVersions(b, a));\n  return parsedVersions[0].original;\n}\n\n/**\n * Get available versions for an npm package with caching to avoid duplicate npm view calls\n * @param packageName Name of the npm package\n * @returns Array of available version strings\n */\nexport function getAvailableVersions(packageName: string): string[] {\n  // Check cache first\n  if (availableVersionsCache.has(packageName)) {\n    cacheStats.hits++;\n    return availableVersionsCache.get(packageName)!;\n  }\n\n  // Cache miss - fetch from npm\n  cacheStats.misses++;\n  try {\n    // Use shell-quote to properly escape the package name to prevent injection\n    const escapedPackageName = quote([packageName]);\n    const output = execSync(`npm view ${escapedPackageName} versions --json`, {\n      encoding: 'utf8',\n      timeout: 30000, // 30 second timeout\n    });\n\n    const versions: unknown = JSON.parse(output);\n    let versionArray: string[] = [];\n\n    if (Array.isArray(versions)) {\n      versionArray = versions.filter((v): v is string => typeof v === 'string');\n    } else if (typeof versions === 'string') {\n      versionArray = [versions];\n    }\n\n    // Cache the result\n    availableVersionsCache.set(packageName, versionArray);\n\n    return versionArray;\n  } catch (error) {\n    cdsExtractorLog('warn', `Failed to fetch versions for ${packageName}: ${String(error)}`);\n    // Cache empty array to avoid repeated failures\n    availableVersionsCache.set(packageName, []);\n    return [];\n  }\n}\n\n/**\n * Get cache statistics for debugging purposes\n * @returns Object with cache hit/miss statistics\n */\nexport function getCacheStatistics(): {\n  hits: number;\n  misses: number;\n  hitRate: string;\n  cachedPackages: string[];\n} {\n  return {\n    hits: cacheStats.hits,\n    misses: cacheStats.misses,\n    hitRate: cacheStats.hitRate,\n    cachedPackages: Array.from(availableVersionsCache.keys()),\n  };\n}\n\n/**\n * Parse a semantic version string\n * @param version Version string to parse (e.g., \"6.1.3\", \"^6.0.0\", \"~6.1.0\", \"latest\")\n * @returns Parsed semantic version or null if invalid\n */\nexport function parseSemanticVersion(version: string): SemanticVersion | null {\n  if (version === 'latest') {\n    // Return a very high version number for 'latest' to ensure it's preferred\n    return {\n      major: 999,\n      minor: 999,\n      patch: 999,\n      original: version,\n    };\n  }\n\n  // Remove common version prefixes\n  const cleanVersion = version.replace(/^[\\^~>=<]+/, '');\n\n  // Basic semver regex\n  const semverRegex = /^(\\d+)\\.(\\d+)\\.(\\d+)(?:-([a-zA-Z0-9.-]+))?(?:\\+([a-zA-Z0-9.-]+))?$/;\n  const match = cleanVersion.match(semverRegex);\n\n  if (!match) {\n    return null;\n  }\n\n  return {\n    major: parseInt(match[1], 10),\n    minor: parseInt(match[2], 10),\n    patch: parseInt(match[3], 10),\n    prerelease: match[4],\n    build: match[5],\n    original: version,\n  };\n}\n\n/**\n * Check if a resolved version satisfies the originally requested version.\n * @param resolvedVersion The version that was resolved\n * @param requestedVersion The originally requested version\n * @returns true if the resolved version satisfies the requested version range\n */\nfunction isSatisfyingVersion(resolvedVersion: string, requestedVersion: string): boolean {\n  // Exact string match or 'latest' case\n  if (resolvedVersion === requestedVersion || requestedVersion === 'latest') {\n    return true;\n  }\n\n  const parsedResolved = parseSemanticVersion(resolvedVersion);\n  if (!parsedResolved) {\n    return false;\n  }\n\n  return satisfiesRange(parsedResolved, requestedVersion);\n}\n\n/**\n * Resolve the best available version for CDS dependencies\n * @param cdsVersion Required @sap/cds version\n * @param cdsDkVersion Required @sap/cds-dk version\n * @returns Object with resolved versions and compatibility info\n */\nexport function resolveCdsVersions(\n  cdsVersion: string,\n  cdsDkVersion: string,\n): {\n  resolvedCdsVersion: string | null;\n  resolvedCdsDkVersion: string | null;\n  cdsExactMatch: boolean;\n  cdsDkExactMatch: boolean;\n  warning?: string;\n  isFallback?: boolean;\n} {\n  const cdsVersions = getAvailableVersions('@sap/cds');\n  const cdsDkVersions = getAvailableVersions('@sap/cds-dk');\n\n  const resolvedCdsVersion = findBestAvailableVersion(cdsVersions, cdsVersion);\n  const resolvedCdsDkVersion = findBestAvailableVersion(cdsDkVersions, cdsDkVersion);\n\n  // Check if resolved versions are exact matches (string equality or 'latest' case).\n  const cdsExactMatch =\n    resolvedCdsVersion === cdsVersion || (cdsVersion === 'latest' && resolvedCdsVersion !== null);\n  const cdsDkExactMatch =\n    resolvedCdsDkVersion === cdsDkVersion ||\n    (cdsDkVersion === 'latest' && resolvedCdsDkVersion !== null);\n\n  // Check if resolved versions satisfy the requested ranges (including exact matches).\n  const cdsSatisfiesRange = resolvedCdsVersion\n    ? isSatisfyingVersion(resolvedCdsVersion, cdsVersion)\n    : false;\n  const cdsDkSatisfiesRange = resolvedCdsDkVersion\n    ? isSatisfyingVersion(resolvedCdsDkVersion, cdsDkVersion)\n    : false;\n\n  // Only consider it a fallback if we couldn't find a satisfying version.\n  const isFallback = !cdsSatisfiesRange || !cdsDkSatisfiesRange;\n\n  let warning: string | undefined;\n\n  // Check compatibility between resolved versions (only if both were resolved).\n  // Show warnings when:\n  // 1. We're using fallback versions (couldn't find compatible versions), OR\n  // 2. At least one version isn't an exact match (version range was used), OR\n  // 3. Resolved versions have actual compatibility issues (e.g., major version mismatch).\n  if (resolvedCdsVersion && resolvedCdsDkVersion) {\n    const compatibility = checkVersionCompatibility(resolvedCdsVersion, resolvedCdsDkVersion);\n\n    const shouldShowWarning =\n      isFallback ||\n      !cdsExactMatch ||\n      !cdsDkExactMatch ||\n      (compatibility.warning && !compatibility.isCompatible);\n\n    if (compatibility.warning && shouldShowWarning) {\n      warning = compatibility.warning;\n    }\n  }\n\n  return {\n    resolvedCdsVersion,\n    resolvedCdsDkVersion,\n    cdsExactMatch,\n    cdsDkExactMatch,\n    warning,\n    isFallback,\n  };\n}\n\n/**\n * Check if version satisfies a version range.\n * @param version Version to check\n * @param range Version range (e.g., \"^6.0.0\", \"~6.1.0\", \">=6.0.0\")\n * @returns true if version satisfies the range\n */\nexport function satisfiesRange(version: SemanticVersion, range: string): boolean {\n  if (range === 'latest') {\n    return true;\n  }\n\n  const rangeVersion = parseSemanticVersion(range);\n  if (!rangeVersion) {\n    return false;\n  }\n\n  if (range.startsWith('^')) {\n    // Caret range: compatible within same major version\n    return version.major === rangeVersion.major && compareVersions(version, rangeVersion) >= 0;\n  } else if (range.startsWith('~')) {\n    // Tilde range: compatible within same minor version\n    return (\n      version.major === rangeVersion.major &&\n      version.minor === rangeVersion.minor &&\n      compareVersions(version, rangeVersion) >= 0\n    );\n  } else if (range.startsWith('>=')) {\n    // Greater than or equal\n    return compareVersions(version, rangeVersion) >= 0;\n  } else if (range.startsWith('>')) {\n    // Greater than\n    return compareVersions(version, rangeVersion) > 0;\n  } else if (range.startsWith('<=')) {\n    // Less than or equal\n    return compareVersions(version, rangeVersion) <= 0;\n  } else if (range.startsWith('<')) {\n    // Less than\n    return compareVersions(version, rangeVersion) < 0;\n  } else {\n    // Exact match\n    return compareVersions(version, rangeVersion) === 0;\n  }\n}\n\n/**\n * Test-only exports - DO NOT USE IN PRODUCTION CODE\n * These are exported only for testing purposes\n */\nexport const __testOnly__ = {\n  availableVersionsCache,\n  cacheStats,\n};\n", "import { resolve } from 'path';\n\nconst USAGE_MESSAGE = `\\tUsage: node <script> <source-root>`;\n\n/**\n * Resolves and validates a source root directory path.\n *\n * This function takes a source root path, validates it, normalizes it,\n * and returns an absolute path to the directory.\n *\n * @param sourceRoot - The source root path to resolve\n * @returns The normalized absolute path to the source root directory\n * @throws {Error} If the source root is null, undefined, an empty string,\n *                 or does not point to a valid directory\n */\nfunction resolveSourceRoot(sourceRoot: string): string {\n  // Check for null, undefined, or empty string\n  if (!sourceRoot || typeof sourceRoot !== 'string') {\n    throw new Error('Source root must be a non-empty string');\n  }\n\n  // Normalize the path and resolve it to an absolute path.\n  const normalizedPath = resolve(sourceRoot);\n\n  // Check if the resolved path points to a valid, existing directory.\n  if (!normalizedPath || normalizedPath === '/') {\n    throw new Error('Source root must point to a valid directory');\n  }\n\n  return normalizedPath;\n}\n\n/**\n * Check if the script was invoked with the required arguments.\n * This function validates and sanitizes script arguments and returns them if valid.\n *\n * Requirements:\n * - Only requires: <source-root>\n *\n * @param args Command line arguments to check.\n * @returns Object with validation result, usage message if failed, and validated\n * arguments if successful.\n */\nexport function validateArguments(args: string[]): {\n  isValid: boolean;\n  usageMessage?: string;\n  args?: {\n    sourceRoot: string;\n  };\n} {\n  // Minimum arguments: node, script, source-root (3 total)\n  if (args.length < 3) {\n    return {\n      isValid: false,\n      usageMessage: USAGE_MESSAGE,\n    };\n  }\n\n  // Get the source root from args (now the first parameter after script name)\n  const rawSourceRoot: string = args[2];\n\n  // Validate and sanitize the source root path\n  let sourceRoot: string;\n  try {\n    sourceRoot = resolveSourceRoot(rawSourceRoot);\n  } catch (error) {\n    return {\n      isValid: false,\n      usageMessage: `Invalid source root: ${String(error)}`,\n    };\n  }\n\n  // Return the validated arguments\n  return {\n    isValid: true,\n    usageMessage: `<source-root>`,\n    args: {\n      sourceRoot,\n    },\n  };\n}\n"],
  "mappings": "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",
  "names": ["require_quote", "__commonJSMin", "exports", "module", "xs", "s", "require_parse", "__commonJSMin", "exports", "module", "CONTROL", "controlRE", "META", "SINGLE_QUOTE", "DOUBLE_QUOTE", "hash", "SQ", "DQ", "DS", "TOKEN", "mult", "i", "startsWithToken", "matchAll", "s", "r", "origIndex", "matches", "matchObj", "getVar", "env", "pre", "key", "parseInternal", "string", "opts", "BS", "BAREWORD", "chunker", "commented", "match", "quote", "esc", "out", "isGlob", "parseEnvVar", "varend", "varname", "char", "slicedFromI", "c", "commentObj", "prev", "arg", "mapped", "acc", "xs", "x", "require_shell_quote", "__commonJSMin", "exports", "import_path", "balanced", "a", "b", "str", "ma", "maybeMatch", "mb", "r", "range", "reg", "m", "begs", "beg", "left", "right", "result", "ai", "bi", "i", "escSlash", "escOpen", "escClose", "escComma", "escPeriod", "escSlashPattern", "escOpenPattern", "escClosePattern", "escCommaPattern", "escPeriodPattern", "slashPattern", "openPattern", "closePattern", "commaPattern", "periodPattern", "numeric", "str", "escapeBraces", "unescapeBraces", "parseCommaParts", "parts", "m", "balanced", "pre", "body", "post", "p", "postParts", "expand", "expand_", "embrace", "isPadded", "el", "lte", "i", "y", "gte", "isTop", "expansions", "k", "expansion", "isNumericSequence", "isAlphaSequence", "isSequence", "isOptions", "n", "N", "x", "width", "incr", "test", "pad", "c", "need", "z", "j", "assertValidPattern", "pattern", "posixClasses", "braceEscape", "s", "regexpEscape", "rangesToString", "ranges", "parseClass", "glob", "position", "pos", "negs", "i", "sawStart", "uflag", "escaping", "negate", "endPos", "rangeStart", "WHILE", "c", "cls", "unip", "u", "neg", "r", "sranges", "snegs", "unescape", "s", "windowsPathsNoEscape", "types", "isExtglobType", "c", "startNoTraversal", "startNoDot", "addPatternStart", "justDots", "reSpecials", "regExpEscape", "s", "qmark", "star", "starNoEmpty", "AST", "_AST", "#root", "#hasMagic", "#uflag", "#parts", "#parent", "#parentIndex", "#negs", "#filledNegs", "#options", "#toString", "#emptyExt", "type", "parent", "options", "p", "#fillNegs", "n", "pp", "part", "parts", "ret", "i", "pl", "#parseAST", "str", "ast", "pos", "opt", "escaping", "inBrace", "braceStart", "braceNeg", "acc", "ext", "pattern", "glob", "re", "body", "hasMagic", "uflag", "flags", "allowDot", "dot", "noEmpty", "src", "_", "#parseGlob", "start", "aps", "needNoTrav", "needNoDot", "end", "unescape", "repeated", "#partsToRegExp", "bodyDotAllowed", "final", "close", "_hasMagic", "needUflag", "consumed", "magic", "parseClass", "escape", "s", "windowsPathsNoEscape", "minimatch", "p", "pattern", "options", "assertValidPattern", "Minimatch", "starDotExtRE", "starDotExtTest", "ext", "f", "starDotExtTestDot", "starDotExtTestNocase", "starDotExtTestNocaseDot", "starDotStarRE", "starDotStarTest", "starDotStarTestDot", "dotStarRE", "dotStarTest", "starRE", "starTest", "starTestDot", "qmarksRE", "qmarksTestNocase", "$0", "noext", "qmarksTestNoExt", "qmarksTestNocaseDot", "qmarksTestNoExtDot", "qmarksTestDot", "qmarksTest", "len", "defaultPlatform", "path", "sep", "GLOBSTAR", "qmark", "star", "twoStarDot", "twoStarNoDot", "filter", "a", "b", "defaults", "def", "orig", "type", "parent", "list", "braceExpand", "expand", "makeRe", "match", "mm", "globMagic", "regExpEscape", "s", "part", "_", "args", "rawGlobParts", "set", "__", "isUNC", "isDrive", "ss", "i", "globParts", "j", "optimizationLevel", "parts", "gs", "prev", "didSomething", "dd", "gss", "next", "p2", "other", "splin", "matched", "emptyGSMatch", "ai", "bi", "result", "which", "negate", "negateOffset", "file", "partial", "fileDrive", "fileUNC", "patternDrive", "patternUNC", "fdi", "pdi", "fd", "pd", "fi", "pi", "fl", "pl", "fr", "pr", "swallowee", "hit", "m", "fastTest", "re", "AST", "twoStar", "flags", "pp", "open", "close", "ff", "filename", "escape", "unescape", "import_node_url", "perf", "warned", "PROCESS", "emitWarning", "msg", "type", "code", "fn", "AC", "AS", "_", "warnACPolyfill", "reason", "printACPolyfillWarning", "shouldWarn", "TYPE", "isPosInt", "n", "getUintArray", "max", "ZeroArray", "size", "Stack", "_Stack", "#constructing", "HeapCls", "LRUCache", "_LRUCache", "#max", "#maxSize", "#dispose", "#onInsert", "#disposeAfter", "#fetchMethod", "#memoMethod", "#size", "#calculatedSize", "#keyMap", "#keyList", "#valList", "#next", "#prev", "#head", "#tail", "#free", "#disposed", "#sizes", "#starts", "#ttls", "#hasDispose", "#hasFetchMethod", "#hasDisposeAfter", "#hasOnInsert", "c", "p", "#isBackgroundFetch", "k", "index", "options", "context", "#backgroundFetch", "#moveToTail", "#indexes", "#rindexes", "#isStale", "ttl", "ttlResolution", "ttlAutopurge", "updateAgeOnGet", "updateAgeOnHas", "allowStale", "dispose", "onInsert", "disposeAfter", "noDisposeOnSet", "noUpdateTTL", "maxSize", "maxEntrySize", "sizeCalculation", "fetchMethod", "memoMethod", "noDeleteOnFetchRejection", "noDeleteOnStaleGet", "allowStaleOnFetchRejection", "allowStaleOnFetchAbort", "ignoreFetchAbort", "UintArray", "#initializeSizeTracking", "#initializeTTLTracking", "key", "ttls", "starts", "#setItemTTL", "start", "t", "#delete", "#updateItemAge", "#statusTTL", "status", "cachedNow", "getNow", "age", "s", "sizes", "#removeItemSize", "#requireSize", "v", "#addItemSize", "#evict", "_i", "_s", "_st", "_k", "_v", "i", "#isValidIndex", "getOptions", "value", "thisp", "deleted", "entry", "remain", "arr", "setOptions", "oldVal", "oldValue", "dt", "task", "val", "free", "head", "hasOptions", "peekOptions", "ac", "signal", "fetchOpts", "cb", "updateCache", "aborted", "ignoreAbort", "fetchFail", "bf", "eb", "er", "allowStaleAborted", "noDelete", "pcall", "res", "rej", "fmp", "b", "fetchOptions", "forceRefresh", "stale", "isStale", "staleVal", "memoOptions", "vv", "fetching", "#connect", "#clear", "pi", "ni", "import_node_path", "import_node_url", "import_fs", "actualFS", "import_promises", "import_node_events", "import_node_stream", "import_node_string_decoder", "proc", "isStream", "s", "Minipass", "Stream", "isReadable", "isWritable", "EOF", "MAYBE_EMIT_END", "EMITTED_END", "EMITTING_END", "EMITTED_ERROR", "CLOSED", "READ", "FLUSH", "FLUSHCHUNK", "ENCODING", "DECODER", "FLOWING", "PAUSED", "RESUME", "BUFFER", "PIPES", "BUFFERLENGTH", "BUFFERPUSH", "BUFFERSHIFT", "OBJECTMODE", "DESTROYED", "ERROR", "EMITDATA", "EMITEND", "EMITEND2", "ASYNC", "ABORT", "ABORTED", "SIGNAL", "DATALISTENERS", "DISCARDED", "defer", "fn", "nodefer", "isEndish", "ev", "isArrayBufferLike", "b", "isArrayBufferView", "Pipe", "src", "dest", "opts", "_er", "PipeProxyErrors", "er", "isObjectModeOptions", "o", "isEncodingOptions", "args", "options", "signal", "_enc", "_om", "a", "_", "chunk", "encoding", "cb", "n", "ret", "c", "noDrain", "ended", "p", "handler", "h", "data", "buf", "resolve", "reject", "stopped", "stop", "res", "onerr", "ondata", "onend", "ondestroy", "value", "rej", "next", "wc", "realpathSync", "rps", "defaultFS", "readdirCB", "fsFromOption", "fsOption", "actualFS", "uncDriveRegexp", "uncToDrive", "rootPath", "eitherSep", "UNKNOWN", "IFIFO", "IFCHR", "IFDIR", "IFBLK", "IFREG", "IFLNK", "IFSOCK", "IFMT", "IFMT_UNKNOWN", "READDIR_CALLED", "LSTAT_CALLED", "ENOTDIR", "ENOENT", "ENOREADLINK", "ENOREALPATH", "ENOCHILD", "TYPEMASK", "entToType", "s", "normalizeCache", "normalize", "c", "n", "normalizeNocaseCache", "normalizeNocase", "ResolveCache", "LRUCache", "ChildrenCache", "maxSize", "a", "setAsCwd", "PathBase", "#fs", "#dev", "#mode", "#nlink", "#uid", "#gid", "#rdev", "#blksize", "#ino", "#size", "#blocks", "#atimeMs", "#mtimeMs", "#ctimeMs", "#birthtimeMs", "#atime", "#mtime", "#ctime", "#birthtime", "#matchName", "#depth", "#fullpath", "#fullpathPosix", "#relative", "#relativePosix", "#type", "#children", "#linkTarget", "#realpath", "name", "type", "root", "roots", "nocase", "children", "opts", "path", "dirParts", "#resolveParts", "p", "part", "cached", "pathPart", "fullpath", "pchild", "pv", "fp", "pfpp", "fpp", "ifmt", "target", "read", "linkTarget", "er", "#readlinkFail", "#readdirSuccess", "#markENOENT", "#markChildrenENOENT", "#markENOREALPATH", "#markENOTDIR", "#readdirFail", "code", "#lstatFail", "ter", "#readdirAddChild", "e", "#readdirMaybePromoteChild", "#readdirAddNewChild", "child", "#readdirPromoteChild", "index", "v", "#applyStat", "st", "atime", "atimeMs", "birthtime", "birthtimeMs", "blksize", "blocks", "ctime", "ctimeMs", "dev", "gid", "ino", "mode", "mtime", "mtimeMs", "nlink", "rdev", "size", "uid", "#onReaddirCB", "#readdirCBInFlight", "#callOnReaddirCB", "cbs", "cb", "allowZalgo", "entries", "#asyncReaddirInFlight", "resolve", "res", "dirs", "walkFilter", "rp", "oldCwd", "changed", "PathWin32", "_PathWin32", "compare", "PathScurryWin32", "PathPosix", "_PathPosix", "_rootPath", "PathScurryBase", "#resolveCache", "#resolvePosixCache", "cwd", "pathImpl", "sep", "childrenCacheSize", "fs", "cwdPath", "split", "prev", "len", "joinSep", "abs", "sawFirst", "l", "paths", "r", "i", "result", "entry", "withFileTypes", "follow", "filter", "results", "walk", "dir", "next", "start", "rej", "options", "Minipass", "queue", "processing", "process", "paused", "onReaddir", "didRealpaths", "promises", "sync", "PathScurryPosix", "_dir", "PathScurryDarwin", "Path", "PathScurry", "isPatternList", "pl", "isGlobList", "gl", "Pattern", "_Pattern", "#patternList", "#globList", "#index", "#platform", "#rest", "#globString", "#isDrive", "#isUNC", "#isAbsolute", "#followGlobstar", "patternList", "globList", "index", "platform", "p0", "p1", "p2", "p3", "prest", "g0", "g1", "g2", "g3", "grest", "p", "g", "GLOBSTAR", "defaultPlatform", "Ignore", "ignored", "nobrace", "nocase", "noext", "noglobstar", "platform", "ign", "mm", "Minimatch", "i", "parsed", "globParts", "p", "Pattern", "m", "children", "absolute", "fullpath", "fullpaths", "relative", "relatives", "HasWalkedCache", "_HasWalkedCache", "store", "target", "pattern", "fullpath", "cached", "MatchRecord", "absolute", "ifDir", "n", "current", "path", "SubWalks", "subs", "p", "k", "Processor", "_Processor", "opts", "hasWalkedCache", "patterns", "processingSet", "t", "root", "rest", "changed", "GLOBSTAR", "rp", "rrest", "tp", "parent", "entries", "results", "e", "ep", "makeIgnore", "ignore", "opts", "Ignore", "GlobUtil", "#onResume", "#ignore", "#sep", "patterns", "path", "m", "#ignored", "#childrenIgnored", "fn", "e", "ifDir", "rpc", "s", "target", "absolute", "ign", "abs", "mark", "rel", "pre", "p", "cb", "Processor", "processor", "tasks", "next", "t", "childrenCached", "_", "entries", "children", "GlobWalker", "res", "rej", "GlobStream", "Minipass", "defaultPlatform", "Glob", "pattern", "opts", "p", "Scurry", "PathScurryWin32", "PathScurryDarwin", "PathScurryPosix", "PathScurry", "nocaseMagicOnly", "mmo", "mms", "Minimatch", "matchSet", "globParts", "set", "m", "i", "g", "Pattern", "GlobWalker", "GlobStream", "hasMagic", "pattern", "options", "p", "Minimatch", "globStreamSync", "pattern", "options", "Glob", "globStream", "globSync", "glob_", "globIterateSync", "globIterate", "streamSync", "stream", "iterateSync", "iterate", "sync", "glob", "hasMagic", "escape", "unescape", "import_child_process", "import_fs", "import_path", "import_shell_quote", "import_fs", "import_path", "sourceRootDirectory", "sessionId", "extractorStartTime", "performanceTracking", "cdsExtractorLog", "level", "message", "optionalParams", "elapsedMs", "levelPrefix", "formatDuration", "startTime", "endTime", "durationMs", "minutes", "seconds", "logExtractorStart", "sourceRoot", "logExtractorStop", "success", "additionalSummary", "totalDuration", "status", "logPerformanceMilestone", "milestone", "additionalInfo", "currentTime", "overallDuration", "info", "logPerformanceTrackingStart", "operationName", "logPerformanceTrackingStop", "duration", "setSourceRootDirectory", "generateStatusReport", "dependencyGraph", "summary", "lines", "parsingPct", "compilationPct", "extractionPct", "error", "warning", "dirExists", "dirPath", "fileExists", "filePath", "recursivelyRenameJsonFiles", "cdsExtractorLog", "entries", "entry", "fullPath", "newPath", "cdsCommandCache", "determineCdsCommand", "cacheDir", "sourceRoot", "getBestCdsCommand", "error", "errorMessage", "cdsExtractorLog", "discoverAvailableCacheDirs", "cacheRootDir", "availableDirs", "entries", "entry", "cdsBin", "fileExists", "initializeCdsCommandCache", "localCdsBin", "testCdsCommand", "availableCacheDir", "fallbackCommands", "command", "globalCommands", "result", "cacheDirs", "testCdsCommand", "command", "sourceRoot", "silent", "cachedResult", "cdsCommandCache", "result", "cleanEnv", "parts", "nodeExecutable", "scriptPath", "escapedCommand", "versionMatch", "testResult", "error", "errorMessage", "cdsExtractorLog", "import_child_process", "import_path", "import_child_process", "import_path", "getCdsVersion", "cdsCommand", "cacheDir", "spawnOptions", "nodePath", "result", "versionOutput", "match", "compileCdsToJson", "cdsFilePath", "sourceRoot", "cdsCommand", "cacheDir", "projectMap", "projectDir", "resolvedCdsFilePath", "fileExists", "cdsVersion", "getCdsVersion", "versionInfo", "spawnOptions", "createSpawnOptions", "project", "relativePath", "shouldUseProjectLevelCompilation", "compileProjectLevel", "shouldCompileIndividually", "cdsExtractorLog", "compileRootFileAsProject", "error", "_versionInfo", "projectAbsolutePath", "capDirectories", "existingDirectories", "dir", "dirPath", "dirExists", "allCdsFiles", "globSync", "cdsFileParents", "file", "firstDir", "relativeOutputPath", "projectJsonOutPath", "projectSpawnOptions", "compileArgs", "result", "arg", "recursivelyRenameJsonFiles", "_projectDir", "relativeCdsPath", "cdsJsonOutPath", "isDirectBinary", "nodePath", "cleanEnv", "import_child_process", "import_path", "import_shell_quote", "addDiagnostic", "filePath", "message", "codeqlExePath", "sourceId", "sourceName", "severity", "logPrefix", "escapedMessage", "cdsExtractorLog", "err", "addCompilationDiagnostic", "cdsFilePath", "errorMessage", "addJavaScriptExtractorDiagnostic", "attemptCompilation", "task", "cdsCommand", "cacheDir", "dependencyGraph", "attemptId", "startTime", "attempt", "primarySourceFile", "compilationResult", "compileCdsToJson", "key", "value", "endTime", "error", "createCompilationTask", "type", "sourceFiles", "expectedOutputFiles", "projectDir", "useProjectLevelCompilation", "createCompilationConfig", "useProjectLevel", "executeCompilationTask", "project", "codeqlExePath", "config", "compilationAttempt", "lastError", "sourceFile", "addCompilationDiagnostic", "cdsExtractorLog", "executeCompilationTasks", "compilationStartTime", "allTasks", "errorMessage", "hasFailedTasks", "compilationEndTime", "orchestrateCompilation", "projectCacheDirMap", "planCompilationTasks", "hasFailures", "statusReport", "generateStatusReport", "determineCdsCommand", "compilationConfig", "tasks", "cdsFile", "expectedOutput", "totalTasks", "sum", "import_path", "import_path", "import_fs", "import_path", "determineCdsFilesForProjectDir", "sourceRootDir", "projectDir", "normalizedSourceRoot", "normalizedProjectDir", "sync", "file", "error", "cdsExtractorLog", "determineCdsProjectsUnderSourceDir", "foundProjects", "packageJsonFiles", "cdsFiles", "candidateDirectories", "packageJsonFile", "cdsFile", "cdsDir", "projectRoot", "findProjectRootFromCdsFile", "dir", "isLikelyCdsProject", "shouldAdd", "existingProjects", "existingProject", "existingAbsPath", "parentPackageJsonPath", "parentPackageJson", "readPackageJsonFile", "hasStandardCdsContent", "hasDirectCdsContent", "currentPackageJsonPath", "currentPackageJson", "extractCdsImports", "filePath", "content", "imports", "usingRegex", "match", "path", "cdsFileDir", "currentDir", "currentDirName", "parentDir", "hasDbDir", "hasSrvDir", "hasAppDir", "hasStandardCdsDirectories", "hasDirectCdsFiles", "hasCdsFiles", "hasPackageJsonWithCapDeps", "packageJsonPath", "packageJson", "standardLocations", "location", "determineCdsFilesToCompile", "project", "filesToCompile", "computeExpectedOutputFiles", "absoluteProjectDir", "hasCapStructure", "hasTypicalCapDirectoryStructure", "hasCapDeps", "importedFiles", "absoluteFilePath", "importInfo", "rootFiles", "relativePath", "expectedFiles", "usesProjectLevelCompilation", "projectModelFile", "hasTypicalCapDirectoryStructure", "cdsFiles", "hasDbFiles", "file", "hasSrvFiles", "dir", "hasPackageJsonWithCapDeps", "packageJsonPath", "packageJson", "readPackageJsonFile", "dependencies", "buildBasicCdsProjectDependencyGraph", "sourceRootDir", "cdsExtractorLog", "projectDirs", "determineCdsProjectsUnderSourceDir", "projectMap", "projectDir", "absoluteProjectDir", "cdsFiles", "determineCdsFilesForProjectDir", "packageJsonPath", "packageJson", "readPackageJsonFile", "project", "relativeFilePath", "absoluteFilePath", "imports", "extractCdsImports", "enrichedImports", "importInfo", "enrichedImport", "importedFilePath", "normalizedImportedPath", "relativeToDirPath", "resolvedPath", "normalizedResolvedPath", "error", "otherProjectDir", "otherProject", "otherProjectAbsoluteDir", "otherFile", "dependencies", "moduleName", "projectPlan", "determineCdsFilesToCompile", "buildCdsProjectDependencyGraph", "startTime", "dependencyGraph", "basicProjectMap", "basicProject", "cdsProject", "sum", "endTime", "errorMessage", "import_child_process", "runJavaScriptExtractor", "sourceRoot", "autobuildScriptPath", "codeqlExePath", "cdsExtractorLog", "result", "errorMessage", "addJavaScriptExtractorDiagnostic", "import_child_process", "import_fs", "import_os", "import_path", "getPlatformInfo", "osPlatform", "osPlatformArch", "isWindows", "getCodeQLExePath", "codeqlExeName", "codeqlDist", "codeqlPathFromDist", "cdsExtractorLog", "versionOutput", "versionInfo", "resolvedPathFromVersion", "parseError", "error", "errorMessage", "getJavaScriptExtractorRoot", "codeqlExePath", "jsExtractorRoot", "setupJavaScriptExtractorEnv", "getAutobuildScriptPath", "autobuildScriptName", "configureLgtmIndexFilters", "excludeFilters", "allowedExcludePatterns", "line", "pattern", "lgtmIndexFiltersPatterns", "setupAndValidateEnvironment", "sourceRoot", "errorMessages", "platformInfo", "dirExists", "autobuildScriptPath", "import_child_process", "import_crypto", "import_fs", "import_path", "import_child_process", "import_shell_quote", "availableVersionsCache", "cacheStats", "total", "checkVersionCompatibility", "cdsVersion", "cdsDkVersion", "parsedCds", "parseSemanticVersion", "parsedCdsDk", "majorVersionsMatch", "minorVersionsMatch", "compareVersions", "a", "b", "findBestAvailableVersion", "availableVersions", "requiredVersion", "parsedVersions", "v", "satisfyingVersions", "satisfiesRange", "getAvailableVersions", "packageName", "escapedPackageName", "output", "versions", "versionArray", "error", "cdsExtractorLog", "parseSemanticVersion", "version", "cleanVersion", "semverRegex", "match", "isSatisfyingVersion", "resolvedVersion", "requestedVersion", "parsedResolved", "satisfiesRange", "resolveCdsVersions", "cdsVersion", "cdsDkVersion", "cdsVersions", "getAvailableVersions", "cdsDkVersions", "resolvedCdsVersion", "findBestAvailableVersion", "resolvedCdsDkVersion", "cdsExactMatch", "cdsDkExactMatch", "cdsSatisfiesRange", "cdsDkSatisfiesRange", "isFallback", "warning", "compatibility", "checkVersionCompatibility", "shouldShowWarning", "range", "rangeVersion", "compareVersions", "cacheSubDirName", "addDependencyVersionWarning", "packageJsonPath", "warningMessage", "codeqlExePath", "cdsExtractorLog", "err", "extractUniqueDependencyCombinations", "projects", "combinations", "project", "cdsVersion", "cdsDkVersion", "resolvedVersions", "resolveCdsVersions", "resolvedCdsVersion", "resolvedCdsDkVersion", "rest", "statusMsg", "actualCdsVersion", "actualCdsDkVersion", "hash", "installDependencies", "dependencyGraph", "sourceRoot", "dependencyCombinations", "combination", "isFallback", "fallbackNote", "cacheRootDir", "projectCacheDirMap", "successfulInstallations", "cacheDirName", "cacheDir", "packageJson", "samplePackageJsonPath", "installDependenciesInCache", "projectDir", "p_cdsVersion", "p_cdsDkVersion", "projectResolvedVersions", "projectActualCdsVersion", "projectActualCdsDkVersion", "combinationActualCdsVersion", "combinationActualCdsDkVersion", "warning", "errorMessage", "import_path", "USAGE_MESSAGE", "resolveSourceRoot", "sourceRoot", "normalizedPath", "validateArguments", "args", "rawSourceRoot", "error", "validationResult", "validateArguments", "sourceRoot", "setSourceRootDirectory", "logExtractorStart", "logPerformanceTrackingStart", "envSetupSuccess", "errorMessages", "codeqlExePath", "autobuildScriptPath", "platformInfo", "setupAndValidateEnvironment", "logPerformanceTrackingStop", "codeqlExe", "cdsExtractorLog", "logExtractorStop", "dependencyGraph", "buildCdsProjectDependencyGraph", "logPerformanceMilestone", "projectDir", "project", "allCdsFiles", "sync", "globError", "error", "projectCacheDirMap", "installDependencies", "cdsFilePathsToProcess", "orchestrateCompilation", "addCompilationDiagnostic", "configureLgtmIndexFilters", "extractionStartTime", "extractorResult", "runJavaScriptExtractor", "extractionEndTime", "totalDuration", "generateStatusReport"]
}
