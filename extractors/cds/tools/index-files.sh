#!/bin/bash

set -eu

echo "Indexing CDS files"

# Check if the list of files is empty
response_file="$1"

# If the response_file doesn't exist, terminate:
if [ ! -f "$response_file" ]; then
    echo "codeql database index-files --language cds terminated early as response file '$response_file' does not exist. This is because no CDS files were selected or found."
    exit 0
fi

# If the response_file is empty, terminate
if [ ! -s "$response_file" ]; then
    echo "codeql database index-files --language cds terminated early as response file '$response_file' is empty. This is because no CDS files were selected or found."
    exit 0
fi

# Determine if we have the cds command available, and if not, install the cds development kit
# in the appropriate directories
if ! command -v cds &> /dev/null
then
    echo "Pre-installing cds compiler"

    # Find all the directories containing a package.json with a dependency on @sap/cds, where
    # the directory contains at least one of the files listed in the response file (e.g. the
    # cds files we want to extract).
    #
    # We then install the cds development kit (@sap/cds-dk) in each directory, which makes the
    # `cds` command usable from the npx command within that directory.
    #
    # Nested package.json files simply cause the package to be installed in the parent node_modules
    # directory.
    #
    # We also ensure we skip node_modules, as we can end up in a recursive loop
    find . -type d -name node_modules -prune -false -o -type f \( -iname 'package.json' \) -exec grep -ql '@sap/cds' {} \; -execdir bash -c "grep -q \"^\$(pwd)\(/\|$\)\" \"$response_file\"" \; -execdir bash -c "echo \"Installing @sap/cds-dk into \$(pwd) to enable CDS compilation.\"" \; -execdir npm install --silent @sap/cds-dk@8.6.1 \; -execdir npm install --silent \;

    # Use the npx command to dynamically install the cds development kit (@sap/cds-dk) package if necessary,
    # which then provides the cds command line tool in directories which are not covered by the package.json
    # install command approach above
    cds_command="npx -y --package @sap/cds-dk cds"
else
    cds_command="cds"
fi

echo "Processing CDS files to JSON"

# Run the cds compile command on each file in the response file in order to generate
# the JSON data we need. Move the generated ".json" files from the temporary output
# to the original directory and rename them to ".cds.json" so that the JS extractor
# can distinguish them from regular JSON files / extract them as CDS files.
while IFS= read -r _cds_file_path; do
    # The cds compile command chooses how it outputs the JSON. If it creates output
    # files in a directory, then it will create the directory when it runs. If it
    # creates a single output file, then it will create the file when it runs. We
    # create the output path by simply appending ".json" to the input file path,
    # such that there is nothing further to do if the output is a single file.
    _cds_compile_json_out="${_cds_file_path}.json"
    # Remove any existing output directory to avoid conflicts.
    if [ -d "$_cds_compile_json_out" ]; then
        echo "WARNING:  overwriting existing temporary output path ${_cds_compile_json_out}."
        rm -rf "$_cds_compile_json_out"
    fi
    _cds_file_err_path="${_cds_file_path}.err"
    echo "Compiling JSON for source CDS file $_cds_file_path to output path: $_cds_compile_json_out"
    if ! $cds_command compile "$_cds_file_path" --to json --dest "$_cds_compile_json_out" --locations 2> "$_cds_file_err_path"; then
        stderr_truncated=`grep "^\[ERROR\]" "$_cds_file_err_path" | tail -n 4`
        _error_msg=$'ERROR: Could not compile the CDS file '"$_cds_file_path"$'.\nReported error(s):\n```\n'"$stderr_truncated"$'\n```'
        echo "$_error_msg"
        # Log the error message as a diagnostic which appears on the Tools status page.
        "$CODEQL_DIST/codeql" database add-diagnostic --extractor-name cds --ready-for-status-page --source-id cds/compilation-failure --source-name "Failure to compile one or more SAP CAP CDS files" --severity error --markdown-message "$_error_msg" --file-path "$_cds_file_path" "$CODEQL_EXTRACTOR_CDS_WIP_DATABASE"
        # Continue to the next file.
        continue
    fi
    # Cleanup the error file if it exists and is empty.
    if [[ -f "$_cds_file_err_path" && -s "$_cds_file_err_path" ]]; then
        rm -f "$_cds_file_err_path"
    fi
    # Replace the ".json" extension with a ".cds.json" extension in the files
    # generated by the cds compile command. Due to inconsistencies between
    # different versions of the cds compiler, and contrary to the command-line
    # documentation for the "cds compile" command, the output may be generated
    # as a single file in the current directory, or as one or more files in an
    # output directory.
    if [ -f "$_cds_compile_json_out" ]; then
        echo "Compiled CDS source file from $_cds_file_path to $_cds_compile_json_out"
    elif [ -d "$_cds_compile_json_out" ]; then
        echo "CDS compiler generated JSON to output directory: $_cds_compile_json_out"
        if ls "$_cds_compile_json_out"/*.json 1> /dev/null 2>&1; then
            for _output_json_file in "$_cds_compile_json_out"/*.json; do
                _cds_json_file_path="${_output_json_file%.json}.cds.json"
                echo "Renaming CDS compiler generated output '.json' file to $_cds_json_file_path"
                mv "$_output_json_file" "$_cds_json_file_path"
            done
        else
            _error_msg="ERROR: Detected no '.json' files in CDS compiler output directory: $_cds_compile_json_out"
            # Log the error message as a diagnostic which appears on the Tools status page.
            "$CODEQL_DIST/codeql" database add-diagnostic --extractor-name cds --ready-for-status-page --source-id cds/compilation-failure --source-name "Failure to find one or more compiled SAP CAP CDS JSON files" --severity error --markdown-message "$_error_msg" --file-path "$_cds_file_path" "$CODEQL_EXTRACTOR_CDS_WIP_DATABASE"
        fi
    else
        _error_msg="ERROR: Detected no output directory or file for CDS compiler output: $_cds_compile_json_out"
        # Log the error message as a diagnostic which appears on the Tools status page.
        "$CODEQL_DIST/codeql" database add-diagnostic --extractor-name cds --ready-for-status-page --source-id cds/compilation-failure --source-name "Failure to find one or more compiled SAP CAP CDS JSON files" --severity error --markdown-message "$_error_msg" --file-path "$_cds_file_path" "$CODEQL_EXTRACTOR_CDS_WIP_DATABASE"
    fi
done < "$response_file"

# Check if the JS extractor variables are set, and set them if not
if [ -z "${CODEQL_EXTRACTOR_JAVASCRIPT_ROOT:-}" ]; then
    # Find the JavaScript extractor location
    export CODEQL_EXTRACTOR_JAVASCRIPT_ROOT="$("$CODEQL_DIST/codeql" resolve extractor --language=javascript)"    

    # Set the JAVASCRIPT extractor environment variables to the same as the CDS extractor environment variables
    # so that the JS extractor will write to the CDS database
    export CODEQL_EXTRACTOR_JAVASCRIPT_WIP_DATABASE="$CODEQL_EXTRACTOR_CDS_WIP_DATABASE"
    export CODEQL_EXTRACTOR_JAVASCRIPT_DIAGNOSTIC_DIR="$CODEQL_EXTRACTOR_CDS_DIAGNOSTIC_DIR"
    export CODEQL_EXTRACTOR_JAVASCRIPT_LOG_DIR="$CODEQL_EXTRACTOR_CDS_LOG_DIR"
    export CODEQL_EXTRACTOR_JAVASCRIPT_SCRATCH_DIR="$CODEQL_EXTRACTOR_CDS_SCRATCH_DIR"
    export CODEQL_EXTRACTOR_JAVASCRIPT_TRAP_DIR="$CODEQL_EXTRACTOR_CDS_TRAP_DIR"
    export CODEQL_EXTRACTOR_JAVASCRIPT_SOURCE_ARCHIVE_DIR="$CODEQL_EXTRACTOR_CDS_SOURCE_ARCHIVE_DIR"
fi

# Check if LGTM_INDEX_FILTERS is already set
# This typically happens if "paths" or "paths-ignore" are set in the LGTM.yml file
if [ -z "${LGTM_INDEX_FILTERS:-}" ]; then
    exclude_filters=""
else
    echo $'Found \$LGTM_INDEX_FILTERS already set to:\n'"$LGTM_INDEX_FILTERS"
    # If it is set, we will try to honour the paths-ignore filter
    # Split by \n and find all the entries that start with exclude, excluding "exclude:**/*" and "exclude:**/*.*"
    # and then join them back together with \n
    exclude_filters=$'\n'"$(echo "$LGTM_INDEX_FILTERS" | grep '^exclude' | grep -v 'exclude:\*\*/\*\|exclude:\*\*/\*\.\*')"
fi

# Enable extraction of the cds.json files only
export LGTM_INDEX_FILTERS=$'exclude:**/*.*\ninclude:**/*.cds.json\ninclude:**/*.cds\nexclude:**/node_modules/**/*.*'"$exclude_filters"
echo "Setting \$LGTM_INDEX_FILTERS to:\n$LGTM_INDEX_FILTERS"
export LGTM_INDEX_TYPESCRIPT="NONE"
# Configure to copy over the CDS files as well, by pretending they are JSON
export LGTM_INDEX_FILETYPES=".cds:JSON"
# Ignore the LGTM_INDEX_INCLUDE variable for this purpose, as it may
# refer explicitly to .ts or .js files
unset LGTM_INDEX_INCLUDE

echo "Extracting the cds.json files"

# Invoke the JavaScript autobuilder to index the .cds.json files only
"$CODEQL_EXTRACTOR_JAVASCRIPT_ROOT"/tools/autobuild.sh